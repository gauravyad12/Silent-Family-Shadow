/*! For license information please see build.js.LICENSE.txt */ ! function(t) {
    var e = {};

    function n(i) {
        if (e[i]) return e[i].exports;
        var r = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
    }
    n.m = t, n.c = e, n.d = function(t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    }, n.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, n.t = function(t, e) {
        if (1 & e && (t = n(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var i = Object.create(null);
        if (n.r(i), Object.defineProperty(i, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var r in t) n.d(i, r, function(e) {
                return t[e]
            }.bind(null, r));
        return i
    }, n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return n.d(e, "a", e), e
    }, n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, n.p = "/", n(n.s = 12)
}([function(t, e, n) {
    "use strict";

    function i(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = void 0;
    var o = function() {
        function t(e) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            i(this, t), this.$el = e, this.componentName = "", this.parent = null, this.root = this, this.definitions = [], this.refs = {}, this._componentInstances = [], n && this.init(n)
        }
        var e, n, o;
        return e = t, (n = [{
            key: "$one",
            value: function(t) {
                return this.$el.querySelector(t)
            }
        }, {
            key: "$all",
            value: function(t) {
                return [].slice.call(this.$el.querySelectorAll(t))
            }
        }, {
            key: "init",
            value: function(t) {
                this.definitions = t, this.parse(), this.root === this && this.onAppReady()
            }
        }, {
            key: "onAppReady",
            value: function() {
                this._componentInstances.forEach((function(t) {
                    return t.onAppReady()
                }))
            }
        }, {
            key: "dispose",
            value: function() {
                this.disposeChildren(), this.destroy()
            }
        }, {
            key: "disposeChildren",
            value: function() {
                this._componentInstances.forEach((function(t) {
                    t.dispose()
                })), this._componentInstances = [], this.refs = {}
            }
        }, {
            key: "replaceContent",
            value: function(t) {
                this.disposeChildren(), this.$el.innerHTML = t, this.parse()
            }
        }, {
            key: "destroy",
            value: function() {
                this.parent && this.$el.parentNode && this.$el.parentNode === this.parent.$el && this.parent.$el.removeChild(this.$el), this.parent = null, this.$el = null
            }
        }, {
            key: "findInstance",
            value: function(t) {
                var e = this._componentInstances.filter((function(e) {
                    return e.componentName === t
                }));
                if (e && e.length) return e[0];
                for (var n = 0, i = this._componentInstances.length; n < i; n++)
                    if (void 0 !== (e = this._componentInstances[n].findInstance(t))) return e
            }
        }, {
            key: "findAllInstances",
            value: function(t) {
                for (var e = this._componentInstances.filter((function(e) {
                        return e.componentName === t
                    })), n = 0, i = this._componentInstances.length; n < i; n++) e = e.concat(this._componentInstances[n].findAllInstances(t));
                return e
            }
        }, {
            key: "parse",
            value: function() {
                var t = this;
                ! function t(e, n) {
                    var i, r;
                    e = null == (r = e) ? [] : Array.isArray(r) ? r : [r], e = [].slice.call(e);
                    for (var o = 0, s = e.length; o < s; o++)(i = e[o]) && i.hasAttribute && i.hasAttribute("data-component") ? n(i) : i.childNodes && i.childNodes.length && t([].slice.call(i.childNodes), n)
                }(this.$el, (function(e) {
                    var n, i, r = e && e.getAttribute ? e.getAttribute("data-component") : "";
                    1 === e.nodeType && r && ("FORM" === e.tagName && console.warn("FORM tag does not support data-component. You should encapsulate the <form> with a <div> in component ".concat(r)), t.definitions instanceof Function ? n = t.definitions(r) : t.definitions instanceof Object && (n = t.definitions[r]), n ? (e.removeAttribute("data-component"), (i = new n(e)).componentName = r, i.parent = t, i.root = t.root, i.init(t.definitions), t._componentInstances.push(i), e.getAttribute("data-ref") && (t.refs[e.getAttribute("data-ref")] = i)) : console.warn("Can't find component '".concat(r, "'")))
                })), this.ready()
            }
        }, {
            key: "ready",
            value: function() {}
        }]) && r(e.prototype, n), o && r(e, o), t
    }();
    e.default = o
}, function(t, e, n) {
    "use strict";
    n.r(e), e.default = function() {
        var t = {
            _allEvents: Object.create(null),
            use: function(e, n) {
                return e(t, n) || t
            },
            on: function(e, n, i) {
                var r = t._allEvents[e] || (t._allEvents[e] = []);
                var o = i ? function i() {
                    i.called || (t.off(e, i), n.apply(n, arguments), i.called = !0)
                } : n;
                return o.__sourceString = n.toString(), r.push(o), t
            },
            once: function(e, n) {
                return t.on(e, n, !0), t
            },
            off: function(e, n) {
                if (n && t._allEvents[e]) {
                    var i = n.toString();
                    t._allEvents[e] = t._allEvents[e].filter((function(t) {
                        return t.__sourceString !== i
                    }))
                } else e ? t._allEvents[e] = [] : t._allEvents = Object.create(null);
                return t
            },
            emit: function(e) {
                if ("*" !== e) {
                    var n = [].slice.call(arguments);
                    (t._allEvents[e] || []).map((function(t) {
                        t.apply(t, n.slice(1))
                    })), (t._allEvents["*"] || []).map((function(t) {
                        t.apply(t, n)
                    }))
                }
                return t
            }
        };
        return t
    }
}, function(t, e, n) {
    (function(e) {
        var n;
        n = function() {
            "use strict";
            var t = function(t) {
                var e = t.id,
                    n = t.viewBox,
                    i = t.content;
                this.id = e, this.viewBox = n, this.content = i
            };

            function n(t, e) {
                return t(e = {
                    exports: {}
                }, e.exports), e.exports
            }
            t.prototype.stringify = function() {
                return this.content
            }, t.prototype.toString = function() {
                return this.stringify()
            }, t.prototype.destroy = function() {
                var t = this;
                ["id", "viewBox", "content"].forEach((function(e) {
                    return delete t[e]
                }))
            }, "undefined" != typeof window ? window : void 0 !== e || "undefined" != typeof self && self;
            var i = n((function(t, e) {
                    t.exports = function() {
                        function t(t) {
                            return t && "object" == typeof t && "[object RegExp]" !== Object.prototype.toString.call(t) && "[object Date]" !== Object.prototype.toString.call(t)
                        }

                        function e(e, n) {
                            var r;
                            return n && !0 === n.clone && t(e) ? i((r = e, Array.isArray(r) ? [] : {}), e, n) : e
                        }

                        function n(n, r, o) {
                            var s = n.slice();
                            return r.forEach((function(r, a) {
                                void 0 === s[a] ? s[a] = e(r, o) : t(r) ? s[a] = i(n[a], r, o) : -1 === n.indexOf(r) && s.push(e(r, o))
                            })), s
                        }

                        function i(r, o, s) {
                            var a = Array.isArray(o),
                                c = (s || {
                                    arrayMerge: n
                                }).arrayMerge || n;
                            return a ? Array.isArray(r) ? c(r, o, s) : e(o, s) : function(n, r, o) {
                                var s = {};
                                return t(n) && Object.keys(n).forEach((function(t) {
                                    s[t] = e(n[t], o)
                                })), Object.keys(r).forEach((function(a) {
                                    t(r[a]) && n[a] ? s[a] = i(n[a], r[a], o) : s[a] = e(r[a], o)
                                })), s
                            }(r, o, s)
                        }
                        return i.all = function(t, e) {
                            if (!Array.isArray(t) || t.length < 2) throw new Error("first argument should be an array with at least two elements");
                            return t.reduce((function(t, n) {
                                return i(t, n, e)
                            }))
                        }, i
                    }()
                })),
                r = n((function(t, e) {
                    e.default = {
                        svg: {
                            name: "xmlns",
                            uri: "http://www.w3.org/2000/svg"
                        },
                        xlink: {
                            name: "xmlns:xlink",
                            uri: "http://www.w3.org/1999/xlink"
                        }
                    }, t.exports = e.default
                })),
                o = r.svg,
                s = r.xlink,
                a = {};
            a[o.name] = o.uri, a[s.name] = s.uri;
            var c = function(t, e) {
                return void 0 === t && (t = ""), "<svg " + function(t) {
                    return Object.keys(t).map((function(e) {
                        return e + '="' + t[e].toString().replace(/"/g, "&quot;") + '"'
                    })).join(" ")
                }(i(a, e || {})) + ">" + t + "</svg>"
            };
            return function(t) {
                function e() {
                    t.apply(this, arguments)
                }
                t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
                var n = {
                    isMounted: {}
                };
                return n.isMounted.get = function() {
                    return !!this.node
                }, e.createFromExistingNode = function(t) {
                    return new e({
                        id: t.getAttribute("id"),
                        viewBox: t.getAttribute("viewBox"),
                        content: t.outerHTML
                    })
                }, e.prototype.destroy = function() {
                    this.isMounted && this.unmount(), t.prototype.destroy.call(this)
                }, e.prototype.mount = function(t) {
                    if (this.isMounted) return this.node;
                    var e = "string" == typeof t ? document.querySelector(t) : t,
                        n = this.render();
                    return this.node = n, e.appendChild(n), n
                }, e.prototype.render = function() {
                    var t = this.stringify();
                    return function(t) {
                        var e = !!document.importNode,
                            n = (new DOMParser).parseFromString(t, "image/svg+xml").documentElement;
                        return e ? document.importNode(n, !0) : n
                    }(c(t)).childNodes[0]
                }, e.prototype.unmount = function() {
                    this.node.parentNode.removeChild(this.node)
                }, Object.defineProperties(e.prototype, n), e
            }(t)
        }, t.exports = n()
    }).call(this, n(8))
}, function(t, e, n) {
    (function(e) {
        var n;
        n = function() {
            "use strict";

            function t(t, e) {
                return t(e = {
                    exports: {}
                }, e.exports), e.exports
            }
            "undefined" != typeof window ? window : void 0 !== e || "undefined" != typeof self && self;
            var n = t((function(t, e) {
                    t.exports = function() {
                        function t(t) {
                            return t && "object" == typeof t && "[object RegExp]" !== Object.prototype.toString.call(t) && "[object Date]" !== Object.prototype.toString.call(t)
                        }

                        function e(e, n) {
                            var r;
                            return n && !0 === n.clone && t(e) ? i((r = e, Array.isArray(r) ? [] : {}), e, n) : e
                        }

                        function n(n, r, o) {
                            var s = n.slice();
                            return r.forEach((function(r, a) {
                                void 0 === s[a] ? s[a] = e(r, o) : t(r) ? s[a] = i(n[a], r, o) : -1 === n.indexOf(r) && s.push(e(r, o))
                            })), s
                        }

                        function i(r, o, s) {
                            var a = Array.isArray(o),
                                c = (s || {
                                    arrayMerge: n
                                }).arrayMerge || n;
                            return a ? Array.isArray(r) ? c(r, o, s) : e(o, s) : function(n, r, o) {
                                var s = {};
                                return t(n) && Object.keys(n).forEach((function(t) {
                                    s[t] = e(n[t], o)
                                })), Object.keys(r).forEach((function(a) {
                                    t(r[a]) && n[a] ? s[a] = i(n[a], r[a], o) : s[a] = e(r[a], o)
                                })), s
                            }(r, o, s)
                        }
                        return i.all = function(t, e) {
                            if (!Array.isArray(t) || t.length < 2) throw new Error("first argument should be an array with at least two elements");
                            return t.reduce((function(t, n) {
                                return i(t, n, e)
                            }))
                        }, i
                    }()
                })),
                i = t((function(t, e) {
                    e.default = {
                        svg: {
                            name: "xmlns",
                            uri: "http://www.w3.org/2000/svg"
                        },
                        xlink: {
                            name: "xmlns:xlink",
                            uri: "http://www.w3.org/1999/xlink"
                        }
                    }, t.exports = e.default
                })),
                r = i.svg,
                o = i.xlink,
                s = {};
            s[r.name] = r.uri, s[o.name] = o.uri;
            var a, c = function(t, e) {
                    return void 0 === t && (t = ""), "<svg " + function(t) {
                        return Object.keys(t).map((function(e) {
                            return e + '="' + t[e].toString().replace(/"/g, "&quot;") + '"'
                        })).join(" ")
                    }(n(s, e || {})) + ">" + t + "</svg>"
                },
                l = i.svg,
                u = i.xlink,
                h = {
                    attrs: (a = {
                        style: ["position: absolute", "width: 0", "height: 0"].join("; "),
                        "aria-hidden": "true"
                    }, a[l.name] = l.uri, a[u.name] = u.uri, a)
                },
                p = function(t) {
                    this.config = n(h, t || {}), this.symbols = []
                };
            p.prototype.add = function(t) {
                var e = this.symbols,
                    n = this.find(t.id);
                return n ? (e[e.indexOf(n)] = t, !1) : (e.push(t), !0)
            }, p.prototype.remove = function(t) {
                var e = this.symbols,
                    n = this.find(t);
                return !!n && (e.splice(e.indexOf(n), 1), n.destroy(), !0)
            }, p.prototype.find = function(t) {
                return this.symbols.filter((function(e) {
                    return e.id === t
                }))[0] || null
            }, p.prototype.has = function(t) {
                return null !== this.find(t)
            }, p.prototype.stringify = function() {
                var t = this.config.attrs,
                    e = this.symbols.map((function(t) {
                        return t.stringify()
                    })).join("");
                return c(e, t)
            }, p.prototype.toString = function() {
                return this.stringify()
            }, p.prototype.destroy = function() {
                this.symbols.forEach((function(t) {
                    return t.destroy()
                }))
            };
            var f = function(t) {
                var e = t.id,
                    n = t.viewBox,
                    i = t.content;
                this.id = e, this.viewBox = n, this.content = i
            };
            f.prototype.stringify = function() {
                return this.content
            }, f.prototype.toString = function() {
                return this.stringify()
            }, f.prototype.destroy = function() {
                var t = this;
                ["id", "viewBox", "content"].forEach((function(e) {
                    return delete t[e]
                }))
            };
            var d = function(t) {
                    var e = !!document.importNode,
                        n = (new DOMParser).parseFromString(t, "image/svg+xml").documentElement;
                    return e ? document.importNode(n, !0) : n
                },
                m = function(t) {
                    function e() {
                        t.apply(this, arguments)
                    }
                    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
                    var n = {
                        isMounted: {}
                    };
                    return n.isMounted.get = function() {
                        return !!this.node
                    }, e.createFromExistingNode = function(t) {
                        return new e({
                            id: t.getAttribute("id"),
                            viewBox: t.getAttribute("viewBox"),
                            content: t.outerHTML
                        })
                    }, e.prototype.destroy = function() {
                        this.isMounted && this.unmount(), t.prototype.destroy.call(this)
                    }, e.prototype.mount = function(t) {
                        if (this.isMounted) return this.node;
                        var e = "string" == typeof t ? document.querySelector(t) : t,
                            n = this.render();
                        return this.node = n, e.appendChild(n), n
                    }, e.prototype.render = function() {
                        var t = this.stringify();
                        return d(c(t)).childNodes[0]
                    }, e.prototype.unmount = function() {
                        this.node.parentNode.removeChild(this.node)
                    }, Object.defineProperties(e.prototype, n), e
                }(f),
                g = {
                    autoConfigure: !0,
                    mountTo: "body",
                    syncUrlsWithBaseTag: !1,
                    listenLocationChangeEvent: !0,
                    locationChangeEvent: "locationChange",
                    locationChangeAngularEmitter: !1,
                    usagesToUpdate: "use[*|href]",
                    moveGradientsOutsideSymbol: !1
                },
                v = function(t) {
                    return Array.prototype.slice.call(t, 0)
                },
                y = function() {
                    return /firefox/i.test(navigator.userAgent)
                },
                b = function() {
                    return /msie/i.test(navigator.userAgent) || /trident/i.test(navigator.userAgent)
                },
                x = function() {
                    return /edge/i.test(navigator.userAgent)
                },
                w = function(t) {
                    return (t || window.location.href).split("#")[0]
                },
                _ = function(t) {
                    angular.module("ng").run(["$rootScope", function(e) {
                        e.$on("$locationChangeSuccess", (function(e, n, i) {
                            var r, o, s;
                            r = t, o = {
                                oldUrl: i,
                                newUrl: n
                            }, (s = document.createEvent("CustomEvent")).initCustomEvent(r, !1, !1, o), window.dispatchEvent(s)
                        }))
                    }])
                },
                M = function(t, e) {
                    return void 0 === e && (e = "linearGradient, radialGradient, pattern, mask, clipPath"), v(t.querySelectorAll("symbol")).forEach((function(t) {
                        v(t.querySelectorAll(e)).forEach((function(e) {
                            t.parentNode.insertBefore(e, t)
                        }))
                    })), t
                },
                S = i.xlink.uri,
                T = /[{}|\\\^\[\]`"<>]/g;

            function E(t) {
                return t.replace(T, (function(t) {
                    return "%" + t[0].charCodeAt(0).toString(16).toUpperCase()
                }))
            }
            var C, A = ["clipPath", "colorProfile", "src", "cursor", "fill", "filter", "marker", "markerStart", "markerMid", "markerEnd", "mask", "stroke", "style"],
                L = A.map((function(t) {
                    return "[" + t + "]"
                })).join(","),
                P = function(t, e, n, i) {
                    var r = E(n),
                        o = E(i);
                    (function(t, e) {
                        return v(t).reduce((function(t, n) {
                            if (!n.attributes) return t;
                            var i = v(n.attributes),
                                r = e ? i.filter(e) : i;
                            return t.concat(r)
                        }), [])
                    })(t.querySelectorAll(L), (function(t) {
                        var e = t.localName,
                            n = t.value;
                        return -1 !== A.indexOf(e) && -1 !== n.indexOf("url(" + r)
                    })).forEach((function(t) {
                            return t.value = t.value.replace(new RegExp(r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), o)
                        })),
                        function(t, e, n) {
                            v(t).forEach((function(t) {
                                var i = t.getAttribute("xlink:href");
                                if (i && 0 === i.indexOf(e)) {
                                    var r = i.replace(e, n);
                                    t.setAttributeNS(S, "xlink:href", r)
                                }
                            }))
                        }(e, r, o)
                },
                O = "mount",
                R = "symbol_mount",
                I = function(t) {
                    function e(e) {
                        var i = this;
                        void 0 === e && (e = {}), t.call(this, n(g, e));
                        var r, o = (r = r || Object.create(null), {
                            on: function(t, e) {
                                (r[t] || (r[t] = [])).push(e)
                            },
                            off: function(t, e) {
                                r[t] && r[t].splice(r[t].indexOf(e) >>> 0, 1)
                            },
                            emit: function(t, e) {
                                (r[t] || []).map((function(t) {
                                    t(e)
                                })), (r["*"] || []).map((function(n) {
                                    n(t, e)
                                }))
                            }
                        });
                        this._emitter = o, this.node = null;
                        var s = this.config;
                        if (s.autoConfigure && this._autoConfigure(e), s.syncUrlsWithBaseTag) {
                            var a = document.getElementsByTagName("base")[0].getAttribute("href");
                            o.on(O, (function() {
                                return i.updateUrls("#", a)
                            }))
                        }
                        var c = this._handleLocationChange.bind(this);
                        this._handleLocationChange = c, s.listenLocationChangeEvent && window.addEventListener(s.locationChangeEvent, c), s.locationChangeAngularEmitter && _(s.locationChangeEvent), o.on(O, (function(t) {
                            s.moveGradientsOutsideSymbol && M(t)
                        })), o.on(R, (function(t) {
                            var e;
                            s.moveGradientsOutsideSymbol && M(t.parentNode), (b() || x()) && (e = [], v(t.querySelectorAll("style")).forEach((function(t) {
                                t.textContent += "", e.push(t)
                            })))
                        }))
                    }
                    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
                    var i = {
                        isMounted: {}
                    };
                    return i.isMounted.get = function() {
                        return !!this.node
                    }, e.prototype._autoConfigure = function(t) {
                        var e = this.config;
                        void 0 === t.syncUrlsWithBaseTag && (e.syncUrlsWithBaseTag = void 0 !== document.getElementsByTagName("base")[0]), void 0 === t.locationChangeAngularEmitter && (e.locationChangeAngularEmitter = void 0 !== window.angular), void 0 === t.moveGradientsOutsideSymbol && (e.moveGradientsOutsideSymbol = y())
                    }, e.prototype._handleLocationChange = function(t) {
                        var e = t.detail,
                            n = e.oldUrl,
                            i = e.newUrl;
                        this.updateUrls(n, i)
                    }, e.prototype.add = function(e) {
                        var n = t.prototype.add.call(this, e);
                        return this.isMounted && n && (e.mount(this.node), this._emitter.emit(R, e.node)), n
                    }, e.prototype.attach = function(t) {
                        var e = this,
                            n = this;
                        if (n.isMounted) return n.node;
                        var i = "string" == typeof t ? document.querySelector(t) : t;
                        return n.node = i, this.symbols.forEach((function(t) {
                            t.mount(n.node), e._emitter.emit(R, t.node)
                        })), v(i.querySelectorAll("symbol")).forEach((function(t) {
                            var e = m.createFromExistingNode(t);
                            e.node = t, n.add(e)
                        })), this._emitter.emit(O, i), i
                    }, e.prototype.destroy = function() {
                        var t = this.config,
                            e = this.symbols,
                            n = this._emitter;
                        e.forEach((function(t) {
                            return t.destroy()
                        })), n.off("*"), window.removeEventListener(t.locationChangeEvent, this._handleLocationChange), this.isMounted && this.unmount()
                    }, e.prototype.mount = function(t, e) {
                        if (void 0 === t && (t = this.config.mountTo), void 0 === e && (e = !1), this.isMounted) return this.node;
                        var n = "string" == typeof t ? document.querySelector(t) : t,
                            i = this.render();
                        return this.node = i, e && n.childNodes[0] ? n.insertBefore(i, n.childNodes[0]) : n.appendChild(i), this._emitter.emit(O, i), i
                    }, e.prototype.render = function() {
                        return d(this.stringify())
                    }, e.prototype.unmount = function() {
                        this.node.parentNode.removeChild(this.node)
                    }, e.prototype.updateUrls = function(t, e) {
                        if (!this.isMounted) return !1;
                        var n = document.querySelectorAll(this.config.usagesToUpdate);
                        return P(this.node, n, w(t) + "#", w(e) + "#"), !0
                    }, Object.defineProperties(e.prototype, i), e
                }(p),
                D = t((function(t) {
                    var e, n, i, r, o;
                    t.exports = (n = [], i = document, r = i.documentElement.doScroll, (o = (r ? /^loaded|^c/ : /^loaded|^i|^c/).test(i.readyState)) || i.addEventListener("DOMContentLoaded", e = function() {
                        for (i.removeEventListener("DOMContentLoaded", e), o = 1; e = n.shift();) e()
                    }), function(t) {
                        o ? setTimeout(t, 0) : n.push(t)
                    })
                }));
            window.__SVG_SPRITE__ ? C = window.__SVG_SPRITE__ : (C = new I({
                attrs: {
                    id: "__SVG_SPRITE_NODE__"
                }
            }), window.__SVG_SPRITE__ = C);
            var N = function() {
                var t = document.getElementById("__SVG_SPRITE_NODE__");
                t ? C.attach(t) : C.mount(document.body, !0)
            };
            return document.body ? N() : D(N), C
        }, t.exports = n()
    }).call(this, n(8))
}, function(t, e, n) {
    "use strict";

    function i(t) {
        return t && "object" == typeof t && "default" in t ? t.default : t
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(n(1)),
        o = n(10),
        s = i(n(0));

    function a(t, e) {
        return o.match(e)(t)
    }

    function c(t = "") {
        if ("string" != typeof t) throw new Error("str should be a string and is a " + typeof t);
        return "/" + t.replace(/^\//, "")
    }

    function l(t, e = [], n = "") {
        if ("" !== n && (t = t.replace(n, "").replace(/\/\//g, "/")), t = c(t), !Array.isArray(e)) throw new Error("Routes param needs to be an array");
        if (!e.length) throw new Error("You need at lease one entry in routes param");
        const i = e.find(e => {
            const n = a(t, e.path);
            return !!n && (e.params = n.params, !0)
        });
        return !!i && Object.assign({}, i)
    }

    function u(t, e = []) {
        if (!Array.isArray(e)) throw new Error("Routes param needs to be an array");
        if (!e.length) throw new Error("You need at lease one entry in routes param");
        const n = e.find(e => t === e.id);
        return !!n && Object.assign({}, n)
    }
    const h = t => (t => t && "A" === t.nodeName.toUpperCase())(t) ? t : t.parentNode ? h(t.parentNode) : null,
        p = t => c(t.pathname + t.search + (t.hash || ""));

    function f(t, e = window) {
        let n = h(t.target);
        return !(!n || t.defaultPrevented || (t => t.which > 1 || t.metaKey || t.ctrlKey || t.shiftKey || t.altKey)(t) || (t => t.hasAttribute("download") || "external" === t.getAttribute("rel"))(n) || (t => t.hasAttribute("data-router-ignore"))(n) || (t => void 0 !== t.target && "_blank" === t.target)(n) || ((t, e = window) => t.protocol !== e.location.protocol || t.hostname !== e.location.hostname)(n, e) || (t => void 0 !== t.href && t.href.indexOf("mailto:") > -1)(n)) && (t.preventDefault(), !((t, e = window) => t.pathname === e.location.pathname && t.search === e.location.search)(n, e) && p(n))
    }

    function d(t, e, n) {
        if (!n || "function" != typeof n) throw new Error("The callback param should be a function");
        t && t[e] && "function" == typeof t[e] ? t[e](n) : n()
    }
    e.View = class extends s {
        constructor(t) {
            super(t), this.showPage = this.showPage.bind(this), this.showFirstPage = this.showFirstPage.bind(this)
        }
        showFirstPage() {
            return new Promise((t, e) => {
                this.currentPage = this._componentInstances[0], d(this.currentPage, "transitionIn", () => {
                    t(!0)
                })
            })
        }
        showPage(t, e) {
            return this.content = t, this.createSection(t, e).then(t => (this.currentPage = t, this.transitionOutAndAfterIn()))
        }
        transitionOutAndAfterIn() {
            return new Promise((t, e) => {
                d(this._componentInstances[this._componentInstances.length - 1], "transitionOut", t)
            }).then(() => this.transitionIn())
        }
        transitionIn() {
            return new Promise((t, e) => {
                this.disposeChildren(), this.addNewPage(), d(this.currentPage, "transitionIn", t)
            })
        }
        addNewPage() {
            this.currentPage.$el ? (this._componentInstances.push(this.currentPage), this.$el.appendChild(this.currentPage.$el)) : this.$el.appendChild(this.currentPage)
        }
        getCtor(t) {
            return "function" == typeof this.definitions ? this.definitions(t) : "object" == typeof this.definitions ? this.definitions[t] : null
        }
        createSection(t, e) {
            let n = (this.window || window).document.createElement("div");
            if (n.innerHTML = t, 3 === n.firstChild.nodeType) return Promise.resolve(n);
            n = n.firstChild;
            let i = n.getAttribute("data-component"),
                r = this.getCtor(i);
            return n.removeAttribute("data-component"), e && "function" == typeof e || (e = t => Promise.resolve(t)), e(n).then(t => {
                let e = new r(t);
                return e.init(this.definitions), e.componentName = i, e.parent = this, e
            })
        }
    }, e.createRouter = function(t, e = {}, n = window) {
        if (!t || !t._componentInstances) throw new Error("First param of createRouter needs to be an instance of brindille component");
        const i = t.findInstance("View");
        if (!i) throw new Error("There is no View instance in your brindille App");
        let o = !0,
            s = !1;
        const a = r(),
            h = e.baseUrl || "",
            d = e.baseContent || "",
            m = e.getContent || (({
                route: t
            }) => Promise.resolve(t.id)),
            g = e.beforeCompile || (t => Promise.resolve(t)),
            v = e.verbose && !0 === e.verbose,
            y = !(!e.notFoundHandler || "function" != typeof e.notFoundHandler) && e.notFoundHandler,
            b = function(t) {
                if (!Array.isArray(t)) throw new Error("[Router] routes must be an array");
                return t.map(t => {
                    if ("string" == typeof t) return {
                        id: t,
                        path: c(t)
                    };
                    if (!t || !t.id) throw new Error("[Router] routes must either be a string or an object with an id");
                    return {
                        id: t.id,
                        path: c(t.path || t.id)
                    }
                })
            }(Array.isArray(e.routes) && e.routes.length ? e.routes : ["home"]),
            x = b[0];
        let w = null,
            _ = null;

        function M(t) {
            let e = f(t, n);
            e && E(e)
        }

        function S(...t) {
            v && console.log("[Router]", ...t)
        }

        function T() {
            S("stop"), n.removeEventListener("popstate", C), n.removeEventListener("click", M)
        }

        function E(t) {
            n.history.pushState(null, null, t), C()
        }

        function C() {
            ! function(t) {
                let e = l(t, b, h);
                if (!e) {
                    if (y) return y(t);
                    e = x
                }
                s = !0, _ = w, w = Object.assign({
                    isFirstRoute: o
                }, e), a.emit("start", w), S("route:", w.id, (o ? "(first) " : " ") + JSON.stringify(w.params)), o ? (o = !1, i.showFirstPage().then(A)) : m({
                    route: w,
                    base: d,
                    path: t
                }).then(t => {
                    const e = i.showPage(t, g);
                    return a.emit("loaded", w), e
                }).then(A)
            }(p(n.location))
        }

        function A() {
            s = !1, a.emit("complete", w), a.emit("update", w)
        }
        return S('baseUrl = "' + h + '"'), S('baseContent = "' + d + '"'), b.forEach(t => {
            S("registering route:", t.path)
        }), {
            start: function() {
                S("start"), n.addEventListener("popstate", C), n.addEventListener("click", M), C()
            },
            stop: T,
            goTo: E,
            goToId: function(t, e) {
                let n = u(t, b);
                if (n) {
                    let t = n.path;
                    e && Object.keys(e).forEach(n => {
                        t = t.replace(":" + n, e[n])
                    }), E(t)
                }
            },
            dispose: function() {
                a.off("update"), T()
            },
            get routes() {
                return b.slice(0)
            },
            get nbListeners() {
                return a._allEvents.update ? a._allEvents.update.length : 0
            },
            get baseUrl() {
                return h
            },
            get baseContent() {
                return d
            },
            get currentRoute() {
                return Object.assign({}, w)
            },
            get previousRoute() {
                return Object.assign({}, _)
            },
            get isTransitionning() {
                return s
            },
            on: (...t) => a.on(...t),
            off: (...t) => a.off(...t)
        }
    }, e.getRouteById = u, e.getRouteByPath = l, e.matchRoute = a
}, function(t, e) {
    t.exports = [{
        id: "10",
        name: "10-CHAMBREDESPARENTS",
        portals: [{
            room: "14",
            p: [.965, .63],
            s: [17.87, 50],
            r: [0, 0, 0],
            c: [1.403, 2.252]
        }, {
            room: "16",
            p: [.908, .046],
            s: [26.79, 48.22],
            r: [0, 0, 0],
            c: [1.474, -.0566]
        }],
        hints: [{
            id: 0,
            p: [.495, .914],
            s: [42.96, 50.49],
            r: [-.028, .237, 0],
            ms: .369,
            mo: [0, -.377],
            mb: .2,
            img: "sil_01",
            flip: !0,
            a: .8
        }, {
            id: 1,
            p: [.936, .924],
            s: [25.45, 44.2],
            r: [.194, -.355, 0],
            ms: .5,
            mo: [0, 0],
            mb: .535,
            souvenir: !0,
            video: "collier.mp4",
            a: .8
        }]
    }, {
        id: "16",
        name: "16-SDB",
        fov: 80,
        portals: [{
            room: "10",
            p: [.957, .875],
            s: [39.29, 78.57],
            r: [0, -1.067, 0],
            c: [1.458, -1.872]
        }, {
            room: "02",
            p: [.559, .52],
            s: [69.65, 150],
            r: [.356, -.652, 0],
            c: [1.453, -1.055]
        }],
        hints: [{
            id: 2,
            p: [.019, .095],
            s: [59.54, 43.33],
            r: [-.124, .237, -.119],
            ms: .981,
            mo: [.264, -.151],
            mb: .2,
            img: "sil_03",
            a: .8
        }]
    }, {
        id: "02",
        name: "02-ATELIERDEMERE",
        portals: [{
            room: "16",
            p: [.976, .196],
            s: [23.22, 61.61],
            r: [0, .237, 0],
            c: [1.496, .2888]
        }, {
            room: "07",
            p: [.52, .38],
            s: [31.26, 81.25],
            r: [0, -.356, 0],
            c: [1.543, -.7206]
        }],
        hints: [{
            id: 3,
            p: [.478, .432],
            s: [27.01, 37.18],
            r: [0, -.045, 0],
            ms: .453,
            mo: [0, -.604],
            mb: .2,
            img: "sil_02",
            a: .8
        }]
    }, {
        id: "07",
        name: "07-CHAPELLE",
        portals: [{
            room: "02",
            p: [.514, .209],
            s: [42.86, 87.79],
            r: [0, -.296, 0],
            c: [1.4, .1266]
        }]
    }, {
        id: "14",
        name: "14-PALIER",
        portals: [{
            room: "10",
            p: [.541, .277],
            s: [29.47, 58.04],
            r: [0, -.474, 0],
            c: [1.524, -1.269]
        }, {
            room: "11",
            p: [.976, .393],
            s: [17.42, 32.15],
            r: [0, .237, 0],
            c: [1.314, -2.754]
        }, {
            room: "15",
            p: [.957, .83],
            s: [23.22, 48.22],
            r: [0, -.533, 0],
            c: [1.464, 3.011]
        }, {
            room: "22",
            alt: 0,
            p: [.544, .42],
            s: [29.47, 61.61],
            r: [.218, .905, 0],
            c: [1.452, -.5233]
        }, {
            room: "22",
            alt: 1,
            p: [.592, .941],
            s: [29.47, 58.04],
            r: [.218, -.905, 0],
            c: [1.349, 2.94]
        }, {
            room: "04",
            c: [1.78, 1.15, 1.324, 1.15],
            p: [.889, .534],
            s: [45.54, 38.85],
            r: [0, .237, -1.067],
            t: "swirl"
        }],
        hints: [{
            id: 5,
            p: [.509, .269],
            s: [10.56, 20.1],
            r: [-.001, -.034, 0],
            ms: .5,
            mo: [0, 0],
            mb: .443,
            video: "escalier.mp4",
            audio: "pas",
            souvenir: !0,
            additive: !0,
            a: .8
        }]
    }, {
        id: "11",
        name: "11-CHAMBREDELISE",
        portals: [{
            room: "14",
            p: [.524, .304],
            s: [29.47, 71.48],
            r: [0, -.474, 0],
            c: [1.49, -1.065]
        }, {
            room: "13",
            p: [.65, .992],
            s: [22.33, 48.22],
            r: [0, .296, 0],
            c: [1.51, 1.728]
        }],
        hints: [{
            id: 6,
            p: [.102, .06],
            s: [54.89, 83.61],
            r: [-.237, -.114, .01],
            ms: .377,
            mo: [.066, -.626],
            mb: .2,
            additive: !0,
            video: "cadre.mp4",
            audio: "cadre",
            souvenir: !0,
            a: .8
        }]
    }, {
        id: "13",
        name: "13_SDB",
        fov: 80,
        portals: [{
            room: "11",
            p: [.908, .937],
            s: [46.48, 115.18],
            r: [.129, -.119, 0],
            c: [1.487, -2.704]
        }, {
            room: "15",
            p: [.981, .447],
            s: [28.13, 60.27],
            r: [0, .059, 0],
            c: [1.601, -2.623]
        }],
        hints: [{
            id: 7,
            p: [.991, .764],
            s: [38.85, 46.88],
            r: [0, .415, 0],
            ms: .642,
            mo: [.453, -.151],
            mb: .2,
            img: "sil_03",
            flip: !0,
            a: .8
        }]
    }, {
        id: "15",
        name: "15-SALLEDEDESSINS",
        portals: [{
            room: "13",
            p: [.977, .658],
            s: [28.78, 71.48],
            r: [0, .742, 0],
            c: [1.455, .7173]
        }, {
            room: "14",
            p: [.539, .083],
            s: [26.79, 61.61],
            r: [0, -.059, 0],
            c: [1.437, -1.073]
        }],
        hints: [{
            id: 8,
            p: [.518, .999],
            s: [49.56, 30.81],
            r: [.059, .295, .018],
            ms: .369,
            mo: [0, -.377],
            mb: .387,
            img: "sil_01",
            a: .88
        }]
    }, {
        id: "22",
        name: "22",
        portals: [{
            room: "06",
            p: [.956, .753],
            s: [28.78, 56.26],
            r: [.122, .474, 0],
            c: [1.448, .6977]
        }, {
            room: "14",
            alt: 0,
            p: [.565, .145],
            s: [26.79, 61.61],
            r: [.237, -.652, 0],
            c: [1.446, -.2553]
        }, {
            room: "14",
            alt: 1,
            p: [.925, .106],
            s: [26.79, 61.61],
            r: [.237, .773, 0],
            c: [1.454, .3038]
        }],
        hints: [{
            id: 9,
            p: [.491, .485],
            s: [40.19, 63.15],
            r: [0, -.037, 0],
            ms: .483,
            mo: [0, -.631],
            mb: .2,
            img: "sil_02",
            additive: !0,
            a: .8
        }]
    }, {
        id: "06",
        name: "06-TOILETTES",
        fov: 80,
        portals: [{
            room: "22",
            p: [.61, .91],
            s: [72.33, 150],
            r: [.415, -.533, 0],
            c: [1.479, -1.292]
        }]
    }, {
        id: "04",
        name: "04-HALL",
        portals: [{
            room: "14",
            c: [.94, 1.87, 1.534, 1.87],
            p: [.975, .576],
            s: [48.22, 53.58],
            r: [0, 0, 0],
            t: "swirl"
        }, {
            room: "05",
            p: [.622, .981],
            s: [57.6, 99.11],
            r: [0, 0, 0],
            c: [1.326, 3.082]
        }, {
            room: "20",
            p: [.912, .02],
            s: [57.6, 87.06],
            r: [0, 0, 0],
            c: [1.365, -.2274]
        }]
    }, {
        id: "05",
        name: "05-ATELIERDUPERE",
        portals: [{
            room: "04",
            p: [.983, .426],
            s: [41.53, 56.26],
            r: [0, 0, 0],
            c: [1.527, 2.024]
        }, {
            room: "09",
            p: [.979, .851],
            s: [37.51, 62.95],
            r: [0, -.593, 0],
            c: [1.523, -2.507]
        }],
        hints: [{
            id: 11,
            p: [.415, .992],
            s: [140.63, 116.52],
            r: [-.067, .356, 0],
            ms: .226,
            mo: [-.264, -.453],
            mb: 0,
            img: "sil_03",
            additive: !0,
            a: .9
        }, {
            id: 12,
            p: [0, 0],
            s: [150, 150],
            r: [0, .356, .012],
            ms: .151,
            mo: [-.34, -.302],
            mb: .2,
            img: "sil_03",
            additive: !0,
            flip: !0,
            a: .8
        }, {
            id: 13,
            p: [.018, .571],
            s: [30.94, 41.64],
            r: [-.064, -.003, .012],
            ms: .528,
            mo: [0, 0],
            mb: .35,
            video: "repas.mp4",
            souvenir: !0,
            additive: !0,
            a: .89
        }]
    }, {
        id: "09",
        name: "09-BUREAUDELAMERE",
        portals: [{
            room: "05",
            p: [.959, .877],
            s: [29.47, 45.54],
            r: [0, 0, 0],
            c: [1.421, 1.682]
        }, {
            room: "08",
            p: [.786, .018],
            s: [32.15, 72.33],
            r: [0, -.771, -.034],
            c: [1.514, .02323]
        }],
        hints: [{
            id: 14,
            p: [.512, .212],
            s: [52.24, 40.19],
            r: [0, -.285, 0],
            ms: .604,
            mo: [-.151, -.226],
            mb: .387,
            additive: !0,
            video: "fleur.mp4",
            audio: "petale",
            souvenir: !0,
            a: 8
        }, {
            id: 15,
            p: [.829, .062],
            s: [17.42, 18.76],
            r: [-.019, -.395, -.166],
            ms: .679,
            mo: [.151, -.038],
            mb: .2,
            img: "sil_04",
            additive: !0,
            a: .8
        }]
    }, {
        id: "08",
        name: "08-SALLEDEMAQUILLAGE",
        portals: [{
            room: "12",
            p: [.967, .23],
            s: [29.47, 80.36],
            r: [0, .889, .066],
            c: [1.58, .1764]
        }, {
            room: "09",
            p: [.536, .223],
            s: [29.47, 80.36],
            r: [.061, .518, .057],
            c: [1.448, -2.122]
        }],
        hints: [{
            id: 16,
            p: [.472, .872],
            s: [37.51, 48.65],
            r: [-.133, 0, 0],
            ms: .51,
            mo: [.166, -.025],
            mb: .34,
            normal: !0,
            video: "repondeur.mp4",
            audio: "rembobine",
            souvenir: !0,
            a: .8
        }]
    }, {
        id: "12",
        name: "12-SDB",
        fov: 80,
        portals: [{
            room: "08",
            p: [.905, .061],
            s: [61.61, 150],
            r: [.142, .593, .025],
            c: [1.326, 1.62]
        }],
        hints: [{
            id: 17,
            p: [.385, .987],
            s: [133.1, 41.17],
            r: [-.178, .178, -.006],
            ms: 3,
            mo: [0, 0],
            mb: .34,
            normal: !0,
            normalIntensity: 2,
            wave: .1,
            video: "arbre.mp4",
            souvenir: !0,
            a: .8
        }]
    }, {
        id: "20",
        name: "20-SALLEAMANGER",
        portals: [{
            room: "04",
            p: [.981, .434],
            s: [28.13, 48.22],
            r: [.178, -.533, 0],
            c: [1.473, 2.434]
        }, {
            room: "17",
            p: [.833, .003],
            s: [26.79, 37.98],
            r: [.119, -.244, -.03],
            c: [1.498, -.2599]
        }]
    }, {
        id: "17",
        name: "17-CUISINE",
        alt: "17-CUISINE-ouvert",
        portals: [{
            room: "20",
            p: [.534, .88],
            s: [57.6, 95.09],
            r: [0, -.209, 0],
            c: [1.273, 3.086]
        }, {
            room: "21",
            p: [.929, .105],
            s: [28.13, 70.22],
            r: [0, 0, 0],
            c: [1.465, 1.6]
        }],
        hints: [{
            id: 18,
            p: [.032, .138],
            s: [68.31, 119.2],
            r: [-.178, .027, 0],
            ms: .675,
            mo: [0, 0],
            mb: .689,
            additive: !0,
            normalIntensity: 2,
            wave: .05,
            img: "fenetre",
            audio: "porte",
            souvenir: !0,
            last: !0,
            a: .6
        }]
    }, {
        id: "21",
        name: "21",
        alt: "21-ouvert",
        portals: [{
            room: "17",
            p: [.547, .118],
            s: [18.76, 46.88],
            r: [.119, .415, 0],
            c: [1.514, -2.54]
        }, {
            room: "18",
            p: [.679, .007],
            s: [41.53, 61.66],
            r: [0, 0, 0],
            c: [1.514, -2.54],
            exit: !0
        }]
    }, {
        id: "18",
        name: "18-EXTERIEUR",
        portals: [{
            room: "21",
            p: [.484, .529],
            s: [21.44, 36.17],
            r: [0, 0, 0]
        }]
    }]
}, function(t, e) {
    t.exports = [{
        id: "home",
        path: ""
    }]
}, function(t, e) {
    t.exports = ["fr", "de", "en"]
}, function(t, e) {
    var n;
    n = function() {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (t) {
        "object" == typeof window && (n = window)
    }
    t.exports = n
}, function(t, e, n) {
    "use strict";

    function i(t, e) {
        return r(t, e, !0)
    }

    function r(t, e, n) {
        var i, r = e.width || e.w,
            o = e.height || e.h,
            s = t.width || t.w,
            a = t.height || t.h,
            c = r / s,
            l = o / a;
        return {
            left: r - s * (i = n ? c > l ? c : l : c < l ? c : l) >> 1,
            top: o - a * i >> 1,
            width: s * i,
            height: a * i,
            scale: i
        }
    }
    t.exports = e = i, e.cover = i, e.contain = function(t, e) {
        return r(t, e, !1)
    }
}, function(t, e, n) {
    "use strict";

    function i(t, e) {
        void 0 === e && (e = {});
        for (var n = function(t) {
                for (var e = [], n = 0; n < t.length;) {
                    var i = t[n];
                    if ("*" !== i && "+" !== i && "?" !== i)
                        if ("\\" !== i)
                            if ("{" !== i)
                                if ("}" !== i)
                                    if (":" !== i)
                                        if ("(" !== i) e.push({
                                            type: "CHAR",
                                            index: n,
                                            value: t[n++]
                                        });
                                        else {
                                            var r = 1,
                                                o = "";
                                            if ("?" === t[a = n + 1]) throw new TypeError('Pattern cannot start with "?" at ' + a);
                                            for (; a < t.length;)
                                                if ("\\" !== t[a]) {
                                                    if (")" === t[a]) {
                                                        if (0 === --r) {
                                                            a++;
                                                            break
                                                        }
                                                    } else if ("(" === t[a] && (r++, "?" !== t[a + 1])) throw new TypeError("Capturing groups are not allowed at " + a);
                                                    o += t[a++]
                                                } else o += t[a++] + t[a++];
                                            if (r) throw new TypeError("Unbalanced pattern at " + n);
                                            if (!o) throw new TypeError("Missing pattern at " + n);
                                            e.push({
                                                type: "PATTERN",
                                                index: n,
                                                value: o
                                            }), n = a
                                        }
                    else {
                        for (var s = "", a = n + 1; a < t.length;) {
                            var c = t.charCodeAt(a);
                            if (!(c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || 95 === c)) break;
                            s += t[a++]
                        }
                        if (!s) throw new TypeError("Missing parameter name at " + n);
                        e.push({
                            type: "NAME",
                            index: n,
                            value: s
                        }), n = a
                    } else e.push({
                        type: "CLOSE",
                        index: n,
                        value: t[n++]
                    });
                    else e.push({
                        type: "OPEN",
                        index: n,
                        value: t[n++]
                    });
                    else e.push({
                        type: "ESCAPED_CHAR",
                        index: n++,
                        value: t[n++]
                    });
                    else e.push({
                        type: "MODIFIER",
                        index: n,
                        value: t[n++]
                    })
                }
                return e.push({
                    type: "END",
                    index: n,
                    value: ""
                }), e
            }(t), i = e.prefixes, r = void 0 === i ? "./" : i, o = "[^" + c(e.delimiter || "/#?") + "]+?", s = [], a = 0, l = 0, u = "", h = function(t) {
                if (l < n.length && n[l].type === t) return n[l++].value
            }, p = function(t) {
                var e = h(t);
                if (void 0 !== e) return e;
                var i = n[l],
                    r = i.type,
                    o = i.index;
                throw new TypeError("Unexpected " + r + " at " + o + ", expected " + t)
            }, f = function() {
                for (var t, e = ""; t = h("CHAR") || h("ESCAPED_CHAR");) e += t;
                return e
            }; l < n.length;) {
            var d = h("CHAR"),
                m = h("NAME"),
                g = h("PATTERN");
            if (m || g) {
                var v = d || ""; - 1 === r.indexOf(v) && (u += v, v = ""), u && (s.push(u), u = ""), s.push({
                    name: m || a++,
                    prefix: v,
                    suffix: "",
                    pattern: g || o,
                    modifier: h("MODIFIER") || ""
                })
            } else {
                var y = d || h("ESCAPED_CHAR");
                if (y) u += y;
                else if (u && (s.push(u), u = ""), h("OPEN")) {
                    v = f();
                    var b = h("NAME") || "",
                        x = h("PATTERN") || "",
                        w = f();
                    p("CLOSE"), s.push({
                        name: b || (x ? a++ : ""),
                        pattern: b && !x ? o : x,
                        prefix: v,
                        suffix: w,
                        modifier: h("MODIFIER") || ""
                    })
                } else p("END")
            }
        }
        return s
    }

    function r(t, e) {
        return o(i(t, e), e)
    }

    function o(t, e) {
        void 0 === e && (e = {});
        var n = l(e),
            i = e.encode,
            r = void 0 === i ? function(t) {
                return t
            } : i,
            o = e.validate,
            s = void 0 === o || o,
            a = t.map((function(t) {
                if ("object" == typeof t) return new RegExp("^(?:" + t.pattern + ")$", n)
            }));
        return function(e) {
            for (var n = "", i = 0; i < t.length; i++) {
                var o = t[i];
                if ("string" != typeof o) {
                    var c = e ? e[o.name] : void 0,
                        l = "?" === o.modifier || "*" === o.modifier,
                        u = "*" === o.modifier || "+" === o.modifier;
                    if (Array.isArray(c)) {
                        if (!u) throw new TypeError('Expected "' + o.name + '" to not repeat, but got an array');
                        if (0 === c.length) {
                            if (l) continue;
                            throw new TypeError('Expected "' + o.name + '" to not be empty')
                        }
                        for (var h = 0; h < c.length; h++) {
                            var p = r(c[h], o);
                            if (s && !a[i].test(p)) throw new TypeError('Expected all "' + o.name + '" to match "' + o.pattern + '", but got "' + p + '"');
                            n += o.prefix + p + o.suffix
                        }
                    } else if ("string" != typeof c && "number" != typeof c) {
                        if (!l) {
                            var f = u ? "an array" : "a string";
                            throw new TypeError('Expected "' + o.name + '" to be ' + f)
                        }
                    } else {
                        p = r(String(c), o);
                        if (s && !a[i].test(p)) throw new TypeError('Expected "' + o.name + '" to match "' + o.pattern + '", but got "' + p + '"');
                        n += o.prefix + p + o.suffix
                    }
                } else n += o
            }
            return n
        }
    }

    function s(t, e) {
        var n = [];
        return a(h(t, n, e), n, e)
    }

    function a(t, e, n) {
        void 0 === n && (n = {});
        var i = n.decode,
            r = void 0 === i ? function(t) {
                return t
            } : i;
        return function(n) {
            var i = t.exec(n);
            if (!i) return !1;
            for (var o = i[0], s = i.index, a = Object.create(null), c = function(t) {
                    if (void 0 === i[t]) return "continue";
                    var n = e[t - 1];
                    "*" === n.modifier || "+" === n.modifier ? a[n.name] = i[t].split(n.prefix + n.suffix).map((function(t) {
                        return r(t, n)
                    })) : a[n.name] = r(i[t], n)
                }, l = 1; l < i.length; l++) c(l);
            return {
                path: o,
                index: s,
                params: a
            }
        }
    }

    function c(t) {
        return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
    }

    function l(t) {
        return t && t.sensitive ? "" : "i"
    }

    function u(t, e, n) {
        void 0 === n && (n = {});
        for (var i = n.strict, r = void 0 !== i && i, o = n.start, s = void 0 === o || o, a = n.end, u = void 0 === a || a, h = n.encode, p = void 0 === h ? function(t) {
                return t
            } : h, f = "[" + c(n.endsWith || "") + "]|$", d = "[" + c(n.delimiter || "/#?") + "]", m = s ? "^" : "", g = 0, v = t; g < v.length; g++) {
            var y = v[g];
            if ("string" == typeof y) m += c(p(y));
            else {
                var b = c(p(y.prefix)),
                    x = c(p(y.suffix));
                if (y.pattern)
                    if (e && e.push(y), b || x)
                        if ("+" === y.modifier || "*" === y.modifier) {
                            var w = "*" === y.modifier ? "?" : "";
                            m += "(?:" + b + "((?:" + y.pattern + ")(?:" + x + b + "(?:" + y.pattern + "))*)" + x + ")" + w
                        } else m += "(?:" + b + "(" + y.pattern + ")" + x + ")" + y.modifier;
                else m += "(" + y.pattern + ")" + y.modifier;
                else m += "(?:" + b + x + ")" + y.modifier
            }
        }
        if (u) r || (m += d + "?"), m += n.endsWith ? "(?=" + f + ")" : "$";
        else {
            var _ = t[t.length - 1],
                M = "string" == typeof _ ? d.indexOf(_[_.length - 1]) > -1 : void 0 === _;
            r || (m += "(?:" + d + "(?=" + f + "))?"), M || (m += "(?=" + d + "|" + f + ")")
        }
        return new RegExp(m, l(n))
    }

    function h(t, e, n) {
        return t instanceof RegExp ? function(t, e) {
            if (!e) return t;
            var n = t.source.match(/\((?!\?)/g);
            if (n)
                for (var i = 0; i < n.length; i++) e.push({
                    name: i,
                    prefix: "",
                    suffix: "",
                    modifier: "",
                    pattern: ""
                });
            return t
        }(t, e) : Array.isArray(t) ? function(t, e, n) {
            var i = t.map((function(t) {
                return h(t, e, n).source
            }));
            return new RegExp("(?:" + i.join("|") + ")", l(n))
        }(t, e, n) : function(t, e, n) {
            return u(i(t, n), e, n)
        }(t, e, n)
    }
    n.r(e), n.d(e, "parse", (function() {
        return i
    })), n.d(e, "compile", (function() {
        return r
    })), n.d(e, "tokensToFunction", (function() {
        return o
    })), n.d(e, "match", (function() {
        return s
    })), n.d(e, "regexpToFunction", (function() {
        return a
    })), n.d(e, "tokensToRegexp", (function() {
        return u
    })), n.d(e, "pathToRegexp", (function() {
        return h
    }))
}, function(t, e, n) {}, function(t, e, n) {
    "use strict";
    n.r(e);
    var i = {};
    n.r(i), n.d(i, "Phrase", (function() {
        return A
    })), n.d(i, "LanguageButton", (function() {
        return W
    })), n.d(i, "SocialButton", (function() {
        return Q
    })), n.d(i, "ShareButton", (function() {
        return pt
    })), n.d(i, "Sharer", (function() {
        return _t
    })), n.d(i, "FullscreenButton", (function() {
        return Dt
    })), n.d(i, "SoundButton", (function() {
        return ie
    })), n.d(i, "Circle", (function() {
        return be
    })), n.d(i, "ArrowButton", (function() {
        return Ce
    })), n.d(i, "CookieBanner", (function() {
        return ze
    })), n.d(i, "Tuto", (function() {
        return Ze
    })), n.d(i, "Intro", (function() {
        return Nf
    })), n.d(i, "Fallback", (function() {
        return Gf
    })), n.d(i, "EndVideo", (function() {
        return Qf
    })), n.d(i, "Inventaire", (function() {
        return Md
    })), n.d(i, "HintsButton", (function() {
        return Dd
    })), n.d(i, "Languages", (function() {
        return Hd
    })), n.d(i, "Footer", (function() {
        return $d
    })), n.d(i, "Logo", (function() {
        return om
    })), n.d(i, "View", (function() {
        return h.View
    })), n.d(i, "Header", (function() {
        return hm
    })), n.d(i, "Cursor", (function() {
        return bm
    })), n.d(i, "Home", (function() {
        return Yy
    })), n.d(i, "About", (function() {
        return ib
    }));
    var r, o = n(0),
        s = n.n(o),
        a = n(1),
        c = Object(a.default)();

    function l(t) {
        return r ? r.findInstance(t) : null
    }
    var u, h = n(4),
        p = n(6),
        f = n.n(p),
        d = n(7),
        m = n.n(d),
        g = m.a.length > 1,
        v = "".concat("/SilentFamilyShadow/").replace(/\/$/, ""),
        y = null,
        b = Object(a.default)();

    function x(t) {
        b.emit("route:start", t)
    }

    function w(t) {
        y.off("update", w), t.path = v + t.path, Object(h.matchRoute)(window.location.pathname, t.path) || window.history.pushState(null, null, g ? t.path.replace(/:lang/, m.a[0]) : t.path)
    }

    function _(t) {
        u,
        u = t,
        b.emit("route:complete", t)
    }

    function M(t) {
        return (M = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function S(t, e) {
        return (S = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function T(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = C(t);
            if (e) {
                var r = C(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return E(this, n)
        }
    }

    function E(t, e) {
        return !e || "object" !== M(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function C(t) {
        return (C = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var A = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && S(t, e)
            }(n, t);
            var e = T(n);

            function n(t) {
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, n), e.call(this, t)
            }
            return n
        }(s.a),
        L = Object(a.default)(),
        P = !1;

    function O(t) {
        L.on("ui:over", t)
    }

    function R() {
        P = !0, L.emit("ui:over")
    }

    function I() {
        P = !1, L.emit("ui:out")
    }

    function D(t) {
        L.emit("hint:progress", t)
    }

    function N() {
        L.emit("cross:enable")
    }

    function k() {
        L.emit("cross:disable")
    }

    function U() {
        L.emit("door:out")
    }

    function B(t) {
        return (B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function z(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function F(t, e) {
        return (F = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function j(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = V(t);
            if (e) {
                var r = V(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return H(this, n)
        }
    }

    function H(t, e) {
        return !e || "object" !== B(e) && "function" != typeof e ? G(t) : e
    }

    function G(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function V(t) {
        return (V = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var W = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && F(t, e)
        }(o, t);
        var e, n, i, r = j(o);

        function o(t) {
            var e;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(G(e)), e.onMouseOut = e.onMouseOut.bind(G(e)), e.$el.addEventListener("mouseover", e.onMouseOver), e.$el.addEventListener("mouseout", e.onMouseOut), e
        }
        return e = o, (n = [{
            key: "onMouseOver",
            value: function() {
                this.refs.circle.onMouseOver(), R()
            }
        }, {
            key: "onMouseOut",
            value: function() {
                this.refs.circle.onMouseOut(), I()
            }
        }]) && z(e.prototype, n), i && z(e, i), o
    }(s.a);

    function q(t) {
        return (q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function X(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Z(t, e) {
        return (Z = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Y(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = K(t);
            if (e) {
                var r = K(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return $(this, n)
        }
    }

    function $(t, e) {
        return !e || "object" !== q(e) && "function" != typeof e ? J(t) : e
    }

    function J(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function K(t) {
        return (K = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Q = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Z(t, e)
            }(o, t);
            var e, n, i, r = Y(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(J(e)), e.onMouseOut = e.onMouseOut.bind(J(e)), e.$el.addEventListener("mouseover", e.onMouseOver), e.$el.addEventListener("mouseout", e.onMouseOut), e
            }
            return e = o, (n = [{
                key: "onMouseOver",
                value: function() {
                    this.refs.circle.onMouseOver(), R()
                }
            }, {
                key: "onMouseOut",
                value: function() {
                    this.refs.circle.onMouseOut(), I()
                }
            }]) && X(e.prototype, n), i && X(e, i), o
        }(s.a),
        tt = n(2),
        et = n.n(tt),
        nt = n(3),
        it = n.n(nt),
        rt = new et.a({
            id: "share",
            use: "share-usage",
            viewBox: "0 0 30 30",
            content: '<symbol viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg" id="share">\n  <path d="M22.35 9.91C24.72 9.91 26.67 7.96 26.67 5.59C26.67 3.22 24.72 1.27 22.35 1.27C19.98 1.27 18.03 3.22 18.03 5.59C18.03 6.39 18.25 7.13 18.61 7.77L11.82 12.74C11.05 11.62 9.74 10.85 8.26 10.85C5.89 10.85 3.94 12.8 3.94 15.17C3.94 17.54 5.89 19.49 8.26 19.49C9.73 19.49 11.05 18.75 11.82 17.6L18.61 22.6C18.23 23.24 18.03 23.98 18.03 24.78C18.03 27.15 19.98 29.1 22.35 29.1C24.72 29.1 26.67 27.15 26.67 24.78C26.67 22.41 24.72 20.46 22.35 20.46C20.88 20.46 19.56 21.2 18.79 22.35L11.97 17.35C12.35 16.71 12.55 15.97 12.55 15.17C12.55 14.37 12.33 13.63 11.97 12.99L18.76 7.99C19.56 9.15 20.84 9.91 22.35 9.91ZM22.35 22.73C23.5 22.73 24.43 23.66 24.43 24.81C24.43 25.96 23.5 26.89 22.35 26.89C21.2 26.89 20.27 25.96 20.27 24.81C20.26 23.66 21.19 22.73 22.35 22.73ZM8.25 17.28C7.1 17.28 6.17 16.35 6.17 15.2C6.17 14.05 7.1 13.12 8.25 13.12C9.4 13.12 10.33 14.05 10.33 15.2C10.33 16.35 9.37 17.28 8.25 17.28ZM22.35 3.51C23.5 3.51 24.43 4.44 24.43 5.59C24.43 6.74 23.5 7.67 22.35 7.67C21.2 7.67 20.27 6.74 20.27 5.59C20.27 4.44 21.19 3.51 22.35 3.51Z" />\n</symbol>'
        });
    it.a.add(rt);

    function ot(t) {
        return (ot = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function st(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function at(t, e) {
        return (at = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function ct(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = ht(t);
            if (e) {
                var r = ht(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return lt(this, n)
        }
    }

    function lt(t, e) {
        return !e || "object" !== ot(e) && "function" != typeof e ? ut(t) : e
    }

    function ut(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function ht(t) {
        return (ht = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var pt = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && at(t, e)
            }(o, t);
            var e, n, i, r = ct(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(ut(e)), e.onMouseOut = e.onMouseOut.bind(ut(e)), e.$el.addEventListener("mouseover", e.onMouseOver), e.$el.addEventListener("mouseout", e.onMouseOut), e
            }
            return e = o, (n = [{
                key: "onMouseOver",
                value: function() {
                    this.refs.circle.onMouseOver(), R()
                }
            }, {
                key: "onMouseOut",
                value: function() {
                    this.refs.circle.onMouseOut(), I()
                }
            }]) && st(e.prototype, n), i && st(e, i), o
        }(s.a),
        ft = new et.a({
            id: "facebook",
            use: "facebook-usage",
            viewBox: "0 0 110 110",
            content: '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 110 110" id="facebook">\n  <path d="M66.5 24h15.4V5H66.5C53.7 5 43.4 16.2 43.4 30v9.6H28v19.1h15.4V105h19.2V58.7h19.2V39.6H62.6v-9.8c0-3.3 2.1-5.8 3.9-5.8z" />\n</symbol>'
        }),
        dt = (it.a.add(ft), new et.a({
            id: "twitter",
            use: "twitter-usage",
            viewBox: "0 0 110 110",
            content: '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 110 110" id="twitter">\n  <path d="M104.8 23.9c-3.7 1.6-7.6 2.7-11.8 3.2 4.2-2.5 7.5-6.6 9-11.3-4 2.3-8.3 4-13 4.9-3.7-4-9-6.5-15-6.5-11.3 0-20.5 9.2-20.5 20.5 0 1.6.2 3.2.5 4.7-17-.8-32.1-9-42.2-21.3C10 21.1 9 24.6 9 28.4c0 7.1 3.6 13.4 9.1 17.1-3.4-.1-6.5-1-9.3-2.6v.3c0 9.9 7 18.2 16.4 20.1-1.7.5-3.5.7-5.4.7-1.3 0-2.6-.1-3.8-.4 2.6 8.1 10.2 14.1 19.2 14.2-7 5.5-15.9 8.8-25.4 8.8-1.6 0-3.2-.1-4.9-.3 9.1 5.8 19.9 9.2 31.5 9.2 37.7 0 58.3-31.2 58.3-58.2 0-.9 0-1.7-.1-2.6 4-2.9 7.5-6.5 10.2-10.6.2-.1 0-.2 0-.2z" />\n</symbol>'
        }));
    it.a.add(dt);

    function mt(t) {
        return (mt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function gt(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function vt(t, e) {
        return (vt = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function yt(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = wt(t);
            if (e) {
                var r = wt(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return bt(this, n)
        }
    }

    function bt(t, e) {
        return !e || "object" !== mt(e) && "function" != typeof e ? xt(t) : e
    }

    function xt(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function wt(t) {
        return (wt = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var _t = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && vt(t, e)
            }(o, t);
            var e, n, i, r = yt(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(xt(e)), e.onMouseLeave = e.onMouseLeave.bind(xt(e)), e.$socials = e.$one(".Sharer-socials"), e.$socialButtons = e.$all(".SocialButton"), e.isHidden = !0, e
            }
            return e = o, (n = [{
                key: "ready",
                value: function() {
                    this.button = this.refs.shareButton, this.button.$el.addEventListener("mouseover", this.onMouseOver)
                }
            }, {
                key: "onMouseOver",
                value: function() {
                    this.show(), this.button.$el.removeEventListener("mouseover", this.onMouseOver), this.$el.addEventListener("mouseleave", this.onMouseLeave)
                }
            }, {
                key: "onMouseLeave",
                value: function() {
                    this.$el.removeEventListener("mouseleave", this.onMouseLeave), this.button.$el.addEventListener("mouseover", this.onMouseOver), this.hide()
                }
            }, {
                key: "show",
                value: function() {
                    this.isHidden = !1, this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.set(this.$socials, {
                        display: "block"
                    }), this.tl.fromTo(this.$socials, {
                        alpha: 0
                    }, {
                        alpha: 1,
                        duration: .4
                    }, 0), this.tl.fromTo(this.$socialButtons, {
                        y: -30
                    }, {
                        y: 0,
                        duration: .4,
                        stagger: -.1,
                        ease: "expo.out"
                    }, 0)
                }
            }, {
                key: "hide",
                value: function() {
                    this.isHidden = !0, this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.to(this.$socials, {
                        duration: .4,
                        alpha: 0
                    }), this.tl.set(this.$socials, {
                        display: "none"
                    })
                }
            }]) && gt(e.prototype, n), i && gt(e, i), o
        }(s.a),
        Mt = new et.a({
            id: "fullscreen",
            use: "fullscreen-usage",
            viewBox: "0 0 30 30",
            content: '<symbol viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg" id="fullscreen">\n  <path d="M24.78 6.92001V12.67H26.05V4.76001H18.14V6.03001H23.89L5.80999 24.1V18.36H4.54999V26.26H12.45V25H6.70999L24.78 6.92001Z" />\n</symbol>'
        }),
        St = (it.a.add(Mt), new et.a({
            id: "exitfullscreen",
            use: "exitfullscreen-usage",
            viewBox: "0 0 30 30",
            content: '<symbol viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg" id="exitfullscreen">\n  <path d="M25.47 4.12L17.2 12.39V6.64H15.94V14.55H23.84V13.28H18.1L26.37 5.01" />\n  <path d="M5.11998 26.25L13.39 17.98V23.73H14.66V15.82H6.74998V17.09H12.5L4.22998 25.36" />\n</symbol>'
        })),
        Tt = (it.a.add(St), Object(a.default)()),
        Et = !1;

    function Ct(t) {
        return (Ct = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function At(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Lt(t, e) {
        return (Lt = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Pt(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = It(t);
            if (e) {
                var r = It(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Ot(this, n)
        }
    }

    function Ot(t, e) {
        return !e || "object" !== Ct(e) && "function" != typeof e ? Rt(t) : e
    }

    function Rt(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function It(t) {
        return (It = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    document.addEventListener("fullscreenchange", (function() {
        document.fullscreenElement ? Tt.emit("enterFullscreen") : Tt.emit("exitFullscreen")
    }));
    var Dt = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Lt(t, e)
            }(o, t);
            var e, n, i, r = Pt(o);

            function o(t) {
                var e, n;
                return function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(Rt(e)), e.onMouseOut = e.onMouseOut.bind(Rt(e)), e.onClick = e.onClick.bind(Rt(e)), e.onEnterFullscreen = e.onEnterFullscreen.bind(Rt(e)), e.onExitFullscreen = e.onExitFullscreen.bind(Rt(e)), e.$enter = e.$one(".FullscreenButton-enter"), e.$exit = e.$one(".FullscreenButton-exit"), e.$el.addEventListener("mouseover", e.onMouseOver), e.$el.addEventListener("mouseout", e.onMouseOut), e.$el.addEventListener("click", e.onClick), n = e.onEnterFullscreen, Tt.on("enterFullscreen", n),
                    function(t) {
                        Tt.on("exitFullscreen", t)
                    }(e.onExitFullscreen), e
            }
            return e = o, (n = [{
                key: "onEnterFullscreen",
                value: function() {
                    this.$enter.style.display = "none", this.$exit.style.display = "block"
                }
            }, {
                key: "onExitFullscreen",
                value: function() {
                    this.$enter.style.display = "block", this.$exit.style.display = "none"
                }
            }, {
                key: "onMouseOver",
                value: function() {
                    this.refs.circle.onMouseOver(), R()
                }
            }, {
                key: "onMouseOut",
                value: function() {
                    this.refs.circle.onMouseOut(), I()
                }
            }, {
                key: "onClick",
                value: function() {
                    Et ? (Et = !1, document.fullscreenElement && document.exitFullscreen && document.exitFullscreen()) : (Et = !0, document.fullscreenElement || document.documentElement.requestFullscreen())
                }
            }]) && At(e.prototype, n), i && At(e, i), o
        }(s.a),
        Nt = !1,
        kt = !1,
        Ut = !1;

    function Bt() {
        Ut ? kt || Nt || (Ut = !1, Howler.mute(!1)) : (kt || Nt) && (Ut = !0, Howler.mute(!0))
    }
    window.addEventListener("focus", (function() {
        kt = !1, Bt()
    })), window.addEventListener("blur", (function() {
        kt = !0, Bt()
    }));
    var zt = Object(a.default)();
    var Ft, jt = {
            nappe0: {
                url: "piste_1.mp3"
            },
            nappe1: {
                url: "piste_2.mp3"
            },
            nappe2: {
                url: "piste_3.mp3"
            },
            nappefin: {
                url: "piste_fin.mp3"
            },
            pas: {
                url: "flashback_mere_escalier.mp3"
            },
            cadre: {
                url: "video_cadre_photo.mp3"
            },
            petale: {
                url: "video_petales.mp3"
            },
            rembobine: {
                url: "video_repondeur.mp3"
            },
            porte: {
                url: "porte.mp3"
            }
        },
        Ht = ["nappe0", "nappe1", "nappe2"],
        Gt = -1;

    function Vt(t) {
        var e;
        switch (t) {
            case 9:
            case 8:
            case 7:
                e = 2;
                break;
            case 6:
            case 5:
            case 4:
                e = 1;
                break;
            case 3:
            case 2:
            case 1:
            case 0:
            default:
                e = 0
        }
        e !== Gt && (Gt = e, Ft && Yt(Ft), Ft = Xt(Ht[Gt]))
    }

    function Wt(t) {
        if (jt[t]) return jt[t].sound || (jt[t].sound = new Howl({
            src: ["/SilentFamilyShadow/assets/audio/" + jt[t].url]
        })), jt[t].sound
    }

    function qt(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            n = Wt(t);
        return n.loop(e), n.play(), n
    }

    function Xt(t) {
        var e = qt(t, !0);
        return e.fade(0, 1, 1e3), e
    }

    function Zt() {
        Ft && Yt(Ft), Ft = Xt("nappefin")
    }

    function Yt(t) {
        t.fade(t.volume(), 0, 2e3), t.once("fade", (function() {
            t.stop()
        }))
    }

    function $t(t) {
        return ($t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Jt(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Kt(t, e) {
        return (Kt = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Qt(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = ne(t);
            if (e) {
                var r = ne(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return te(this, n)
        }
    }

    function te(t, e) {
        return !e || "object" !== $t(e) && "function" != typeof e ? ee(t) : e
    }

    function ee(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function ne(t) {
        return (ne = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var ie = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Kt(t, e)
        }(o, t);
        var e, n, i, r = Qt(o);

        function o(t) {
            var e, n, i;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(ee(e)), e.onMouseOut = e.onMouseOut.bind(ee(e)), e.onClick = e.onClick.bind(ee(e)), e.onMute = e.onMute.bind(ee(e)), e.onUnMute = e.onUnMute.bind(ee(e)), e.$rects = e.$all(".SoundButton-rect"), e.tls = [], e.$rects.forEach((function(t, n) {
                var i = 1 === n || 2 === n ? .8 : .4;
                t.style.transform = "scaleY(" + (i * Math.random() + .2) + ")";
                var r = gsap.timeline({
                    repeat: -1,
                    yoyo: !0,
                    ease: "none"
                });
                r.to(t, {
                    duration: .2,
                    scaleY: i * Math.random() + .2
                }), r.to(t, {
                    duration: .2,
                    scaleY: i * Math.random() + .2
                }), r.to(t, {
                    duration: .2,
                    scaleY: i * Math.random() + .2
                }), r.to(t, {
                    duration: .2,
                    scaleY: i * Math.random() + .2
                }), r.to(t, {
                    duration: .2,
                    scaleY: i * Math.random() + .2
                }), r.to(t, {
                    duration: .2,
                    scaleY: i * Math.random() + .2
                }), e.tls.push(r)
            })), e.$el.addEventListener("mouseover", e.onMouseOver), e.$el.addEventListener("mouseout", e.onMouseOut), e.$el.addEventListener("click", e.onClick), n = e.onMute, zt.on("mute", n), i = e.onUnMute, zt.on("unmute", i), e
        }
        return e = o, (n = [{
            key: "onMute",
            value: function() {
                this.tls.forEach((function(t) {
                    return t.pause()
                })), this.$rects.forEach((function(t) {
                    t.style.transform = "scaleY(0.1)"
                }))
            }
        }, {
            key: "onUnMute",
            value: function() {
                this.tls.forEach((function(t) {
                    return t.play()
                }))
            }
        }, {
            key: "onMouseOver",
            value: function() {
                this.refs.circle.onMouseOver(), R()
            }
        }, {
            key: "onMouseOut",
            value: function() {
                this.refs.circle.onMouseOut(), I()
            }
        }, {
            key: "onClick",
            value: function() {
                Nt ? (Nt = !1, Bt(), zt.emit("unmute")) : (Nt = !0, Bt(), zt.emit("mute"))
            }
        }]) && Jt(e.prototype, n), i && Jt(e, i), o
    }(s.a);

    function re(t) {
        if (t) {
            var e = t.innerHTML;
            t.innerHTML = "";
            var n = document.createElement("div");
            n.classList.add("".concat("channel-split", "-static")), n.innerHTML = e, t.appendChild(n), ["red", "green", "blue"].forEach((function(n) {
                var i = document.createElement("div");
                i.classList.add("channel-split"), i.classList.add("".concat("channel-split", "-").concat(n)), i.innerHTML = e, t.appendChild(i)
            }))
        }
    }

    function oe(t, e, n) {
        var i = gsap.timeline();
        return i.to([t, e], {
            duration: 1,
            x: 0,
            y: 0,
            force3D: !0,
            ease: "expo.out"
        }, 0), i
    }

    function se(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2,
            i = gsap.timeline({
                repeat: -1
            }),
            r = n,
            o = n / 2,
            s = 0;
        return i.to(t, {
            duration: .1,
            x: r,
            y: o
        }, 0), i.to(t, {
            duration: .1,
            x: o,
            y: r
        }, .1), i.to(t, {
            duration: .1,
            x: r,
            y: s
        }, .2), i.to(t, {
            duration: .1,
            x: s,
            y: o
        }, .3), i.to(e, {
            duration: .1,
            x: -r,
            y: -o
        }, 0), i.to(e, {
            duration: .1,
            x: s,
            y: -o
        }, .1), i.to(e, {
            duration: .1,
            x: -o,
            y: -r
        }, .2), i.to(e, {
            duration: .1,
            x: -r,
            y: s
        }, .3), i
    }

    function ae(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function ce(t) {
        return t * Math.PI / 180
    }

    function le(t, e, n, i) {
        var r = ce(i - 90);
        return {
            x: t + n * Math.cos(r),
            y: e + n * Math.sin(r)
        }
    }

    function ue(t, e, n, i, r) {
        var o = n,
            s = le(t, e, o, r),
            a = le(t, e, o, i),
            c = r - i <= 180 ? "0" : "1";
        return ["M", s.x, s.y, "A", o, o, 0, c, 0, a.x, a.y].join(" ")
    }
    var he = function() {
        function t(e, n, i, r) {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.update = this.update.bind(this), this.path1 = e, this.path2 = n, this.d = r, this.x = .5 * i, this.y = .5 * i, this.r = .5 * this.d - 1, this.delta = 20, this.halfDelta = .5 * this.delta, this.a1 = -20, this.a2 = 110, this.offset = 0
        }
        var e, n, i;
        return e = t, (n = [{
            key: "update",
            value: function() {
                var t = ue(this.x, this.y, this.r, this.a1 + this.halfDelta + this.offset, this.a2 - this.halfDelta + this.offset),
                    e = ue(this.x, this.y, this.r, this.a2 + this.halfDelta + this.offset, this.a1 + 360 - this.halfDelta + this.offset);
                return this.path1.setAttribute("d", t), this.path2.setAttribute("d", e), {
                    d1: t,
                    d2: e
                }
            }
        }]) && ae(e.prototype, n), i && ae(e, i), t
    }();

    function pe(t) {
        return (pe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function fe(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function de(t, e) {
        return (de = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function me(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = ye(t);
            if (e) {
                var r = ye(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return ge(this, n)
        }
    }

    function ge(t, e) {
        return !e || "object" !== pe(e) && "function" != typeof e ? ve(t) : e
    }

    function ve(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function ye(t) {
        return (ye = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var be = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && de(t, e)
            }(o, t);
            var e, n, i, r = me(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).update = e.update.bind(ve(e)), e.onMouseOver = e.onMouseOver.bind(ve(e)), e.onMouseOut = e.onMouseOut.bind(ve(e)), re(t), e.$svg = e.$one("svg"), e.$red = e.$one(".channel-split-red"), e.$green = e.$one(".channel-split-green"), e.$blue = e.$one(".channel-split-blue"), e.$arcRed1 = e.$one(".channel-split-red .Arc--1"), e.$arcRed2 = e.$one(".channel-split-red .Arc--2"), e.$arcGreen1 = e.$one(".channel-split-green .Arc--1"), e.$arcGreen2 = e.$one(".channel-split-green .Arc--2"), e.$arcBlue1 = e.$one(".channel-split-blue .Arc--1"), e.$arcBlue2 = e.$one(".channel-split-blue .Arc--2"), e.arc = new he(e.$arcRed1, e.$arcRed2, parseInt(e.$svg.getAttribute("width")), 35), e.update(), e
            }
            return e = o, (n = [{
                key: "onMouseOver",
                value: function() {
                    this.tl && this.tl.kill(), this.tl = gsap.timeline({
                        onUpdate: this.update
                    }), this.tl.to(this.arc, {
                        duration: 1,
                        a1: -60,
                        a2: 150,
                        ease: "expo.out"
                    }, 0), this.wiggleTl = se(this.$red, this.$blue, 1)
                }
            }, {
                key: "onMouseOut",
                value: function() {
                    this.wiggleTl && this.wiggleTl.kill(), this.tl && this.tl.kill(), this.tl = gsap.timeline({
                        onUpdate: this.update
                    }), this.tl.to(this.arc, {
                        duration: 1,
                        a1: -20,
                        a2: 110,
                        ease: "expo.out"
                    }, 0), this.tl.add(oe(this.$red, this.$blue), 0)
                }
            }, {
                key: "update",
                value: function() {
                    var t = this.arc.update(),
                        e = t.d1,
                        n = t.d2;
                    this.$arcGreen1.setAttribute("d", e), this.$arcBlue1.setAttribute("d", e), this.$arcGreen2.setAttribute("d", n), this.$arcBlue2.setAttribute("d", n)
                }
            }]) && fe(e.prototype, n), i && fe(e, i), o
        }(s.a),
        xe = new et.a({
            id: "play",
            use: "play-usage",
            viewBox: "0 0 8 22",
            content: '<symbol viewBox="0 0 8 22" xmlns="http://www.w3.org/2000/svg" id="play">\n<path d="M0 0V22L8 11L0 0Z" />\n</symbol>'
        });
    it.a.add(xe);

    function we(t) {
        return (we = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function _e(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Me(t, e) {
        return (Me = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Se(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Ee(t);
            if (e) {
                var r = Ee(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Te(this, n)
        }
    }

    function Te(t, e) {
        return !e || "object" !== we(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function Ee(t) {
        return (Ee = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Ce = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Me(t, e)
            }(n, t);
            var e = Se(n);

            function n() {
                return _e(this, n), e.apply(this, arguments)
            }
            return n
        }(s.a),
        Ae = window.gtag || function() {},
        Le = !1;

    function Pe() {
        if (Le = !0, Ae("js", new Date), Ae("config", "UA-172931261-1"), window.ATInternet) try {
            new ATInternet.Tracker.Tag({
                log: "logc136",
                logSSL: "logs1136",
                secure: !0,
                domain: "xiti.com"
            }).page.send({
                level2: "1",
                chapter1: "Webprod",
                chapter2: "DarkShadow",
                name: "experience",
                customVars: {
                    site: {
                        1: "{{ lang }}",
                        2: encodeURIComponent(location.href)
                    }
                },
                customObject: {
                    device: function() {
                        var t = 600,
                            e = 1e3,
                            n = "error";
                        if (void 0 !== window.innerWidth) {
                            var i = window.innerWidth;
                            n = i < t ? "smartphone" : i < e ? "tablet" : i >= e ? "desktop" : "error"
                        }
                        return n
                    }()
                }
            })
        } catch (t) {
            console.error(t), console.log("Problem with stats reporting. Probably related to an adblocker.")
        }
    }

    function Oe(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : void 0;
        Le && (console.log("[TRACK] category:", t, " | action:", e, " | label:", n, " | value:", i), Ae("event", e, {
            event_category: t,
            event_label: n,
            value: i
        }))
    }

    function Re(t) {
        return (Re = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Ie(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function De(t, e) {
        return (De = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Ne(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Be(t);
            if (e) {
                var r = Be(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return ke(this, n)
        }
    }

    function ke(t, e) {
        return !e || "object" !== Re(e) && "function" != typeof e ? Ue(t) : e
    }

    function Ue(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Be(t) {
        return (Be = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    Pe();
    var ze = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && De(t, e)
            }(o, t);
            var e, n, i, r = Ne(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onAllow = e.onAllow.bind(Ue(e)), e.onDecline = e.onDecline.bind(Ue(e)), e.$allowButton = e.$one(".CookieBanner-button--allow"), e.$declineButton = e.$one(".CookieBanner-button--decline"), e.$allowButton.addEventListener("click", e.onAllow), e.$declineButton.addEventListener("click", e.onDecline), e
            }
            return e = o, (n = [{
                key: "onAllow",
                value: function() {
                    Pe(), this.transitionOut()
                }
            }, {
                key: "onDecline",
                value: function() {
                    this.transitionOut()
                }
            }, {
                key: "transitionOut",
                value: function() {
                    this.$allowButton.removeEventListener("click", this.onAllow), this.$allowButton.removeEventListener("click", this.onDecline), gsap.timeline().to(this.$el, {
                        yPercent: -100,
                        duration: 1,
                        alpha: 0,
                        display: "none"
                    })
                }
            }]) && Ie(e.prototype, n), i && Ie(e, i), o
        }(s.a),
        Fe = new et.a({
            id: "360",
            use: "360-usage",
            viewBox: "0 0 71 47",
            content: '<symbol viewBox="0 0 71 47" xmlns="http://www.w3.org/2000/svg" id="360">\n<path d="M57.3314 24.01C57.3314 24.01 74.9714 29.74 63.7814 35.85C61.9614 36.84 53.8714 39.96 41.6714 40.57V43.64C48.8414 43.16 60.1214 41.74 66.5114 37.57C80.1214 28.7 57.3314 24.01 57.3314 24.01Z" />\n<path d="M57.3414 23.96L57.5914 24.06L57.7014 23.95L57.3414 23.96ZM58.4414 24.69L58.8914 24.74C58.7314 24.32 59.0414 24.51 58.4214 24.08C58.1714 24.08 57.6114 24.08 57.6514 24.24C57.8214 24.26 58.1114 24.19 58.3514 24.29C58.2214 24.37 57.9514 24.29 57.7914 24.4C58.1714 24.6 58.0714 24.37 58.5114 24.53L58.4414 24.69ZM59.0414 24.46C58.9914 24.51 58.9314 24.56 58.9214 24.61C58.9814 24.56 59.2114 24.54 59.0414 24.46ZM59.3214 24.49C59.5914 24.58 59.2814 24.62 59.3014 24.65L59.6714 24.51L59.3214 24.49ZM60.4514 24.83L60.5814 24.84C60.5514 24.79 60.5014 24.82 60.4514 24.83ZM61.0114 24.97C60.9214 24.86 60.7714 24.86 60.5814 24.85L60.5914 24.86C60.7314 24.98 60.5414 25.1 60.3014 24.98C60.0314 24.94 60.1014 24.79 59.8414 24.83L60.1114 25.05C60.5314 25.15 60.8314 24.98 61.0114 24.97ZM60.4514 24.83L60.3014 24.8C60.3514 24.84 60.4014 24.84 60.4514 24.83ZM59.8814 24.65L59.7314 24.64L59.7514 24.72L59.8814 24.65ZM61.9414 25.25C61.8014 25.45 61.2914 25.01 61.1614 25.16C61.5314 25.27 61.7614 25.53 61.6414 25.62L62.0614 25.68C62.2214 25.65 62.1114 25.42 61.9414 25.25ZM62.5214 26.07C62.5514 26.06 62.5914 26.06 62.6214 26.07C62.5814 26.06 62.5414 26.06 62.5214 26.07ZM64.6314 26.47L63.6414 26.31C63.7514 26.28 63.7414 26.2 63.9614 26.26C63.5714 26.06 63.4614 26.19 63.1414 26.04C63.1114 25.8 63.7314 26.25 63.6114 25.99C63.3714 25.91 63.0114 25.78 62.7614 25.89L62.4314 25.62L62.4814 25.88C62.6114 26 62.8514 25.82 62.8914 26.01C62.9014 26.12 62.7414 26.08 62.6314 26.07C62.8914 26.11 63.2214 26.48 63.7114 26.64C64.2314 26.83 64.2514 26.43 64.6314 26.47ZM64.5614 26.72L64.5914 26.83L64.6014 26.7L64.5614 26.72ZM65.6614 26.88L65.1414 26.8C65.0914 26.76 65.0914 26.7 65.0714 26.65C65.0714 26.71 64.9014 26.74 64.9114 26.79C65.0314 27.07 65.5014 26.98 65.7614 27.07C66.3614 27.47 65.6814 27.16 65.8414 27.46C65.6614 27.37 65.6814 27.32 65.4414 27.18C65.7314 27.58 66.3014 27.64 66.5814 27.72C66.5214 27.67 66.5314 27.6 66.3914 27.54L66.6814 27.62C66.4914 27.33 66.2914 27.15 65.6614 26.88ZM64.8314 26.5C65.0114 26.57 65.0714 26.61 65.0714 26.64C65.0514 26.57 65.0114 26.51 64.8314 26.5ZM66.7114 27.79C66.6914 27.76 66.6514 27.74 66.5814 27.72C66.6014 27.75 66.6414 27.77 66.7114 27.79ZM66.5914 27.43L66.8914 27.62L66.8114 27.46C66.7714 27.45 66.6014 27.38 66.5914 27.43ZM66.3814 37.05C66.4514 37.11 66.5814 37.07 66.7914 36.9C66.8314 37.01 66.5314 37.2 66.4314 37.35C66.7714 37.2 66.5014 37.46 66.6414 37.51C66.9814 37.28 67.0414 37.05 67.4214 36.83C67.4214 36.86 67.4614 36.9 67.5314 36.9C67.9014 36.52 68.5414 35.9 68.9514 35.59C69.3414 35.29 69.5414 34.97 69.8314 34.51C70.3614 33.82 70.7614 32.96 70.7214 32.05C70.7014 31.14 70.2414 30.29 69.6514 29.55C69.5314 29.53 69.4214 29.52 69.3014 29.51C69.3214 29.37 68.9814 29.21 69.1214 29.14C69.1714 29.23 69.2614 29.28 69.3514 29.36C69.2114 28.93 68.5414 28.65 68.1914 28.32C68.2114 28.38 68.1614 28.58 68.0214 28.53C68.1914 28.35 67.5614 28.21 67.5814 27.89C67.2014 27.58 67.4514 28.07 67.0414 27.77C66.9214 27.88 67.4214 28.09 67.4314 28.23C67.2414 28.25 67.0714 27.95 67.0114 28.1C67.6614 28.55 69.0614 29.14 69.8714 30.07L69.6814 30.06C70.1614 30.46 70.5614 31.42 70.3314 31.88C70.4914 31.78 70.2614 32.68 70.5214 32.65C70.4214 32.78 70.4514 32.83 70.3514 33.02L70.4214 33.11C70.3014 33.4 70.2014 33.3 70.0614 33.62C70.2914 33.47 70.2114 33.71 70.2414 33.86C69.9214 34.17 69.5214 34.47 69.2014 34.67C69.2514 34.68 69.3014 34.68 69.4214 34.62C69.2414 34.79 69.3614 34.83 69.3514 34.92C69.2014 35.12 69.0814 34.97 69.0314 34.91C68.6814 35.18 68.7614 35.55 68.4514 35.71L68.6214 35.73C68.2914 36.07 67.8814 36.2 67.5114 36.57C67.2014 36.57 67.7514 36.18 67.8614 35.98C67.7514 36.01 67.5814 36.14 67.4814 36.14C67.3814 36.36 67.1414 36.66 66.9714 36.9C67.0614 36.57 66.5314 36.96 66.3814 37.05ZM67.4814 36.14C67.5114 36.08 67.5314 36.03 67.5514 35.99C67.5214 36.03 67.4914 36.07 67.4314 36.11C67.4414 36.14 67.4614 36.14 67.4814 36.14ZM66.3814 37.05L66.3614 37.04C66.3214 37.08 66.3314 37.08 66.3814 37.05ZM69.0114 35.55L68.9514 35.59L68.8814 35.65L69.0114 35.55ZM68.8414 34.86C68.9514 34.83 69.0714 34.76 69.2014 34.67C69.1214 34.66 69.0914 34.68 68.8414 34.86ZM70.3214 32.44C70.3114 32.36 70.2614 32.4 70.2314 32.34C70.2014 32.5 70.2314 32.57 70.3214 32.44ZM67.0214 36.45L66.7214 36.71L66.6214 36.82L67.0214 36.45ZM60.1014 40.55C60.4814 40.59 60.9614 40.35 61.3714 40.21C62.1014 39.85 61.3514 39.85 62.0514 39.57V39.92C62.7514 39.63 63.7814 39.26 64.2314 38.71C64.3014 38.72 64.4414 38.7 64.2914 38.83C64.7314 38.59 64.3114 38.3 64.9514 38.09C64.4914 38.55 65.2314 38.17 65.1714 38.42L65.1014 38.49C65.4714 38.27 65.8914 37.87 66.1514 37.74C66.1114 37.66 65.8314 37.68 66.1514 37.48C66.0114 37.54 66.0114 37.43 65.9814 37.35C65.7014 37.63 65.4914 37.69 65.3414 37.91C65.1114 37.92 65.4514 37.8 65.2114 37.82C65.1414 37.9 65.0714 37.98 64.9914 38.06C64.7814 38.14 65.1514 37.85 64.8214 37.99C64.8214 38.07 64.5914 38.26 64.3414 38.37L64.3914 38.3C64.2214 38.44 63.9314 38.53 64.1014 38.65L63.8014 38.6L63.8914 38.69C63.3314 38.89 63.0114 38.7 62.3814 39.14C62.5614 39.11 62.4414 39.23 62.3514 39.3C62.6814 39.25 62.6814 39.05 62.9414 38.92C63.0314 39.01 62.6214 39.35 62.9914 39.28C62.5614 39.3 62.3014 39.6 62.0214 39.36C61.5614 39.52 61.4514 39.72 60.9714 39.83L60.9614 39.78C60.9514 40.01 60.5614 39.82 60.2814 40.13L60.5414 40.1C60.5614 40.18 60.4414 40.22 60.2814 40.29C60.2814 40.25 60.2814 40.25 60.2214 40.23C60.2114 40.39 59.6914 40.59 59.6414 40.65C59.8714 40.6 60.1014 40.39 60.3514 40.27C60.2514 40.4 60.3314 40.5 60.1014 40.55ZM64.4914 38.17L64.3914 38.31C64.4414 38.27 64.4814 38.22 64.4914 38.17ZM57.9114 40.94C57.6114 40.99 57.9614 40.79 57.6714 40.81C57.3914 40.99 58.0714 40.91 57.8114 41.15C57.6114 41.11 57.3514 41.33 57.2214 41.37C57.3414 41.25 57.2114 41.08 57.1414 41.05C57.0414 41.14 56.7614 41.11 56.5614 41.15C57.0814 41.15 56.1714 41.32 56.6414 41.34C56.6414 41.46 56.2014 41.67 55.9914 41.62C55.9914 41.54 56.1414 41.52 56.2614 41.48C56.3314 41.3 55.9414 41.48 55.8314 41.35C55.4214 41.67 53.9214 41.98 54.4214 42.24C54.5914 42.27 54.7114 42.15 54.8814 42.1C54.3814 42.14 54.8414 41.92 54.8614 41.85C55.0814 41.85 55.4114 41.67 55.3614 41.81L55.0614 42.01C56.1314 41.85 57.5714 41.48 58.7514 41.07L58.2314 41.21C58.2614 41.1 58.5114 41.03 58.6814 40.93L58.3714 40.77C58.5214 40.75 58.6514 40.68 58.6614 40.76C58.8114 40.61 58.7114 40.58 58.5814 40.53C58.9614 40.38 59.0414 40.46 59.2914 40.22C58.6114 40.22 58.8014 40.53 58.0314 40.57L57.9114 40.94ZM59.2714 40.41L59.1514 40.57L59.3714 40.45L59.2714 40.41ZM59.1814 40.98C59.1614 40.93 59.2514 40.88 59.2214 40.84C58.9114 40.89 58.9714 40.95 59.1814 40.98ZM55.4314 41.43L55.0514 41.55L55.3114 41.54C55.3014 41.49 55.3914 41.45 55.4314 41.43ZM52.8014 42.59C53.3414 42.46 53.5514 42.31 54.2014 42.3C54.4714 42.09 54.0014 42.05 54.1014 41.89C53.7914 41.91 53.8814 42.16 53.5714 42.27C53.4214 42.16 53.1114 42.39 52.8014 42.42C52.8514 42.47 52.8614 42.53 52.8014 42.59ZM50.8214 42.41C50.5714 42.45 50.3314 42.59 50.1214 42.55C50.1414 42.47 50.2814 42.41 50.4414 42.41C50.3214 42.24 50.1714 42.49 49.8814 42.4C49.9014 42.42 50.0114 42.43 49.9414 42.49C49.2614 42.54 49.5814 42.7 48.6914 42.71C48.5714 42.78 48.4414 42.79 48.4814 42.91C47.9614 42.82 48.2114 42.79 47.5914 42.73C47.6214 42.8 47.8414 42.94 47.8614 43.1C46.9814 42.98 46.9914 43.23 46.4314 43.13C46.4914 43.12 46.5614 43.07 46.7114 43.07C46.6114 42.86 46.2614 43.16 45.9514 43.15L45.9614 42.96C45.6814 43.02 45.2114 43.19 44.8514 43.09L44.9214 42.99C44.2214 43.2 43.3814 43.2 42.7814 43.32L42.4514 43.23C42.1814 43.32 42.2614 43.33 42.4814 43.35C42.7214 43.37 42.9914 43.4 42.6914 43.56C42.5814 43.22 42.2614 43.7 41.8014 43.6C41.7414 43.46 42.2614 43.49 42.1414 43.34C42.0214 43.49 41.9414 43.45 41.8314 43.46C41.8414 43.42 41.8314 43.38 41.8214 43.34C41.9914 43.24 41.8414 42.96 42.0314 42.99C41.9314 42.9 41.8314 42.45 41.7214 42.2C41.8214 42.05 41.8014 41.79 41.7814 41.6C41.7814 42.08 41.5314 41.47 41.4514 42.01C41.5014 42.42 41.5314 43.02 41.5414 43.77C42.1814 43.71 42.7314 43.69 43.1614 43.69C43.2514 43.45 43.7914 43.64 43.9314 43.44C43.9614 43.51 44.0414 43.57 44.0714 43.64C44.7014 43.54 43.9114 43.53 44.0614 43.43C44.3314 43.38 44.5714 43.49 44.5514 43.58C45.0114 43.55 44.6014 43.51 44.8214 43.37L45.1414 43.59C46.5614 43.38 48.4114 42.98 50.0414 42.88L49.8914 42.75C50.6314 42.72 51.0514 42.22 51.7514 42.44L51.9514 42.27C51.8414 42.37 52.1114 42.48 51.9414 42.62C52.1314 42.53 52.3514 42.55 52.5414 42.47L52.1714 42.46C52.4014 42.28 52.6914 42.32 52.8014 42.42C53.3114 42.16 52.4314 42.21 52.2814 42.1C51.5714 42.51 51.4714 41.95 50.7714 42.19C50.3314 42.35 50.8414 42.33 50.8214 42.41ZM51.8314 42.68C51.8814 42.66 51.9114 42.64 51.9414 42.62C51.9014 42.64 51.8714 42.65 51.8314 42.68ZM41.7814 41.6C41.7714 41.55 41.7714 41.48 41.7714 41.39C41.7314 41.31 41.7514 41.43 41.7814 41.6ZM52.8014 42.42H52.7914H52.8014ZM53.0914 41.97L52.8914 42L52.9414 42.07L53.0914 41.97ZM42.8314 40.81L42.8214 40.73C42.8014 40.75 42.8014 40.78 42.8314 40.81ZM48.7014 40.27L48.5714 40.28C48.6114 40.29 48.6614 40.28 48.7014 40.27ZM62.3714 36.69C62.7114 36.5 63.1614 36.25 63.3514 36.01L63.3614 36.09C63.5414 35.97 64.0514 35.54 63.6114 35.61L63.5514 35.72C63.1814 36.05 63.1814 35.75 62.8214 35.86C62.4314 36.07 62.3114 36.46 61.9014 36.54C61.7414 36.61 61.7414 36.52 61.7614 36.45C61.3814 36.57 61.3214 36.85 61.0614 36.97C60.7514 36.42 59.9414 37.55 59.2414 37.35C58.8914 37.51 58.3914 37.6 57.9614 37.86C58.1614 37.64 57.5214 37.97 57.5714 37.77C57.5314 38.15 56.1914 37.98 56.2214 38.43C55.5514 38.46 56.2014 38.47 55.4314 38.54C55.4214 38.49 55.5514 38.46 55.5914 38.44C55.2814 38.42 55.1914 38.75 54.9014 38.59C54.3014 38.69 54.8314 38.74 54.5014 38.94C53.8714 39.02 54.0314 38.92 53.6514 38.81C53.6414 39.04 53.2514 39.01 52.9714 39.18C53.0514 39.18 53.4814 39.14 53.2214 39.27C52.4914 39.38 52.6714 39.53 52.0014 39.72C51.6114 39.55 52.6714 39.58 52.0414 39.51C52.4514 39.31 52.7814 39.26 52.9714 39.04C52.4014 39.14 51.7114 39.32 51.0914 39.52C50.7414 39.55 51.2514 39.38 50.9714 39.4C50.3314 39.4 50.0614 39.82 49.5414 39.78L49.6214 39.64C49.3414 39.85 48.5114 39.77 47.9414 39.93C48.0314 39.99 48.0814 40.02 48.0114 40.07C47.9814 39.76 47.2214 40.33 46.6114 40.18C46.6814 40.37 46.1414 40.56 45.7814 40.6C45.6514 40.56 45.6714 40.48 45.6614 40.42C46.2614 40.49 46.2114 40.15 46.6514 40.01C46.2814 40.16 45.6414 40.12 45.3214 40.29L45.4414 40.12C44.9114 40.15 45.0114 40.51 44.4414 40.41L44.4814 40.3C43.5214 40.4 42.6014 40.3 41.5614 40.47C41.5814 40.7 41.6114 40.91 41.6514 41.07C41.7514 41.12 41.9714 40.87 42.0414 40.97L42.0214 40.91C42.0914 40.86 42.1714 40.8 42.3014 40.73C42.4514 40.66 42.6314 40.6 42.8214 40.55V40.73C42.9114 40.6 43.3914 40.49 43.1114 40.41C43.4414 40.3 43.3814 40.56 43.7514 40.43C43.7414 40.62 43.5114 40.65 43.5114 40.81L43.8414 40.69C43.7414 40.77 44.0514 40.74 43.9514 40.82C44.5514 40.54 44.8214 40.83 45.4514 40.67H45.0914C45.0914 40.57 45.2914 40.56 45.4414 40.52C45.6314 40.65 45.7314 40.62 46.0714 40.65C46.3414 40.54 46.4714 40.33 46.8514 40.29C46.8014 40.49 47.5014 40.32 47.5914 40.48C47.6514 40.27 48.3214 40.32 48.3614 40.2C48.5514 40.13 48.8314 40.11 48.8514 40.21C48.8214 40.22 48.7514 40.25 48.7014 40.27L48.9014 40.24C48.8914 40.27 48.9014 40.29 48.8714 40.29C49.0514 40.27 49.0314 40.13 49.2814 40.19C49.2914 40.24 49.1614 40.26 49.0614 40.3C49.5514 40.26 49.8614 39.89 50.2914 39.99C50.3514 39.89 50.9014 39.79 50.7414 39.6C50.9114 39.65 50.8814 39.82 51.2814 39.72C51.4814 39.51 51.7414 39.71 52.0214 39.54C51.6514 39.8 52.0314 39.6 51.7114 39.83C52.0014 39.86 52.3614 39.54 52.8414 39.48C52.9014 39.51 52.9114 39.56 52.9714 39.6C53.1314 39.5 53.3114 39.32 53.5114 39.43L53.4614 39.31C53.8014 39.31 54.2414 39.16 54.6114 39.22L54.9614 38.9C55.5614 39.02 56.2414 38.62 56.6014 38.31C56.8014 38.26 57.1114 38.22 57.1214 38.28C57.0814 38.31 57.0014 38.36 56.9314 38.42C57.2214 38.35 57.6114 38.38 57.7214 38.15C58.0014 38.01 57.9714 38.22 58.2014 38.19C58.7214 37.75 60.0214 37.85 60.0714 37.38C59.8214 37.45 59.3414 37.53 58.8814 37.68C58.9914 37.6 58.8714 37.54 59.0414 37.48C59.4914 37.32 59.7814 37.39 60.2214 37.18L60.2514 37.45C61.1414 37.44 61.6214 36.58 62.3714 36.69ZM56.4414 38.58L56.8114 38.63L56.7514 38.52C56.6514 38.57 56.5414 38.6 56.4414 38.58ZM56.7514 38.52C56.8114 38.49 56.8714 38.46 56.9314 38.42C56.8614 38.44 56.7914 38.46 56.7314 38.5L56.7514 38.52ZM63.6414 36.08C63.7114 36.05 63.8614 36 63.9814 35.89C63.8814 35.92 63.6914 36 63.6414 36.08ZM63.9614 35.81L63.7914 35.86L63.7814 35.9L63.9614 35.81ZM64.9814 28.04C64.8014 27.97 64.6214 27.9 64.4414 27.84C64.4114 27.72 63.8414 27.44 64.0814 27.44C63.7014 27.42 63.1914 26.88 63.2714 27.26C64.6814 28.02 66.5014 29.47 67.1114 31.07C67.0714 30.99 66.9914 30.91 66.9314 30.84C67.1814 31.22 67.1114 31.55 67.0614 31.8C66.9814 32.07 66.9514 32.29 66.9814 32.71L66.8114 32.53C66.6214 32.84 66.7114 33.4 66.2114 33.58L66.3114 33.61C66.2314 33.7 66.1714 33.7 66.0914 33.79L66.1514 33.78C66.0114 34.09 65.8214 34.19 65.5514 34.36C65.4814 34.32 65.6414 34.24 65.7014 34.16C65.5414 34.19 65.4714 34.49 65.2514 34.63C65.0514 34.69 65.1914 34.54 65.1914 34.5C64.6514 35.03 64.2314 34.99 63.9414 35.55C63.9314 35.63 64.1714 35.55 63.9514 35.72C64.4314 35.55 64.7314 35.24 65.0414 34.89L64.9414 34.96C65.0314 34.48 65.2214 34.88 65.5814 34.4C65.5614 34.61 65.3514 34.76 65.3014 34.87C66.0114 34.65 65.9414 34.13 66.4714 34.04L66.4414 34.08C66.5314 34.03 66.6114 33.85 66.6914 33.71C66.6314 33.73 66.5114 33.82 66.4214 33.88C66.5014 33.74 66.4414 33.59 66.4314 33.51C66.6614 33.49 66.5014 33.3 66.7114 33.13C66.8814 33.12 66.6914 33.38 66.6914 33.51L66.8014 33.19C66.9614 32.94 67.0914 33.02 67.2214 32.92C67.2314 32.64 67.0914 33.02 67.0414 32.77C67.1914 32.67 67.4014 32.28 67.4314 31.81C67.4914 31.34 67.3014 30.85 67.1314 30.58C67.2214 30.78 67.2914 30.6 67.3614 30.87C67.3614 30.77 67.1814 30.45 67.0814 30.49C66.8214 30.14 66.5914 29.64 66.3714 29.26V29.42C66.0214 29.27 65.8814 28.66 65.3214 28.33L65.3314 28.34C65.1714 28.22 64.8714 28.32 64.6114 28.06C64.7714 28.02 64.9214 28.15 64.9814 28.04ZM63.0114 27.01L63.2614 26.99C63.0814 26.85 62.7514 26.87 62.7414 26.98C62.8914 27.02 63.0314 27.18 63.0914 27.12C63.0814 27.09 63.1114 27.05 63.0114 27.01ZM59.2214 25.19C59.1314 25.19 59.1314 25.25 59.0814 25.27C59.9114 25.59 60.9414 26 61.2014 26.26C61.4514 26.43 61.6014 26.26 61.9614 26.39L62.0414 26.6C62.2614 26.61 62.7314 27.05 62.6614 26.73C62.6414 26.7 62.4414 26.75 62.3114 26.63L62.3814 26.57L62.0114 26.4L62.1714 26.37C61.7514 25.99 61.6914 26.46 61.1314 26.09L61.2214 25.9C60.8214 25.69 60.5814 25.66 60.2614 25.38C60.2614 25.38 60.2214 25.48 60.3114 25.47C60.3714 25.51 60.4314 25.63 60.3514 25.66C59.6614 25.54 60.5014 25.59 60.1014 25.32C59.5114 25.21 58.4314 24.92 58.1914 24.65C58.4014 24.86 57.9714 24.84 57.6714 24.72C57.5614 24.6 57.8114 24.64 57.8814 24.6C57.7514 24.53 57.6514 24.44 57.5014 24.42C57.6514 24.59 57.4614 24.69 57.1214 24.65C57.7914 25.01 58.5114 24.88 59.2214 25.19ZM58.9414 25.27C59.0114 25.29 59.0614 25.29 59.0814 25.27C58.9814 25.24 58.8814 25.2 58.7914 25.16L58.9414 25.27Z" />\n<path d="M36.4614 41.33L28.3014 37.92C27.2414 37.47 26.3714 37.75 26.3714 38.54V40.36C15.8814 39.43 8.97145 36.75 7.31145 35.85C-3.87855 29.74 13.7614 24.01 13.7614 24.01C13.7614 24.01 -9.02855 28.7 4.57145 37.57C10.1214 41.19 19.3414 42.73 26.3714 43.39V43.57V45.73C26.3714 46.52 27.2414 46.8 28.3014 46.36L36.4614 42.95C37.5314 42.5 37.5314 41.77 36.4614 41.33Z" />\n<path d="M36.4814 41.27C36.5814 41.33 36.6714 41.39 36.7514 41.46L36.9114 41.4C36.7714 41.34 36.6214 41.31 36.4814 41.27ZM36.7914 42.25C36.7714 42.33 36.7314 42.38 36.5914 42.49C36.8014 42.58 36.8314 42.63 36.8914 42.66C36.9314 42.65 37.1214 42.73 37.4314 42.27C37.4514 42.08 37.3014 41.79 37.1114 41.69C36.9214 41.58 36.7714 41.58 36.7614 41.66C36.9014 41.72 37.2914 41.87 37.2114 42.21C37.1514 42.07 37.0014 41.81 36.8114 41.85C36.8614 42.12 37.1114 41.99 36.9414 42.34L36.7914 42.25ZM36.6714 42.81C36.6914 42.73 36.7014 42.65 36.6614 42.61C36.6614 42.69 36.4714 42.87 36.6714 42.81ZM36.3914 42.98C36.0714 43.1 36.3514 42.85 36.3114 42.85L36.0414 43.22L36.3914 42.98ZM35.0714 43.52L34.9314 43.6C35.0014 43.61 35.0314 43.56 35.0714 43.52ZM34.4414 43.81C34.6014 43.83 34.7414 43.72 34.9314 43.6C34.9314 43.6 34.9214 43.6 34.9114 43.59C34.7014 43.6 34.8014 43.38 35.1114 43.29C35.4014 43.13 35.4414 43.3 35.6614 43.09L35.2514 43.11C34.7714 43.33 34.6014 43.67 34.4414 43.81ZM35.0714 43.52L35.2414 43.43C35.1514 43.44 35.1114 43.48 35.0714 43.52ZM35.7414 43.26L35.8914 43.16L35.8214 43.11L35.7414 43.26ZM33.3614 44.28C33.3514 44.03 34.1414 43.98 34.1514 43.78C33.7314 43.96 33.3314 43.95 33.3714 43.79L32.9314 44.05C32.8014 44.2 33.0714 44.28 33.3614 44.28ZM32.2114 44.12C32.1914 44.15 32.1614 44.18 32.1214 44.2C32.1714 44.17 32.2114 44.14 32.2114 44.12ZM29.9814 45.48L30.9914 44.81C30.9214 44.92 30.9914 44.97 30.7514 45.1C31.2514 44.92 31.2514 44.76 31.6614 44.61C31.8714 44.76 30.9614 44.93 31.2714 45.01C31.5514 44.88 31.9714 44.7 32.1214 44.43L32.6314 44.38L32.3914 44.23C32.1814 44.24 32.0914 44.55 31.9114 44.45C31.8214 44.38 31.9914 44.28 32.1114 44.21C31.8414 44.37 31.2514 44.37 30.6714 44.64C30.0614 44.93 30.3514 45.21 29.9814 45.48ZM29.8414 45.26L29.7314 45.21L29.8314 45.3L29.8414 45.26ZM28.7614 46.05L29.2814 45.67C29.3414 45.67 29.4014 45.7 29.4614 45.72C29.4114 45.68 29.5314 45.53 29.4914 45.5C29.1414 45.41 28.8114 45.85 28.5214 46.02C27.6814 46.26 28.5114 45.9 28.1214 45.84C28.3514 45.75 28.3814 45.8 28.7014 45.68C28.0714 45.69 27.6714 46.09 27.3914 46.13C27.4714 46.15 27.4914 46.22 27.6514 46.17C27.5514 46.21 27.4614 46.25 27.3614 46.27C27.6814 46.44 28.0114 46.42 28.7614 46.05ZM29.7814 45.62C29.5714 45.72 29.4914 45.74 29.4614 45.72C29.5414 45.75 29.6314 45.76 29.7814 45.62ZM27.2514 46.13C27.2814 46.15 27.3314 46.15 27.3914 46.13C27.3614 46.12 27.3214 46.12 27.2514 46.13ZM27.5414 46.38C27.4114 46.38 27.2814 46.38 27.1614 46.35C27.2014 46.4 27.2514 46.44 27.3014 46.47C27.3614 46.47 27.5614 46.43 27.5414 46.38ZM14.0414 40.85C14.0614 40.95 14.2014 41.03 14.5314 41.09C14.4614 41.19 14.0514 41.07 13.8314 41.08C14.2414 41.26 13.7914 41.21 13.8714 41.35C14.3514 41.48 14.6014 41.39 15.1114 41.54C15.0714 41.57 15.0714 41.62 15.1314 41.67C15.7714 41.75 16.8414 41.87 17.4414 42.08C18.0114 42.25 18.4714 42.26 19.1214 42.33C21.2514 42.76 23.5014 42.93 25.8214 43.27C25.9514 43.21 26.1214 43.15 26.3214 43.1C26.3614 43.15 26.4814 43.17 26.6014 43.18C26.5914 43.39 26.6014 43.58 26.5114 43.57C26.5314 43.46 26.5214 43.36 26.5214 43.26C26.4614 43.25 26.4014 43.25 26.3314 43.24C26.3714 43.27 26.4214 43.29 26.4714 43.3C26.3514 43.94 26.5214 44.61 26.4614 45.17C26.5014 45.1 26.6914 45 26.7314 45.18C26.4914 45.15 26.6914 45.87 26.5014 46.03C26.7414 46.5 26.6414 45.97 26.9714 46.25C27.0314 46.15 26.7014 45.98 26.8314 45.87C26.9414 45.89 26.9214 46.07 27.0114 45.95C26.9614 45.9 26.9614 45.88 26.9214 45.81C26.9014 45.76 26.8914 45.36 26.8714 45.14C26.8214 44.58 26.7514 44.08 26.6914 43.1C26.1614 43.08 25.6414 43.06 25.1614 43.04L25.3314 42.92C24.5414 42.94 23.2914 42.8 22.7014 42.49C22.8314 42.64 21.5714 42.27 21.6414 42.58C21.4614 42.48 21.4014 42.48 21.1214 42.42L21.0414 42.5C20.6414 42.44 20.7314 42.3 20.2714 42.24C20.5514 42.42 20.2114 42.4 20.0614 42.49C19.5414 42.26 19.0014 42.03 18.5514 41.83C18.5814 41.88 18.6114 41.94 18.7614 42.02C18.4614 41.92 18.4914 42.05 18.3914 42.08C18.0914 42.03 18.1514 41.87 18.1814 41.79C17.6414 41.64 17.3414 41.9 16.9514 41.71L17.0614 41.87C16.4914 41.79 16.0414 41.54 15.4114 41.44C15.1614 41.2 15.9614 41.41 16.2314 41.39C16.1214 41.32 15.8514 41.25 15.7814 41.17C15.5014 41.2 15.0214 41.23 14.6714 41.23C15.0314 41.1 14.2514 40.92 14.0414 40.85ZM15.7814 41.17C15.8614 41.16 15.9214 41.15 15.9714 41.14C15.9114 41.14 15.8514 41.14 15.7614 41.11C15.7514 41.13 15.7614 41.15 15.7814 41.17ZM14.0414 40.85L14.0314 40.83C13.9714 40.82 13.9914 40.83 14.0414 40.85ZM17.5214 42.11L17.4414 42.08C17.4014 42.07 17.3714 42.07 17.3314 42.06L17.5214 42.11ZM18.1014 41.61C18.2114 41.67 18.3714 41.75 18.5514 41.83C18.5114 41.76 18.4714 41.71 18.1014 41.61ZM21.9114 42.38C22.0314 42.37 21.9714 42.32 22.0514 42.29C21.8114 42.25 21.7214 42.28 21.9114 42.38ZM15.1114 40.99L14.6314 40.91L14.4514 40.9L15.1114 40.99ZM5.68142 38.31C5.99142 38.64 6.59142 38.87 7.06142 39.11C7.98142 39.44 7.32142 38.85 8.16142 39.21L7.88142 39.45C8.74142 39.8 9.95142 40.32 10.7814 40.3C10.8414 40.36 10.9814 40.45 10.7314 40.42C11.3214 40.6 11.1814 40.08 11.9214 40.43C11.1414 40.39 12.1114 40.69 11.8514 40.82L11.7314 40.8C12.2314 40.94 12.9314 41.01 13.2514 41.12C13.2914 41.05 13.0314 40.84 13.4814 40.95C13.3014 40.89 13.4014 40.82 13.4414 40.74C12.9614 40.7 12.7314 40.58 12.4214 40.61C12.2014 40.43 12.6014 40.62 12.3814 40.44L11.9814 40.43C11.7214 40.32 12.2914 40.41 11.8814 40.26C11.8214 40.31 11.4614 40.27 11.1414 40.15L11.2514 40.14C10.9814 40.11 10.6514 39.94 10.7114 40.15L10.4814 39.88L10.4914 40.02C9.84142 39.73 9.68142 39.38 8.79142 39.17C8.97142 39.29 8.76142 39.27 8.64142 39.25C8.97142 39.47 9.12142 39.34 9.46142 39.46C9.46142 39.6 8.84142 39.51 9.22142 39.74C8.82142 39.42 8.36142 39.41 8.29142 39.05C7.77142 38.8 7.51142 38.84 7.00142 38.53L7.03142 38.5C6.84142 38.63 6.65142 38.19 6.17142 38.18L6.42142 38.36C6.37142 38.43 6.24142 38.36 6.04142 38.28C6.08142 38.26 6.08142 38.26 6.04142 38.19C5.90142 38.3 5.31142 37.98 5.22142 37.97C5.45142 38.14 5.81142 38.22 6.12142 38.33C5.93142 38.33 5.92142 38.46 5.68142 38.31ZM11.4514 40.13L11.2414 40.14C11.3214 40.16 11.4014 40.16 11.4514 40.13ZM3.59142 36.64C3.32142 36.39 3.74142 36.6 3.52142 36.34C3.16142 36.18 3.72142 36.78 3.34142 36.67C3.22142 36.45 2.84142 36.33 2.71142 36.24C2.90142 36.28 2.95142 36.06 2.93142 35.99C2.78142 35.94 2.59142 35.67 2.44142 35.49C2.77142 36 2.03142 35.19 2.32142 35.67C2.21142 35.72 1.74142 35.38 1.65142 35.15C1.72142 35.11 1.84142 35.25 1.95142 35.36C2.15142 35.33 1.73142 35.04 1.80142 34.86C1.55142 34.72 1.12142 34.3 0.851423 33.92C0.541423 33.56 0.401423 33.24 0.311423 33.57C0.321423 33.8 0.481423 33.92 0.611423 34.1C0.361423 33.53 0.781423 34.01 0.851423 34.02C0.931423 34.27 1.27142 34.57 1.11142 34.56C0.981423 34.48 0.891423 34.38 0.781423 34.29C1.42142 35.49 2.86142 36.68 4.14142 37.46L3.61142 37.08C3.73142 37.05 3.99142 37.22 4.21142 37.32L4.08142 36.94C4.22142 37.06 4.39142 37.14 4.33142 37.2C4.57142 37.25 4.52142 37.14 4.45142 36.99C4.86142 37.24 4.89142 37.34 5.28142 37.4C4.71142 36.84 4.63142 37.18 3.98142 36.53L3.59142 36.64ZM5.11142 37.51H4.88142L5.16142 37.61L5.11142 37.51ZM4.57142 37.79C4.59142 37.74 4.70142 37.78 4.72142 37.73C4.42142 37.51 4.42142 37.59 4.57142 37.79ZM1.51142 34.49C1.41142 34.37 1.29142 34.26 1.21142 34.14C1.25142 34.23 1.29142 34.32 1.34142 34.41C1.38142 34.37 1.47142 34.45 1.51142 34.49ZM0.0314229 31.47C-0.0585771 32.2 0.061423 32.5 0.181423 33.3C0.471423 33.62 0.391423 33.05 0.581423 33.16C0.491423 32.81 0.291423 32.91 0.151423 32.52C0.241423 32.37 0.0914229 31.93 0.181423 31.54C0.121423 31.58 0.0614229 31.57 0.0314229 31.47ZM1.56142 29.65C1.75142 29.43 1.92142 29.16 2.13142 29.03C2.16142 29.12 2.05142 29.27 1.91142 29.37C2.12142 29.44 2.11142 29.11 2.45142 29.01C2.42142 29.01 2.30142 29.06 2.35142 28.97C3.00142 28.51 2.60142 28.55 3.54142 28.05C3.64142 27.93 3.77142 27.85 3.69142 27.75C4.29142 27.58 4.02142 27.73 4.72142 27.5C4.66142 27.45 4.38142 27.42 4.30142 27.28C5.32142 26.98 5.23142 26.77 5.90142 26.63C5.84142 26.67 5.77142 26.74 5.60142 26.8C5.77142 26.96 6.09142 26.53 6.44142 26.42L6.49142 26.61C6.78142 26.45 7.28142 26.11 7.73142 26.09L7.67142 26.22C8.42142 25.77 9.40142 25.51 10.0814 25.23L10.4914 25.22C11.4214 24.8 9.51142 25.45 10.1414 24.97C10.3414 25.27 10.6114 24.71 11.2114 24.68C11.5114 24.74 10.6614 24.91 11.0014 24.98C11.0714 24.77 11.2814 24.85 11.5614 24.71C11.5414 24.89 12.1914 24.57 12.0614 24.8L13.0314 24.24C13.2214 24.29 13.5214 24.2 13.7414 24.13C13.1714 24.25 13.8514 23.85 13.1914 23.92C12.2714 24.21 10.7314 24.69 9.56142 24.97C9.51142 25.24 8.83142 25.21 8.71142 25.45C8.66142 25.39 8.55142 25.36 8.50142 25.31C7.79142 25.61 8.71142 25.36 8.56142 25.5C8.25142 25.65 7.95142 25.61 7.95142 25.52C7.43142 25.71 7.91142 25.6 7.69142 25.82L7.26142 25.71C5.67142 26.43 3.65142 27.51 2.05142 28.69L2.26142 28.72C1.52142 29.25 1.43142 29.94 0.771423 30.41C0.761423 30.51 0.761423 30.61 0.771423 30.71C0.761423 30.54 0.501423 30.74 0.501423 30.48C0.461423 30.74 0.251423 30.94 0.251423 31.22C0.301423 31.07 0.391423 30.94 0.481423 30.82C0.451423 31.14 0.341423 31.45 0.191423 31.54C0.221423 32.22 0.521423 31.19 0.711423 31.13C0.741423 30.68 0.911423 30.49 1.12142 30.37C1.30142 30.23 1.52142 30.14 1.74142 29.79C2.03142 29.34 1.60142 29.72 1.56142 29.65ZM0.531423 30.33C0.501423 30.39 0.501423 30.44 0.501423 30.48C0.511423 30.44 0.521423 30.39 0.531423 30.33ZM13.7414 24.13C13.7514 24.13 13.7614 24.13 13.7814 24.12L13.7214 23.91C13.6714 23.93 13.6014 23.95 13.5114 23.99C13.4514 24.05 13.5514 23.99 13.7214 23.91L13.7814 24.12L13.7414 24.13ZM0.191423 31.54V31.53V31.54ZM0.531423 32.02L0.541423 31.79L0.461423 31.82L0.531423 32.02ZM11.2214 24.65L11.2514 24.73C11.2614 24.69 11.2614 24.67 11.2214 24.65ZM5.00142 28.27L5.12142 28.17C5.08142 28.19 5.04142 28.23 5.00142 28.27ZM14.4114 38.52C14.8714 38.6 15.4914 38.68 15.8514 38.64L15.8014 38.71C16.0514 38.73 16.8714 38.77 16.3914 38.52L16.2514 38.56C15.6614 38.55 15.8714 38.33 15.4414 38.17C14.8914 38.08 14.5114 38.3 14.0614 38.1C13.8514 38.06 13.9014 37.98 13.9814 37.94C13.5114 37.8 13.2614 37.97 12.9314 37.9C12.9814 37.27 11.4314 37.64 10.8614 37.02C10.4114 36.92 9.85142 36.67 9.26142 36.57C9.61142 36.54 8.75142 36.36 8.94142 36.24C8.63142 36.52 7.49142 35.44 7.20142 35.76C6.58142 35.25 7.16142 35.77 6.43142 35.21C6.45142 35.17 6.59142 35.25 6.64142 35.27C6.38142 35.02 6.07142 35.12 5.95142 34.78C5.38142 34.33 5.76142 34.82 5.35142 34.65C4.80142 34.1 4.99142 34.2 4.85142 33.77C4.64142 33.87 4.41142 33.47 4.13142 33.22C4.17142 33.3 4.43142 33.76 4.17142 33.52C3.91142 33.14 3.80142 32.99 3.69142 32.84C3.57142 32.7 3.44142 32.56 3.31142 32.11C3.44142 31.62 3.53142 32.98 3.53142 32.18C3.75142 32.69 3.96142 33.04 4.26142 33.17C3.88142 32.6 3.60142 31.81 3.67142 31.02C3.78142 30.62 3.74142 31.26 3.82142 30.94C4.11142 30.29 4.06142 29.78 4.51142 29.34L4.53142 29.51C4.63142 29.11 5.44142 28.54 5.94142 28.04C5.83142 28.05 5.75142 28.05 5.80142 27.96C5.98142 28.22 6.49142 27.22 7.22142 27.03C7.06142 26.89 7.59142 26.43 7.96142 26.2C8.12142 26.17 8.14142 26.26 8.16142 26.31C7.49142 26.56 7.67142 26.83 7.25142 27.21C7.58142 26.86 8.30142 26.58 8.59142 26.26L8.53142 26.48C9.10142 26.19 8.86142 25.9 9.53142 25.73L9.52142 25.86C10.7314 25.24 12.2714 24.82 13.2014 24.22C13.2614 24.1 12.6714 24.08 12.6114 24.02C12.0314 24.33 11.7414 24.63 11.3214 24.9L11.2514 24.73C11.1914 24.88 10.6814 25.19 11.0214 25.15C10.6914 25.39 10.6814 25.12 10.3014 25.41C10.2514 25.22 10.5014 25.09 10.4414 24.94L10.1114 25.2C10.1914 25.08 9.86142 25.24 9.94142 25.13C9.36142 25.65 8.95142 25.5 8.30142 25.97L8.70142 25.79C8.75142 25.88 8.52142 25.99 8.37142 26.11C8.12142 26.08 8.01142 26.16 7.63142 26.31C7.37142 26.55 7.31142 26.82 6.92142 27.06C6.89142 26.84 6.21142 27.41 6.05142 27.33C6.08142 27.55 5.36142 27.95 5.39142 28.09C5.22142 28.28 4.96142 28.51 4.89142 28.44C4.91142 28.41 4.96142 28.33 5.00142 28.27L4.82142 28.45C4.82142 28.42 4.80142 28.41 4.82142 28.39C4.65142 28.55 4.75142 28.64 4.48142 28.8C4.44142 28.76 4.55142 28.64 4.63142 28.53C4.17142 28.97 4.15142 29.53 3.75142 29.88C3.76142 30.01 3.50142 30.68 3.77142 30.61C3.66142 30.76 3.46142 30.63 3.41142 31.17C3.53142 31.47 3.31142 31.77 3.49142 32.15C3.22142 31.65 3.42142 32.17 3.21142 31.7C3.12142 32.11 3.52142 32.61 3.77142 33.17C3.77142 33.24 3.72142 33.26 3.72142 33.34C3.92142 33.5 4.16142 33.65 4.20142 33.9L4.28142 33.8C4.50142 34.17 4.94142 34.53 5.20142 34.92C5.38142 34.97 5.57142 35 5.75142 35.03C6.16142 35.65 7.09142 35.92 7.65142 35.96C7.87142 36.08 8.18142 36.27 8.16142 36.32C8.10142 36.31 7.99142 36.3 7.88142 36.29C8.21142 36.45 8.57142 36.74 8.83142 36.64C9.20142 36.71 9.04142 36.86 9.28142 36.99C10.0814 37 11.3214 37.93 11.6714 37.58C11.3714 37.49 10.8514 37.23 10.2914 37.06C10.4514 37.06 10.3714 36.94 10.5814 37C11.1314 37.17 11.3714 37.42 11.9514 37.52L11.8014 37.76C12.7014 38.33 13.7514 37.95 14.4114 38.52ZM7.29142 36.04L7.62142 36.36L7.63142 36.23C7.50142 36.19 7.38142 36.12 7.29142 36.04ZM7.63142 36.23C7.72142 36.26 7.80142 36.27 7.88142 36.28C7.80142 36.24 7.71142 36.21 7.63142 36.2V36.23ZM16.0714 38.88C16.1614 38.92 16.3414 38.98 16.5314 38.99C16.4114 38.93 16.1714 38.87 16.0714 38.88ZM16.5814 38.91L16.3814 38.82L16.3414 38.85L16.5814 38.91ZM26.5614 37.76C26.7514 37.55 27.0314 37.43 27.3014 37.37C27.4614 37.4 28.3114 37.51 28.0014 37.58C28.5214 37.53 29.2214 38.07 29.0414 37.68C28.4514 37.52 27.5214 36.85 26.3814 37.54C26.1114 37.73 25.9314 38.08 25.9114 38.39C25.8914 38.7 25.9014 38.84 25.9014 39.07V39.64L25.9114 39.85C25.3314 39.84 24.7614 39.82 24.1614 39.81L24.5514 39.74C23.3314 39.81 22.9514 39.3 21.9314 39.6L22.0914 39.39C21.5614 39.24 21.0014 39.57 20.4714 39.23L20.5114 39.33C20.3614 39.3 20.3114 39.25 20.1614 39.22L20.2114 39.28C19.8014 39.3 19.5614 39.25 19.1814 39.11C19.1714 39.04 19.3714 39.12 19.4914 39.12C19.3314 39.02 18.9914 39.11 18.6914 39.05C18.4714 38.94 18.7214 38.95 18.7514 38.92C17.8314 38.85 17.4714 38.52 16.7514 38.72C16.6814 38.76 16.9614 38.88 16.6314 38.84C17.2014 39.07 17.7214 39.05 18.2814 39.06L18.1314 39.03C18.6314 38.79 18.4414 39.17 19.1714 39.17C18.9614 39.26 18.6614 39.2 18.5214 39.25C19.2814 39.66 19.7114 39.27 20.1914 39.69L20.1314 39.68C20.2414 39.74 20.4714 39.71 20.6614 39.71C20.6014 39.66 20.4314 39.61 20.3114 39.56C20.5014 39.56 20.6214 39.43 20.6914 39.38C20.8714 39.56 20.9814 39.36 21.3014 39.48C21.3914 39.63 21.0014 39.56 20.8714 39.61L21.2814 39.58C21.6414 39.63 21.6214 39.78 21.7914 39.88C22.1114 39.82 21.6214 39.78 21.8914 39.67C22.2514 39.91 23.9414 40.08 24.7514 40.03C24.4714 40.02 24.6414 40.17 24.3114 40.11C24.4214 40.16 24.8614 40.13 24.8814 40.02C25.1114 40.01 25.3714 40.02 25.6314 40.06C25.8114 40.08 25.9914 40.13 26.2114 40.18L26.2614 40.01C26.2214 40.03 26.1914 40.03 26.1514 40.04C26.0614 39.78 26.1014 39.77 26.1414 39.43C26.1914 39.09 26.2114 38.78 26.2014 38.33L26.1914 38.35C26.2014 38.11 26.1914 37.51 26.8714 37.35C26.7314 37.51 26.4514 37.68 26.5614 37.76ZM29.4014 37.92L29.1114 37.96C29.3514 38.1 29.7414 38.06 29.7314 37.95C29.5414 37.9 29.3414 37.75 29.2814 37.81C29.3014 37.85 29.2814 37.89 29.4014 37.92ZM34.1814 39.9C34.2914 39.9 34.2814 39.84 34.3414 39.82C33.3214 39.42 32.0514 38.95 31.6914 38.68C31.3714 38.49 31.2214 38.67 30.7714 38.54L30.6414 38.32C30.3714 38.31 29.7314 37.87 29.8814 38.19C29.9014 38.22 30.1314 38.17 30.3114 38.3L30.2514 38.36L30.7114 38.52L30.5314 38.56C31.0914 38.95 31.0814 38.45 31.8114 38.86L31.7214 39.05C32.2314 39.28 32.5214 39.32 32.9214 39.62C32.9214 39.62 32.9614 39.53 32.8614 39.53C32.7814 39.48 32.7014 39.36 32.7814 39.33C33.6214 39.5 32.6214 39.39 33.1214 39.7C33.8314 39.84 35.1314 40.25 35.4314 40.56C35.1714 40.32 35.6814 40.38 36.0514 40.55C36.1914 40.69 35.8814 40.61 35.8014 40.65C35.9614 40.74 36.0814 40.85 36.2614 40.89C36.0914 40.69 36.2914 40.61 36.7214 40.71C35.8914 40.22 35.0514 40.29 34.1814 39.9ZM34.5114 39.84C34.4214 39.81 34.3714 39.81 34.3414 39.82C34.4614 39.87 34.5814 39.92 34.6914 39.97L34.5114 39.84Z" />\n<path fill-rule="evenodd" clip-rule="evenodd" d="M25.1414 24.89C24.3614 24.89 23.7214 24.68 23.2414 24.25C22.9414 24.02 22.7914 23.73 22.7914 23.4C22.7914 23.18 22.8214 23.05 22.8914 22.98C22.9514 22.9 23.1014 22.86 23.3314 22.86C23.5014 22.86 23.6514 22.92 23.7814 23.05C23.9514 23.22 24.1014 23.35 24.2514 23.46C24.4214 23.54 24.6314 23.59 24.8914 23.59C26.1814 23.59 26.8214 22.39 26.8214 20C26.8214 18.9 26.8114 18.08 26.7914 17.56C26.7714 17.03 26.7114 16.37 26.6014 15.59C26.3514 13.89 25.7814 12.5 24.8914 11.4C24.8514 11.42 24.7414 11.43 24.5714 11.43C24.3014 11.43 24.0614 11.38 23.8714 11.27C23.6814 11.17 23.5914 11.01 23.5914 10.8C23.5914 10.44 23.9414 9.91 24.6314 9.21C24.9114 8.91 25.1414 8.54 25.3314 8.1C25.5214 7.63 25.6214 7.18 25.6214 6.73C25.6214 5.86 25.5214 4.9 25.3314 3.84C25.2314 3.21 25.0514 2.69 24.7914 2.29C24.5614 1.89 24.2814 1.69 23.9714 1.69C23.7314 1.69 23.5214 1.77 23.3314 1.94C23.1614 2.11 23.0414 2.32 22.9514 2.57C22.8914 2.83 22.7614 3.05 22.5714 3.24C22.3814 3.41 22.1514 3.5 21.8714 3.5C21.6414 3.5 21.4314 3.42 21.2414 3.27C21.0714 3.1 20.9614 2.89 20.9214 2.64C21.2214 1.9 21.6314 1.31 22.1614 0.86C22.7114 0.42 23.3314 0.19 24.0314 0.19C24.5214 0.19 24.9614 0.35 25.3614 0.67C25.7714 0.97 26.0814 1.37 26.3214 1.88C26.5314 2.36 26.7114 2.93 26.8614 3.59C27.0014 4.23 27.1014 4.83 27.1414 5.4C27.1814 5.8 27.2014 6.38 27.2014 7.15C27.2014 7.44 27.1514 7.74 27.0514 8.03C26.9614 8.33 26.8714 8.56 26.7614 8.73C26.6514 8.96 26.4914 9.22 26.2514 9.49L25.7814 10.19C26.2614 10.49 26.7014 11 27.0814 11.72C27.4614 12.43 27.7414 13.27 27.9314 14.22C28.2714 16 28.4414 17.59 28.4414 18.98C28.4414 19.85 28.3914 20.7 28.2814 21.52C28.1414 22.41 27.8314 23.18 27.3614 23.84C26.9214 24.54 26.1814 24.89 25.1414 24.89ZM35.4914 24.79C34.4914 24.79 33.7514 24.15 33.2714 22.86C32.7614 21.59 32.4514 20.14 32.3514 18.51C32.2214 17.03 32.1614 15.4 32.1614 13.62V10.92C32.1614 3.64 33.3014 0 35.5814 0C35.7514 0 35.9114 0.0700001 36.0614 0.19C36.2314 0.32 36.3114 0.47 36.3114 0.64C36.3114 0.89 36.2014 1.13 35.9614 1.34C35.7314 1.53 35.4514 1.65 35.1114 1.72C34.8514 1.95 34.6114 2.64 34.3814 3.78C34.1714 4.9 34.0114 6.07 33.9014 7.27L33.7414 9.87C33.9514 9.83 34.1114 9.81 34.2214 9.81C34.7114 9.81 35.1514 9.97 35.5514 10.29C35.9514 10.6 36.2914 11.03 36.5714 11.56C37.0314 12.42 37.4114 13.74 37.7114 15.49C37.8814 16.85 37.9914 18.18 38.0314 19.49V20.92C38.0314 21.32 38.0214 21.7 38.0014 22.06C37.9814 22.4 37.9214 22.74 37.8414 23.08C37.7314 23.46 37.5914 23.77 37.4214 24C37.2614 24.23 37.0014 24.42 36.6614 24.57C36.3014 24.72 35.9114 24.79 35.4914 24.79ZM35.7414 23.43C36.2914 23.43 36.5714 22.71 36.5714 21.27C36.5714 20.02 36.4414 18.15 36.1914 15.65C36.0214 14.25 35.8014 13.16 35.5214 12.38C35.2014 11.49 34.8314 11 34.4114 10.89C34.1314 11.1 33.9414 11.33 33.8414 11.59C33.7514 11.84 33.7114 12.19 33.7114 12.64C33.7114 13.21 33.7214 13.67 33.7414 14.03L33.7714 15.21C33.8014 16.39 33.8714 17.59 34.0014 18.79C34.1014 19.91 34.3014 20.99 34.6014 22.03C34.8814 22.96 35.2614 23.43 35.7414 23.43ZM44.8214 24.47C42.2614 24.47 40.9814 18.53 40.9814 6.64V5.62C40.9814 4.03 41.1614 2.8 41.5214 1.91C41.6914 1.4 41.9514 1.02 42.3114 0.77C42.6914 0.49 43.1514 0.35 43.6814 0.35C46.7014 0.35 48.2214 5.74 48.2214 16.51C48.2214 21.82 47.0814 24.47 44.8214 24.47ZM45.1114 23.01C45.4414 23.01 45.7214 22.7 45.9314 22.06C46.2914 21.13 46.5414 19.58 46.6914 17.4C46.7414 16.93 46.7614 16.39 46.7614 15.78C46.7614 14.36 46.6914 12.48 46.5714 10.13C46.4214 7.91 46.0914 5.9 45.5814 4.1C45.3514 3.19 45.0314 2.47 44.6314 1.94C44.2514 1.41 43.8214 1.11 43.3314 1.05C43.0114 1.31 42.7914 1.57 42.6614 1.84C42.5614 2.12 42.5014 2.49 42.5014 2.96C42.5014 4.12 42.5214 5.16 42.5714 6.07L42.6314 9.24C42.6314 9.51 42.6814 10.02 42.7914 10.76C42.8914 11.55 42.9514 12.06 42.9514 12.32C42.9514 12.83 42.9814 13.99 43.0414 15.81C43.1314 17.55 43.3314 19.14 43.6514 20.6C43.7914 21.34 44.0014 21.94 44.2514 22.38C44.5014 22.8 44.7914 23.01 45.1114 23.01ZM56.0914 9.11C55.3914 9.11 54.7914 8.96 54.2814 8.67C53.7714 8.37 53.3914 7.97 53.1414 7.46C52.6914 6.57 52.4714 5.61 52.4714 4.57C52.4714 3.5 52.8014 2.61 53.4514 1.91C54.1114 1.21 54.9814 0.86 56.0614 0.86C56.7314 0.86 57.3514 0.95 57.9014 1.11C58.4714 1.26 58.9214 1.47 59.2614 1.75C59.5814 1.98 59.8414 2.27 60.0614 2.61C60.2714 2.94 60.4114 3.28 60.5014 3.62C60.5814 3.9 60.6314 4.2 60.6314 4.54C60.6314 5.26 60.4614 5.98 60.1214 6.7C59.8914 7.17 59.6114 7.57 59.2914 7.91C58.9814 8.22 58.5514 8.5 58.0214 8.73C57.4514 8.99 56.8114 9.11 56.0914 9.11ZM56.2114 7.91C56.7214 7.91 57.1914 7.82 57.6114 7.65C58.0314 7.48 58.3714 7.27 58.6314 7.02C58.8414 6.76 59.0214 6.49 59.1714 6.19C59.3414 5.88 59.4414 5.58 59.4814 5.3C59.5514 5.05 59.5814 4.82 59.5814 4.61C59.5814 4.03 59.3614 3.46 58.9114 2.89C58.7014 2.62 58.3514 2.38 57.8714 2.19C57.3614 2.02 56.8114 1.94 56.2114 1.94C55.6214 1.94 55.1114 2.13 54.6914 2.51C54.2714 2.87 53.9914 3.33 53.8714 3.88C53.7414 4.38 53.6814 4.96 53.6814 5.59C53.6814 5.91 53.7914 6.26 54.0214 6.64C54.2814 7 54.6014 7.3 54.9814 7.56C55.3814 7.79 55.7914 7.91 56.2114 7.91Z" />\n</symbol>'
        });
    it.a.add(Fe);

    function je(t) {
        return (je = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function He(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Ge(t, e) {
        return (Ge = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Ve(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Xe(t);
            if (e) {
                var r = Xe(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return We(this, n)
        }
    }

    function We(t, e) {
        return !e || "object" !== je(e) && "function" != typeof e ? qe(t) : e
    }

    function qe(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Xe(t) {
        return (Xe = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Ze = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Ge(t, e)
        }(o, t);
        var e, n, i, r = Ve(o);

        function o(t) {
            var e;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), (e = r.call(this, t)).onMouseDown = e.onMouseDown.bind(qe(e)), e.transitionIn = e.transitionIn.bind(qe(e)), e.transitionOut = e.transitionOut.bind(qe(e)), e.$text = e.$one("p"), e.$picto = e.$one("svg"), e
        }
        return e = o, (n = [{
            key: "transitionIn",
            value: function() {
                this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.set(this.$el, {
                    display: "block"
                }, 0), this.tl.fromTo(this.$text, {
                    alpha: 0,
                    display: "none"
                }, {
                    duration: 1,
                    alpha: 1,
                    display: "block"
                }, 0), this.tl.to(this.$text, {
                    alpha: 0,
                    duration: 1,
                    display: "none"
                }, 4), this.tl.fromTo(this.$picto, {
                    alpha: 0,
                    display: "none"
                }, {
                    duration: 1,
                    alpha: 1,
                    display: "block"
                }, 12), window.addEventListener("mousedown", this.onMouseDown)
            }
        }, {
            key: "transitionOut",
            value: function() {
                this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.to(this.$el, {
                    duration: 1,
                    alpha: 0,
                    display: "none"
                })
            }
        }, {
            key: "onMouseDown",
            value: function() {
                this.tl && this.tl.time() < 4 || (window.removeEventListener("mousedown", this.onMouseDown), this.transitionOut())
            }
        }]) && He(e.prototype, n), i && He(e, i), o
    }(s.a);
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }), void 0 === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function(t) {
        if (null == t) throw new TypeError("Cannot convert undefined or null to object");
        const e = Object(t);
        for (let t = 1; t < arguments.length; t++) {
            const n = arguments[t];
            if (null != n)
                for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t])
        }
        return e
    });
    const Ye = 0,
        $e = 1,
        Je = 2,
        Ke = 0,
        Qe = 1,
        tn = 2,
        en = 3;

    function nn() {}
    Object.assign(nn.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
                const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
            }
        },
        dispatchEvent: function(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
                t.target = this;
                const n = e.slice(0);
                for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
            }
        }
    });
    const rn = [];
    for (let t = 0; t < 256; t++) rn[t] = (t < 16 ? "0" : "") + t.toString(16);
    const on = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            const t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (rn[255 & t] + rn[t >> 8 & 255] + rn[t >> 16 & 255] + rn[t >> 24 & 255] + "-" + rn[255 & e] + rn[e >> 8 & 255] + "-" + rn[e >> 16 & 15 | 64] + rn[e >> 24 & 255] + "-" + rn[63 & n | 128] + rn[n >> 8 & 255] + "-" + rn[n >> 16 & 255] + rn[n >> 24 & 255] + rn[255 & i] + rn[i >> 8 & 255] + rn[i >> 16 & 255] + rn[i >> 24 & 255]).toUpperCase()
        },
        clamp: function(t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function(t, e) {
            return (t % e + e) % e
        },
        mapLinear: function(t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        lerp: function(t, e, n) {
            return (1 - n) * t + n * e
        },
        smoothstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        degToRad: function(t) {
            return t * on.DEG2RAD
        },
        radToDeg: function(t) {
            return t * on.RAD2DEG
        },
        isPowerOfTwo: function(t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        },
        setQuaternionFromProperEuler: function(t, e, n, i, r) {
            const o = Math.cos,
                s = Math.sin,
                a = o(n / 2),
                c = s(n / 2),
                l = o((e + i) / 2),
                u = s((e + i) / 2),
                h = o((e - i) / 2),
                p = s((e - i) / 2),
                f = o((i - e) / 2),
                d = s((i - e) / 2);
            switch (r) {
                case "XYX":
                    t.set(a * u, c * h, c * p, a * l);
                    break;
                case "YZY":
                    t.set(c * p, a * u, c * h, a * l);
                    break;
                case "ZXZ":
                    t.set(c * h, c * p, a * u, a * l);
                    break;
                case "XZX":
                    t.set(a * u, c * d, c * f, a * l);
                    break;
                case "YXY":
                    t.set(c * f, a * u, c * d, a * l);
                    break;
                case "ZYZ":
                    t.set(c * d, c * f, a * u, a * l);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
    };

    function sn(t = 0, e = 0) {
        this.x = t, this.y = e
    }

    function an() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    let cn;
    Object.defineProperties(sn.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }), Object.assign(sn.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t, this.y = e, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function(t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function(t) {
            const e = this.x,
                n = this.y,
                i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        },
        clampScalar: function(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
        },
        clampLength: function(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function(t) {
            return this.x * t.y - this.y * t.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            const e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
        },
        rotateAround: function(t, e) {
            const n = Math.cos(e),
                i = Math.sin(e),
                r = this.x - t.x,
                o = this.y - t.y;
            return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this
        },
        random: function() {
            return this.x = Math.random(), this.y = Math.random(), this
        }
    }), Object.assign(an.prototype, {
        isMatrix3: !0,
        set: function(t, e, n, i, r, o, s, a, c) {
            const l = this.elements;
            return l[0] = t, l[1] = i, l[2] = s, l[3] = e, l[4] = r, l[5] = a, l[6] = n, l[7] = o, l[8] = c, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            const e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
        },
        extractBasis: function(t, e, n) {
            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        },
        setFromMatrix4: function(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            const n = t.elements,
                i = e.elements,
                r = this.elements,
                o = n[0],
                s = n[3],
                a = n[6],
                c = n[1],
                l = n[4],
                u = n[7],
                h = n[2],
                p = n[5],
                f = n[8],
                d = i[0],
                m = i[3],
                g = i[6],
                v = i[1],
                y = i[4],
                b = i[7],
                x = i[2],
                w = i[5],
                _ = i[8];
            return r[0] = o * d + s * v + a * x, r[3] = o * m + s * y + a * w, r[6] = o * g + s * b + a * _, r[1] = c * d + l * v + u * x, r[4] = c * m + l * y + u * w, r[7] = c * g + l * b + u * _, r[2] = h * d + p * v + f * x, r[5] = h * m + p * y + f * w, r[8] = h * g + p * b + f * _, this
        },
        multiplyScalar: function(t) {
            const e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function() {
            const t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                r = t[3],
                o = t[4],
                s = t[5],
                a = t[6],
                c = t[7],
                l = t[8];
            return e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a
        },
        getInverse: function(t, e) {
            void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
            const n = t.elements,
                i = this.elements,
                r = n[0],
                o = n[1],
                s = n[2],
                a = n[3],
                c = n[4],
                l = n[5],
                u = n[6],
                h = n[7],
                p = n[8],
                f = p * c - l * h,
                d = l * u - p * a,
                m = h * a - c * u,
                g = r * f + o * d + s * m;
            if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const v = 1 / g;
            return i[0] = f * v, i[1] = (s * h - p * o) * v, i[2] = (l * o - s * c) * v, i[3] = d * v, i[4] = (p * r - s * u) * v, i[5] = (s * a - l * r) * v, i[6] = m * v, i[7] = (o * u - h * r) * v, i[8] = (c * r - o * a) * v, this
        },
        transpose: function() {
            let t;
            const e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            const e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        setUvTransform: function(t, e, n, i, r, o, s) {
            const a = Math.cos(r),
                c = Math.sin(r);
            this.set(n * a, n * c, -n * (a * o + c * s) + o + t, -i * c, i * a, -i * (-c * o + a * s) + s + e, 0, 0, 1)
        },
        scale: function(t, e) {
            const n = this.elements;
            return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
        },
        rotate: function(t) {
            const e = Math.cos(t),
                n = Math.sin(t),
                i = this.elements,
                r = i[0],
                o = i[3],
                s = i[6],
                a = i[1],
                c = i[4],
                l = i[7];
            return i[0] = e * r + n * a, i[3] = e * o + n * c, i[6] = e * s + n * l, i[1] = -n * r + e * a, i[4] = -n * o + e * c, i[7] = -n * s + e * l, this
        },
        translate: function(t, e) {
            const n = this.elements;
            return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
        },
        equals: function(t) {
            const e = this.elements,
                n = t.elements;
            for (let t = 0; t < 9; t++)
                if (e[t] !== n[t]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
        }
    });
    const ln = {
        getDataURL: function(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
                void 0 === cn && (cn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), cn.width = t.width, cn.height = t.height;
                const n = cn.getContext("2d");
                t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = cn
            }
            return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
        }
    };
    let un = 0;

    function hn(t, e, n, i, r, o, s, a, c, l) {
        Object.defineProperty(this, "id", {
            value: un++
        }), this.uuid = on.generateUUID(), this.name = "", this.image = void 0 !== t ? t : hn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : hn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== i ? i : 1001, this.magFilter = void 0 !== r ? r : 1006, this.minFilter = void 0 !== o ? o : 1008, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== s ? s : 1023, this.internalFormat = null, this.type = void 0 !== a ? a : 1009, this.offset = new sn(0, 0), this.repeat = new sn(1, 1), this.center = new sn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new an, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : 3e3, this.version = 0, this.onUpdate = null
    }

    function pn(t = 0, e = 0, n = 0, i = 1) {
        this.x = t, this.y = e, this.z = n, this.w = i
    }

    function fn(t, e, n) {
        this.width = t, this.height = e, this.scissor = new pn(0, 0, t, e), this.scissorTest = !1, this.viewport = new pn(0, 0, t, e), n = n || {}, this.texture = new hn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function dn(t, e, n) {
        fn.call(this, t, e, n), this.samples = 4
    }

    function mn(t = 0, e = 0, n = 0, i = 1) {
        this._x = t, this._y = e, this._z = n, this._w = i
    }
    hn.DEFAULT_IMAGE = void 0, hn.DEFAULT_MAPPING = 300, hn.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: hn,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
        },
        toJSON: function(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                const i = this.image;
                if (void 0 === i.uuid && (i.uuid = on.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++) e.push(ln.getDataURL(i[t]))
                    } else e = ln.getDataURL(i);
                    t.images[i.uuid] = {
                        uuid: i.uuid,
                        url: e
                    }
                }
                n.image = i.uuid
            }
            return e || (t.textures[this.uuid] = n), n
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (300 !== this.mapping) return t;
            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                case 1e3:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case 1001:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
            }
            if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                case 1e3:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case 1001:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
            }
            return this.flipY && (t.y = 1 - t.y), t
        }
    }), Object.defineProperty(hn.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.defineProperties(pn.prototype, {
        width: {
            get: function() {
                return this.z
            },
            set: function(t) {
                this.z = t
            }
        },
        height: {
            get: function() {
                return this.w
            },
            set: function(t) {
                this.w = t
            }
        }
    }), Object.assign(pn.prototype, {
        isVector4: !0,
        set: function(t, e, n, i) {
            return this.x = t, this.y = e, this.z = n, this.w = i, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setW: function(t) {
            return this.w = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        },
        applyMatrix4: function(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = this.w,
                o = t.elements;
            return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            let e, n, i, r;
            const o = t.elements,
                s = o[0],
                a = o[4],
                c = o[8],
                l = o[1],
                u = o[5],
                h = o[9],
                p = o[2],
                f = o[6],
                d = o[10];
            if (Math.abs(a - l) < .01 && Math.abs(c - p) < .01 && Math.abs(h - f) < .01) {
                if (Math.abs(a + l) < .1 && Math.abs(c + p) < .1 && Math.abs(h + f) < .1 && Math.abs(s + u + d - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                const t = (s + 1) / 2,
                    o = (u + 1) / 2,
                    m = (d + 1) / 2,
                    g = (a + l) / 4,
                    v = (c + p) / 4,
                    y = (h + f) / 4;
                return t > o && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = g / n, r = v / n) : o > m ? o < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = g / i, r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(m), n = v / r, i = y / r), this.set(n, i, r, e), this
            }
            let m = Math.sqrt((f - h) * (f - h) + (c - p) * (c - p) + (l - a) * (l - a));
            return Math.abs(m) < .001 && (m = 1), this.x = (f - h) / m, this.y = (c - p) / m, this.z = (l - a) / m, this.w = Math.acos((s + u + d - 1) / 2), this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        },
        clampScalar: function(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
        },
        clampLength: function(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        },
        random: function() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }
    }), fn.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: fn,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), dn.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: dn,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(t) {
            return fn.prototype.copy.call(this, t), this.samples = t.samples, this
        }
    }), Object.assign(mn, {
        slerp: function(t, e, n, i) {
            return n.copy(t).slerp(e, i)
        },
        slerpFlat: function(t, e, n, i, r, o, s) {
            let a = n[i + 0],
                c = n[i + 1],
                l = n[i + 2],
                u = n[i + 3];
            const h = r[o + 0],
                p = r[o + 1],
                f = r[o + 2],
                d = r[o + 3];
            if (u !== d || a !== h || c !== p || l !== f) {
                let t = 1 - s,
                    e = a * h + c * p + l * f + u * d,
                    n = e >= 0 ? 1 : -1,
                    i = 1 - e * e;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i),
                        o = Math.atan2(r, e * n);
                    t = Math.sin(t * o) / r, s = Math.sin(s * o) / r
                }
                const r = s * n;
                if (a = a * t + h * r, c = c * t + p * r, l = l * t + f * r, u = u * t + d * r, t === 1 - s) {
                    const t = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
                    a *= t, c *= t, l *= t, u *= t
                }
            }
            t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u
        },
        multiplyQuaternionsFlat: function(t, e, n, i, r, o) {
            const s = n[i],
                a = n[i + 1],
                c = n[i + 2],
                l = n[i + 3],
                u = r[o],
                h = r[o + 1],
                p = r[o + 2],
                f = r[o + 3];
            return t[e] = s * f + l * u + a * p - c * h, t[e + 1] = a * f + l * h + c * u - s * p, t[e + 2] = c * f + l * p + s * h - a * u, t[e + 3] = l * f - s * u - a * h - c * p, t
        }
    }), Object.defineProperties(mn.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this._onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t, this._onChangeCallback()
            }
        }
    }), Object.assign(mn.prototype, {
        isQuaternion: !0,
        set: function(t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const n = t._x,
                i = t._y,
                r = t._z,
                o = t.order,
                s = Math.cos,
                a = Math.sin,
                c = s(n / 2),
                l = s(i / 2),
                u = s(r / 2),
                h = a(n / 2),
                p = a(i / 2),
                f = a(r / 2);
            switch (o) {
                case "XYZ":
                    this._x = h * l * u + c * p * f, this._y = c * p * u - h * l * f, this._z = c * l * f + h * p * u, this._w = c * l * u - h * p * f;
                    break;
                case "YXZ":
                    this._x = h * l * u + c * p * f, this._y = c * p * u - h * l * f, this._z = c * l * f - h * p * u, this._w = c * l * u + h * p * f;
                    break;
                case "ZXY":
                    this._x = h * l * u - c * p * f, this._y = c * p * u + h * l * f, this._z = c * l * f + h * p * u, this._w = c * l * u - h * p * f;
                    break;
                case "ZYX":
                    this._x = h * l * u - c * p * f, this._y = c * p * u + h * l * f, this._z = c * l * f - h * p * u, this._w = c * l * u + h * p * f;
                    break;
                case "YZX":
                    this._x = h * l * u + c * p * f, this._y = c * p * u + h * l * f, this._z = c * l * f - h * p * u, this._w = c * l * u - h * p * f;
                    break;
                case "XZY":
                    this._x = h * l * u - c * p * f, this._y = c * p * u - h * l * f, this._z = c * l * f + h * p * u, this._w = c * l * u + h * p * f;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
            }
            return !1 !== e && this._onChangeCallback(), this
        },
        setFromAxisAngle: function(t, e) {
            const n = e / 2,
                i = Math.sin(n);
            return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        },
        setFromRotationMatrix: function(t) {
            const e = t.elements,
                n = e[0],
                i = e[4],
                r = e[8],
                o = e[1],
                s = e[5],
                a = e[9],
                c = e[2],
                l = e[6],
                u = e[10],
                h = n + s + u;
            if (h > 0) {
                const t = .5 / Math.sqrt(h + 1);
                this._w = .25 / t, this._x = (l - a) * t, this._y = (r - c) * t, this._z = (o - i) * t
            } else if (n > s && n > u) {
                const t = 2 * Math.sqrt(1 + n - s - u);
                this._w = (l - a) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (r + c) / t
            } else if (s > u) {
                const t = 2 * Math.sqrt(1 + s - n - u);
                this._w = (r - c) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (a + l) / t
            } else {
                const t = 2 * Math.sqrt(1 + u - n - s);
                this._w = (o - i) / t, this._x = (r + c) / t, this._y = (a + l) / t, this._z = .25 * t
            }
            return this._onChangeCallback(), this
        },
        setFromUnitVectors: function(t, e) {
            let n = t.dot(e) + 1;
            return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
        },
        angleTo: function(t) {
            return 2 * Math.acos(Math.abs(on.clamp(this.dot(t), -1, 1)))
        },
        rotateTowards: function(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            let t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            const n = t._x,
                i = t._y,
                r = t._z,
                o = t._w,
                s = e._x,
                a = e._y,
                c = e._z,
                l = e._w;
            return this._x = n * l + o * s + i * c - r * a, this._y = i * l + o * a + r * s - n * c, this._z = r * l + o * c + n * a - i * s, this._w = o * l - n * s - i * a - r * c, this._onChangeCallback(), this
        },
        slerp: function(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
                i = this._y,
                r = this._z,
                o = this._w;
            let s = o * t._w + n * t._x + i * t._y + r * t._z;
            if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
            const a = 1 - s * s;
            if (a <= Number.EPSILON) {
                const t = 1 - e;
                return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
            }
            const c = Math.sqrt(a),
                l = Math.atan2(c, s),
                u = Math.sin((1 - e) * l) / c,
                h = Math.sin(e * l) / c;
            return this._w = o * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        },
        fromBufferAttribute: function(t, e) {
            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
        },
        _onChange: function(t) {
            return this._onChangeCallback = t, this
        },
        _onChangeCallback: function() {}
    });
    const gn = new yn,
        vn = new mn;

    function yn(t = 0, e = 0, n = 0) {
        this.x = t, this.y = e, this.z = n
    }
    Object.assign(yn.prototype, {
        isVector3: !0,
        set: function(t, e, n) {
            return this.x = t, this.y = e, this.z = n, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: function(t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(vn.setFromEuler(t))
        },
        applyAxisAngle: function(t, e) {
            return this.applyQuaternion(vn.setFromAxisAngle(t, e))
        },
        applyMatrix3: function(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
        },
        applyNormalMatrix: function(t) {
            return this.applyMatrix3(t).normalize()
        },
        applyMatrix4: function(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements,
                o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this
        },
        applyQuaternion: function(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.x,
                o = t.y,
                s = t.z,
                a = t.w,
                c = a * e + o * i - s * n,
                l = a * n + s * e - r * i,
                u = a * i + r * n - o * e,
                h = -r * e - o * n - s * i;
            return this.x = c * a + h * -r + l * -s - u * -o, this.y = l * a + h * -o + u * -r - c * -s, this.z = u * a + h * -s + c * -o - l * -r, this
        },
        project: function(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        },
        unproject: function(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        },
        transformDirection: function(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        },
        clampScalar: function(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
        },
        clampLength: function(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
        },
        cross: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
        },
        crossVectors: function(t, e) {
            const n = t.x,
                i = t.y,
                r = t.z,
                o = e.x,
                s = e.y,
                a = e.z;
            return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this
        },
        projectOnVector: function(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        },
        projectOnPlane: function(t) {
            return gn.copy(this).projectOnVector(t), this.sub(gn)
        },
        reflect: function(t) {
            return this.sub(gn.copy(t).multiplyScalar(2 * this.dot(t)))
        },
        angleTo: function(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(on.clamp(n, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            const e = this.x - t.x,
                n = this.y - t.y,
                i = this.z - t.z;
            return e * e + n * n + i * i
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        },
        setFromSphericalCoords: function(t, e, n) {
            const i = Math.sin(e) * t;
            return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
        },
        setFromCylindrical: function(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        },
        setFromCylindricalCoords: function(t, e, n) {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
        },
        setFromMatrixPosition: function(t) {
            const e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
                n = this.setFromMatrixColumn(t, 1).length(),
                i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = i, this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        setFromMatrix3Column: function(t, e) {
            return this.fromArray(t.elements, 3 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        },
        random: function() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
    });
    const bn = new yn,
        xn = new En,
        wn = new yn(0, 0, 0),
        _n = new yn(1, 1, 1),
        Mn = new yn,
        Sn = new yn,
        Tn = new yn;

    function En() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(En.prototype, {
        isMatrix4: !0,
        set: function(t, e, n, i, r, o, s, a, c, l, u, h, p, f, d, m) {
            const g = this.elements;
            return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = p, g[7] = f, g[11] = d, g[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new En).fromArray(this.elements)
        },
        copy: function(t) {
            const e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
        },
        copyPosition: function(t) {
            const e = this.elements,
                n = t.elements;
            return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
        },
        extractBasis: function(t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function(t) {
            const e = this.elements,
                n = t.elements,
                i = 1 / bn.setFromMatrixColumn(t, 0).length(),
                r = 1 / bn.setFromMatrixColumn(t, 1).length(),
                o = 1 / bn.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromEuler: function(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z,
                o = Math.cos(n),
                s = Math.sin(n),
                a = Math.cos(i),
                c = Math.sin(i),
                l = Math.cos(r),
                u = Math.sin(r);
            if ("XYZ" === t.order) {
                const t = o * l,
                    n = o * u,
                    i = s * l,
                    r = s * u;
                e[0] = a * l, e[4] = -a * u, e[8] = c, e[1] = n + i * c, e[5] = t - r * c, e[9] = -s * a, e[2] = r - t * c, e[6] = i + n * c, e[10] = o * a
            } else if ("YXZ" === t.order) {
                const t = a * l,
                    n = a * u,
                    i = c * l,
                    r = c * u;
                e[0] = t + r * s, e[4] = i * s - n, e[8] = o * c, e[1] = o * u, e[5] = o * l, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = o * a
            } else if ("ZXY" === t.order) {
                const t = a * l,
                    n = a * u,
                    i = c * l,
                    r = c * u;
                e[0] = t - r * s, e[4] = -o * u, e[8] = i + n * s, e[1] = n + i * s, e[5] = o * l, e[9] = r - t * s, e[2] = -o * c, e[6] = s, e[10] = o * a
            } else if ("ZYX" === t.order) {
                const t = o * l,
                    n = o * u,
                    i = s * l,
                    r = s * u;
                e[0] = a * l, e[4] = i * c - n, e[8] = t * c + r, e[1] = a * u, e[5] = r * c + t, e[9] = n * c - i, e[2] = -c, e[6] = s * a, e[10] = o * a
            } else if ("YZX" === t.order) {
                const t = o * a,
                    n = o * c,
                    i = s * a,
                    r = s * c;
                e[0] = a * l, e[4] = r - t * u, e[8] = i * u + n, e[1] = u, e[5] = o * l, e[9] = -s * l, e[2] = -c * l, e[6] = n * u + i, e[10] = t - r * u
            } else if ("XZY" === t.order) {
                const t = o * a,
                    n = o * c,
                    i = s * a,
                    r = s * c;
                e[0] = a * l, e[4] = -u, e[8] = c * l, e[1] = t * u + r, e[5] = o * l, e[9] = n * u - i, e[2] = i * u - n, e[6] = s * l, e[10] = r * u + t
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromQuaternion: function(t) {
            return this.compose(wn, t, _n)
        },
        lookAt: function(t, e, n) {
            const i = this.elements;
            return Tn.subVectors(t, e), 0 === Tn.lengthSq() && (Tn.z = 1), Tn.normalize(), Mn.crossVectors(n, Tn), 0 === Mn.lengthSq() && (1 === Math.abs(n.z) ? Tn.x += 1e-4 : Tn.z += 1e-4, Tn.normalize(), Mn.crossVectors(n, Tn)), Mn.normalize(), Sn.crossVectors(Tn, Mn), i[0] = Mn.x, i[4] = Sn.x, i[8] = Tn.x, i[1] = Mn.y, i[5] = Sn.y, i[9] = Tn.y, i[2] = Mn.z, i[6] = Sn.z, i[10] = Tn.z, this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            const n = t.elements,
                i = e.elements,
                r = this.elements,
                o = n[0],
                s = n[4],
                a = n[8],
                c = n[12],
                l = n[1],
                u = n[5],
                h = n[9],
                p = n[13],
                f = n[2],
                d = n[6],
                m = n[10],
                g = n[14],
                v = n[3],
                y = n[7],
                b = n[11],
                x = n[15],
                w = i[0],
                _ = i[4],
                M = i[8],
                S = i[12],
                T = i[1],
                E = i[5],
                C = i[9],
                A = i[13],
                L = i[2],
                P = i[6],
                O = i[10],
                R = i[14],
                I = i[3],
                D = i[7],
                N = i[11],
                k = i[15];
            return r[0] = o * w + s * T + a * L + c * I, r[4] = o * _ + s * E + a * P + c * D, r[8] = o * M + s * C + a * O + c * N, r[12] = o * S + s * A + a * R + c * k, r[1] = l * w + u * T + h * L + p * I, r[5] = l * _ + u * E + h * P + p * D, r[9] = l * M + u * C + h * O + p * N, r[13] = l * S + u * A + h * R + p * k, r[2] = f * w + d * T + m * L + g * I, r[6] = f * _ + d * E + m * P + g * D, r[10] = f * M + d * C + m * O + g * N, r[14] = f * S + d * A + m * R + g * k, r[3] = v * w + y * T + b * L + x * I, r[7] = v * _ + y * E + b * P + x * D, r[11] = v * M + y * C + b * O + x * N, r[15] = v * S + y * A + b * R + x * k, this
        },
        multiplyScalar: function(t) {
            const e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        determinant: function() {
            const t = this.elements,
                e = t[0],
                n = t[4],
                i = t[8],
                r = t[12],
                o = t[1],
                s = t[5],
                a = t[9],
                c = t[13],
                l = t[2],
                u = t[6],
                h = t[10],
                p = t[14];
            return t[3] * (+r * a * u - i * c * u - r * s * h + n * c * h + i * s * p - n * a * p) + t[7] * (+e * a * p - e * c * h + r * o * h - i * o * p + i * c * l - r * a * l) + t[11] * (+e * c * u - e * s * p - r * o * u + n * o * p + r * s * l - n * c * l) + t[15] * (-i * s * l - e * a * u + e * s * h + i * o * u - n * o * h + n * a * l)
        },
        transpose: function() {
            const t = this.elements;
            let e;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        },
        setPosition: function(t, e, n) {
            const i = this.elements;
            return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
        },
        getInverse: function(t, e) {
            void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
            const n = this.elements,
                i = t.elements,
                r = i[0],
                o = i[1],
                s = i[2],
                a = i[3],
                c = i[4],
                l = i[5],
                u = i[6],
                h = i[7],
                p = i[8],
                f = i[9],
                d = i[10],
                m = i[11],
                g = i[12],
                v = i[13],
                y = i[14],
                b = i[15],
                x = f * y * h - v * d * h + v * u * m - l * y * m - f * u * b + l * d * b,
                w = g * d * h - p * y * h - g * u * m + c * y * m + p * u * b - c * d * b,
                _ = p * v * h - g * f * h + g * l * m - c * v * m - p * l * b + c * f * b,
                M = g * f * u - p * v * u - g * l * d + c * v * d + p * l * y - c * f * y,
                S = r * x + o * w + s * _ + a * M;
            if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const T = 1 / S;
            return n[0] = x * T, n[1] = (v * d * a - f * y * a - v * s * m + o * y * m + f * s * b - o * d * b) * T, n[2] = (l * y * a - v * u * a + v * s * h - o * y * h - l * s * b + o * u * b) * T, n[3] = (f * u * a - l * d * a - f * s * h + o * d * h + l * s * m - o * u * m) * T, n[4] = w * T, n[5] = (p * y * a - g * d * a + g * s * m - r * y * m - p * s * b + r * d * b) * T, n[6] = (g * u * a - c * y * a - g * s * h + r * y * h + c * s * b - r * u * b) * T, n[7] = (c * d * a - p * u * a + p * s * h - r * d * h - c * s * m + r * u * m) * T, n[8] = _ * T, n[9] = (g * f * a - p * v * a - g * o * m + r * v * m + p * o * b - r * f * b) * T, n[10] = (c * v * a - g * l * a + g * o * h - r * v * h - c * o * b + r * l * b) * T, n[11] = (p * l * a - c * f * a - p * o * h + r * f * h + c * o * m - r * l * m) * T, n[12] = M * T, n[13] = (p * v * s - g * f * s + g * o * d - r * v * d - p * o * y + r * f * y) * T, n[14] = (g * l * s - c * v * s - g * o * u + r * v * u + c * o * y - r * l * y) * T, n[15] = (c * f * s - p * l * s + p * o * u - r * f * u - c * o * d + r * l * d) * T, this
        },
        scale: function(t) {
            const e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z;
            return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
        },
        getMaxScaleOnAxis: function() {
            const t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        },
        makeTranslation: function(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(t, e) {
            const n = Math.cos(e),
                i = Math.sin(e),
                r = 1 - n,
                o = t.x,
                s = t.y,
                a = t.z,
                c = r * o,
                l = r * s;
            return this.set(c * o + n, c * s - i * a, c * a + i * s, 0, c * s + i * a, l * s + n, l * a - i * o, 0, c * a - i * s, l * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        makeShear: function(t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(t, e, n) {
            const i = this.elements,
                r = e._x,
                o = e._y,
                s = e._z,
                a = e._w,
                c = r + r,
                l = o + o,
                u = s + s,
                h = r * c,
                p = r * l,
                f = r * u,
                d = o * l,
                m = o * u,
                g = s * u,
                v = a * c,
                y = a * l,
                b = a * u,
                x = n.x,
                w = n.y,
                _ = n.z;
            return i[0] = (1 - (d + g)) * x, i[1] = (p + b) * x, i[2] = (f - y) * x, i[3] = 0, i[4] = (p - b) * w, i[5] = (1 - (h + g)) * w, i[6] = (m + v) * w, i[7] = 0, i[8] = (f + y) * _, i[9] = (m - v) * _, i[10] = (1 - (h + d)) * _, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
        },
        decompose: function(t, e, n) {
            const i = this.elements;
            let r = bn.set(i[0], i[1], i[2]).length(),
                o = bn.set(i[4], i[5], i[6]).length(),
                s = bn.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], xn.copy(this);
            const a = 1 / r,
                c = 1 / o,
                l = 1 / s;
            return xn.elements[0] *= a, xn.elements[1] *= a, xn.elements[2] *= a, xn.elements[4] *= c, xn.elements[5] *= c, xn.elements[6] *= c, xn.elements[8] *= l, xn.elements[9] *= l, xn.elements[10] *= l, e.setFromRotationMatrix(xn), n.x = r, n.y = o, n.z = s, this
        },
        makePerspective: function(t, e, n, i, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const s = this.elements,
                a = 2 * r / (e - t),
                c = 2 * r / (n - i),
                l = (e + t) / (e - t),
                u = (n + i) / (n - i),
                h = -(o + r) / (o - r),
                p = -2 * o * r / (o - r);
            return s[0] = a, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = c, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
        },
        makeOrthographic: function(t, e, n, i, r, o) {
            const s = this.elements,
                a = 1 / (e - t),
                c = 1 / (n - i),
                l = 1 / (o - r),
                u = (e + t) * a,
                h = (n + i) * c,
                p = (o + r) * l;
            return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
        },
        equals: function(t) {
            const e = this.elements,
                n = t.elements;
            for (let t = 0; t < 16; t++)
                if (e[t] !== n[t]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
        }
    });
    const Cn = new En,
        An = new mn;

    function Ln(t = 0, e = 0, n = 0, i = Ln.DefaultOrder) {
        this._x = t, this._y = e, this._z = n, this._order = i
    }

    function Pn() {
        this.mask = 1
    }
    Ln.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Ln.DefaultOrder = "XYZ", Object.defineProperties(Ln.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this._onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t, this._onChangeCallback()
            }
        }
    }), Object.assign(Ln.prototype, {
        isEuler: !0,
        set: function(t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
        },
        setFromRotationMatrix: function(t, e, n) {
            const i = on.clamp,
                r = t.elements,
                o = r[0],
                s = r[4],
                a = r[8],
                c = r[1],
                l = r[5],
                u = r[9],
                h = r[2],
                p = r[6],
                f = r[10];
            switch (e = e || this._order) {
                case "XYZ":
                    this._y = Math.asin(i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(p, l), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(i(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(c, o));
                    break;
                case "ZYX":
                    this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-s, l));
                    break;
                case "YZX":
                    this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(a, f));
                    break;
                case "XZY":
                    this._z = Math.asin(-i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-u, f), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
            }
            return this._order = e, !1 !== n && this._onChangeCallback(), this
        },
        setFromQuaternion: function(t, e, n) {
            return Cn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Cn, e, n)
        },
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function(t) {
            return An.setFromEuler(this), this.setFromQuaternion(An, t)
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new yn(this._x, this._y, this._z)
        },
        _onChange: function(t) {
            return this._onChangeCallback = t, this
        },
        _onChangeCallback: function() {}
    }), Object.assign(Pn.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask |= 1 << t | 0
        },
        enableAll: function() {
            this.mask = -1
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        disableAll: function() {
            this.mask = 0
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    let On = 0;
    const Rn = new yn,
        In = new mn,
        Dn = new En,
        Nn = new yn,
        kn = new yn,
        Un = new yn,
        Bn = new mn,
        zn = new yn(1, 0, 0),
        Fn = new yn(0, 1, 0),
        jn = new yn(0, 0, 1),
        Hn = {
            type: "added"
        },
        Gn = {
            type: "removed"
        };

    function Vn() {
        Object.defineProperty(this, "id", {
            value: On++
        }), this.uuid = on.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Vn.DefaultUp.clone();
        const t = new yn,
            e = new Ln,
            n = new mn,
            i = new yn(1, 1, 1);
        e._onChange((function() {
            n.setFromEuler(e, !1)
        })), n._onChange((function() {
            e.setFromQuaternion(n, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new En
            },
            normalMatrix: {
                value: new an
            }
        }), this.matrix = new En, this.matrixWorld = new En, this.matrixAutoUpdate = Vn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Pn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function Wn() {
        Vn.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    Vn.DefaultUp = new yn(0, 1, 0), Vn.DefaultMatrixAutoUpdate = !0, Vn.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: Vn,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix4: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t), this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function(t, e) {
            return In.setFromAxisAngle(t, e), this.quaternion.multiply(In), this
        },
        rotateOnWorldAxis: function(t, e) {
            return In.setFromAxisAngle(t, e), this.quaternion.premultiply(In), this
        },
        rotateX: function(t) {
            return this.rotateOnAxis(zn, t)
        },
        rotateY: function(t) {
            return this.rotateOnAxis(Fn, t)
        },
        rotateZ: function(t) {
            return this.rotateOnAxis(jn, t)
        },
        translateOnAxis: function(t, e) {
            return Rn.copy(t).applyQuaternion(this.quaternion), this.position.add(Rn.multiplyScalar(e)), this
        },
        translateX: function(t) {
            return this.translateOnAxis(zn, t)
        },
        translateY: function(t) {
            return this.translateOnAxis(Fn, t)
        },
        translateZ: function(t) {
            return this.translateOnAxis(jn, t)
        },
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(t) {
            return t.applyMatrix4(Dn.getInverse(this.matrixWorld))
        },
        lookAt: function(t, e, n) {
            t.isVector3 ? Nn.copy(t) : Nn.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), kn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Dn.lookAt(kn, Nn, this.up) : Dn.lookAt(Nn, kn, this.up), this.quaternion.setFromRotationMatrix(Dn), i && (Dn.extractRotation(i.matrixWorld), In.setFromRotationMatrix(Dn), this.quaternion.premultiply(In.inverse()))
        },
        add: function(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Hn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        },
        remove: function(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            const e = this.children.indexOf(t);
            return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Gn)), this
        },
        attach: function(t) {
            return this.updateWorldMatrix(!0, !1), Dn.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Dn.multiply(t.parent.matrixWorld)), t.applyMatrix4(Dn), t.updateWorldMatrix(!1, !1), this.add(t), this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i) return i
            }
        },
        getWorldPosition: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new yn), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new mn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(kn, t, Un), t
        },
        getWorldScale: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new yn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(kn, Bn, t), t
        },
        getWorldDirection: function(t) {
            void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new yn), this.updateMatrixWorld(!0);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        },
        raycast: function() {},
        traverse: function(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
        },
        traverseAncestors: function(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
        },
        updateWorldMatrix: function(t, e) {
            const n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                const t = this.children;
                for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
            }
        },
        toJSON: function(t) {
            const e = void 0 === t || "string" == typeof t,
                n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};

            function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
            }
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(t.geometries, this.geometry);
                const e = this.geometry.parameters;
                if (void 0 !== e && void 0 !== e.shapes) {
                    const n = e.shapes;
                    if (Array.isArray(n))
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            r(t.shapes, i)
                        } else r(t.shapes, n)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const e = [];
                    for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                    i.material = e
                } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
            }
            if (e) {
                const e = o(t.geometries),
                    i = o(t.materials),
                    r = o(t.textures),
                    s = o(t.images),
                    a = o(t.shapes);
                e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a)
            }
            return n.object = i, n;

            function o(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (let e = 0; e < t.children.length; e++) {
                    const n = t.children[e];
                    this.add(n.clone())
                }
            return this
        }
    }), Wn.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: Wn,
        isScene: !0,
        copy: function(t, e) {
            return Vn.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        },
        toJSON: function(t) {
            const e = Vn.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    const qn = [new yn, new yn, new yn, new yn, new yn, new yn, new yn, new yn],
        Xn = new yn,
        Zn = new oi,
        Yn = new yn,
        $n = new yn,
        Jn = new yn,
        Kn = new yn,
        Qn = new yn,
        ti = new yn,
        ei = new yn,
        ni = new yn,
        ii = new yn,
        ri = new yn;

    function oi(t, e) {
        this.min = void 0 !== t ? t : new yn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new yn(-1 / 0, -1 / 0, -1 / 0)
    }

    function si(t, e, n, i, r) {
        for (let o = 0, s = t.length - 3; o <= s; o += 3) {
            ri.fromArray(t, o);
            const s = r.x * Math.abs(ri.x) + r.y * Math.abs(ri.y) + r.z * Math.abs(ri.z),
                a = e.dot(ri),
                c = n.dot(ri),
                l = i.dot(ri);
            if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1
        }
        return !0
    }
    Object.assign(oi.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromArray: function(t) {
            let e = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -1 / 0,
                o = -1 / 0,
                s = -1 / 0;
            for (let a = 0, c = t.length; a < c; a += 3) {
                const c = t[a],
                    l = t[a + 1],
                    u = t[a + 2];
                c < e && (e = c), l < n && (n = l), u < i && (i = u), c > r && (r = c), l > o && (o = l), u > s && (s = u)
            }
            return this.min.set(e, n, i), this.max.set(r, o, s), this
        },
        setFromBufferAttribute: function(t) {
            let e = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -1 / 0,
                o = -1 / 0,
                s = -1 / 0;
            for (let a = 0, c = t.count; a < c; a++) {
                const c = t.getX(a),
                    l = t.getY(a),
                    u = t.getZ(a);
                c < e && (e = c), l < n && (n = l), u < i && (i = u), c > r && (r = c), l > o && (o = l), u > s && (s = u)
            }
            return this.min.set(e, n, i), this.max.set(r, o, s), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function(t, e) {
            const n = Xn.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        },
        setFromObject: function(t) {
            return this.makeEmpty(), this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new yn), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new yn), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        expandByObject: function(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Zn.copy(e.boundingBox), Zn.applyMatrix4(t.matrixWorld), this.union(Zn));
            const n = t.children;
            for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
            return this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new yn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function(t) {
            return this.clampPoint(t.center, Xn), Xn.distanceToSquared(t.center) <= t.radius * t.radius
        },
        intersectsPlane: function(t) {
            let e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
        },
        intersectsTriangle: function(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(ei), ni.subVectors(this.max, ei), Yn.subVectors(t.a, ei), $n.subVectors(t.b, ei), Jn.subVectors(t.c, ei), Kn.subVectors($n, Yn), Qn.subVectors(Jn, $n), ti.subVectors(Yn, Jn);
            let e = [0, -Kn.z, Kn.y, 0, -Qn.z, Qn.y, 0, -ti.z, ti.y, Kn.z, 0, -Kn.x, Qn.z, 0, -Qn.x, ti.z, 0, -ti.x, -Kn.y, Kn.x, 0, -Qn.y, Qn.x, 0, -ti.y, ti.x, 0];
            return !!si(e, Yn, $n, Jn, ni) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!si(e, Yn, $n, Jn, ni) && (ii.crossVectors(Kn, Qn), e = [ii.x, ii.y, ii.z], si(e, Yn, $n, Jn, ni)))
        },
        clampPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new yn), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function(t) {
            return Xn.copy(t).clamp(this.min, this.max).sub(t).length()
        },
        getBoundingSphere: function(t) {
            return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(Xn).length(), t
        },
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: function(t) {
            return this.isEmpty() || (qn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), qn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), qn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), qn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), qn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), qn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), qn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), qn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(qn)), this
        },
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    });
    const ai = new oi;

    function ci(t, e) {
        this.center = void 0 !== t ? t : new yn, this.radius = void 0 !== e ? e : -1
    }
    Object.assign(ci.prototype, {
        set: function(t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: function(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : ai.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
            return this.radius = Math.sqrt(i), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        isEmpty: function() {
            return this.radius < 0
        },
        makeEmpty: function() {
            return this.center.set(0, 0, 0), this.radius = -1, this
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            const n = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new yn), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
        },
        getBoundingBox: function(t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new oi), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        },
        translate: function(t) {
            return this.center.add(t), this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    });
    const li = new yn,
        ui = new yn,
        hi = new yn,
        pi = new yn,
        fi = new yn,
        di = new yn,
        mi = new yn;

    function gi(t, e) {
        this.origin = void 0 !== t ? t : new yn, this.direction = void 0 !== e ? e : new yn(0, 0, -1)
    }
    Object.assign(gi.prototype, {
        set: function(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function(t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new yn), e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        },
        recast: function(t) {
            return this.origin.copy(this.at(t, li)), this
        },
        closestPointToPoint: function(t, e) {
            void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new yn), e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function(t) {
            const e = li.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (li.copy(this.direction).multiplyScalar(e).add(this.origin), li.distanceToSquared(t))
        },
        distanceSqToSegment: function(t, e, n, i) {
            ui.copy(t).add(e).multiplyScalar(.5), hi.copy(e).sub(t).normalize(), pi.copy(this.origin).sub(ui);
            const r = .5 * t.distanceTo(e),
                o = -this.direction.dot(hi),
                s = pi.dot(this.direction),
                a = -pi.dot(hi),
                c = pi.lengthSq(),
                l = Math.abs(1 - o * o);
            let u, h, p, f;
            if (l > 0)
                if (u = o * a - s, h = o * s - a, f = r * l, u >= 0)
                    if (h >= -f)
                        if (h <= f) {
                            const t = 1 / l;
                            u *= t, h *= t, p = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + c
                        } else h = r, u = Math.max(0, -(o * h + s)), p = -u * u + h * (h + 2 * a) + c;
            else h = -r, u = Math.max(0, -(o * h + s)), p = -u * u + h * (h + 2 * a) + c;
            else h <= -f ? (u = Math.max(0, -(-o * r + s)), h = u > 0 ? -r : Math.min(Math.max(-r, -a), r), p = -u * u + h * (h + 2 * a) + c) : h <= f ? (u = 0, h = Math.min(Math.max(-r, -a), r), p = h * (h + 2 * a) + c) : (u = Math.max(0, -(o * r + s)), h = u > 0 ? r : Math.min(Math.max(-r, -a), r), p = -u * u + h * (h + 2 * a) + c);
            else h = o > 0 ? -r : r, u = Math.max(0, -(o * h + s)), p = -u * u + h * (h + 2 * a) + c;
            return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(hi).multiplyScalar(h).add(ui), p
        },
        intersectSphere: function(t, e) {
            li.subVectors(t.center, this.origin);
            const n = li.dot(this.direction),
                i = li.dot(li) - n * n,
                r = t.radius * t.radius;
            if (i > r) return null;
            const o = Math.sqrt(r - i),
                s = n - o,
                a = n + o;
            return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
        },
        intersectsSphere: function(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        },
        distanceToPlane: function(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        },
        intersectPlane: function(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        },
        intersectsPlane: function(t) {
            const e = t.distanceToPoint(this.origin);
            if (0 === e) return !0;
            return t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function(t, e) {
            let n, i, r, o, s, a;
            const c = 1 / this.direction.x,
                l = 1 / this.direction.y,
                u = 1 / this.direction.z,
                h = this.origin;
            return c >= 0 ? (n = (t.min.x - h.x) * c, i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, i = (t.min.x - h.x) * c), l >= 0 ? (r = (t.min.y - h.y) * l, o = (t.max.y - h.y) * l) : (r = (t.max.y - h.y) * l, o = (t.min.y - h.y) * l), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), u >= 0 ? (s = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (s = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        },
        intersectsBox: function(t) {
            return null !== this.intersectBox(t, li)
        },
        intersectTriangle: function(t, e, n, i, r) {
            fi.subVectors(e, t), di.subVectors(n, t), mi.crossVectors(fi, di);
            let o, s = this.direction.dot(mi);
            if (s > 0) {
                if (i) return null;
                o = 1
            } else {
                if (!(s < 0)) return null;
                o = -1, s = -s
            }
            pi.subVectors(this.origin, t);
            const a = o * this.direction.dot(di.crossVectors(pi, di));
            if (a < 0) return null;
            const c = o * this.direction.dot(fi.cross(pi));
            if (c < 0) return null;
            if (a + c > s) return null;
            const l = -o * pi.dot(mi);
            return l < 0 ? null : this.at(l / s, r)
        },
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    });
    const vi = new yn,
        yi = new yn,
        bi = new an;

    function xi(t, e) {
        this.normal = void 0 !== t ? t : new yn(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }
    Object.assign(xi.prototype, {
        isPlane: !0,
        set: function(t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function(t, e, n, i) {
            return this.normal.set(t, e, n), this.constant = i, this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function(t, e, n) {
            const i = vi.subVectors(n, e).cross(yi.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new yn), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function(t, e) {
            void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new yn);
            const n = t.delta(vi),
                i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
        },
        intersectsLine: function(t) {
            const e = this.distanceToPoint(t.start),
                n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new yn), t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function(t, e) {
            const n = e || bi.getNormalMatrix(t),
                i = this.coplanarPoint(vi).applyMatrix4(t),
                r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r), this
        },
        translate: function(t) {
            return this.constant -= t.dot(this.normal), this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    });
    const wi = new yn,
        _i = new yn,
        Mi = new yn,
        Si = new yn,
        Ti = new yn,
        Ei = new yn,
        Ci = new yn,
        Ai = new yn,
        Li = new yn,
        Pi = new yn;

    function Oi(t, e, n) {
        this.a = void 0 !== t ? t : new yn, this.b = void 0 !== e ? e : new yn, this.c = void 0 !== n ? n : new yn
    }
    Object.assign(Oi, {
        getNormal: function(t, e, n, i) {
            void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new yn), i.subVectors(n, e), wi.subVectors(t, e), i.cross(wi);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        },
        getBarycoord: function(t, e, n, i, r) {
            wi.subVectors(i, e), _i.subVectors(n, e), Mi.subVectors(t, e);
            const o = wi.dot(wi),
                s = wi.dot(_i),
                a = wi.dot(Mi),
                c = _i.dot(_i),
                l = _i.dot(Mi),
                u = o * c - s * s;
            if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new yn), 0 === u) return r.set(-2, -1, -1);
            const h = 1 / u,
                p = (c * a - s * l) * h,
                f = (o * l - s * a) * h;
            return r.set(1 - p - f, f, p)
        },
        containsPoint: function(t, e, n, i) {
            return Oi.getBarycoord(t, e, n, i, Si), Si.x >= 0 && Si.y >= 0 && Si.x + Si.y <= 1
        },
        getUV: function(t, e, n, i, r, o, s, a) {
            return this.getBarycoord(t, e, n, i, Si), a.set(0, 0), a.addScaledVector(r, Si.x), a.addScaledVector(o, Si.y), a.addScaledVector(s, Si.z), a
        },
        isFrontFacing: function(t, e, n, i) {
            return wi.subVectors(n, e), _i.subVectors(t, e), wi.cross(_i).dot(i) < 0
        }
    }), Object.assign(Oi.prototype, {
        set: function(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
        },
        setFromPointsAndIndices: function(t, e, n, i) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        getArea: function() {
            return wi.subVectors(this.c, this.b), _i.subVectors(this.a, this.b), .5 * wi.cross(_i).length()
        },
        getMidpoint: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new yn), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(t) {
            return Oi.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new xi), t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(t, e) {
            return Oi.getBarycoord(t, this.a, this.b, this.c, e)
        },
        getUV: function(t, e, n, i, r) {
            return Oi.getUV(t, this.a, this.b, this.c, e, n, i, r)
        },
        containsPoint: function(t) {
            return Oi.containsPoint(t, this.a, this.b, this.c)
        },
        isFrontFacing: function(t) {
            return Oi.isFrontFacing(this.a, this.b, this.c, t)
        },
        intersectsBox: function(t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function(t, e) {
            void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new yn);
            const n = this.a,
                i = this.b,
                r = this.c;
            let o, s;
            Ti.subVectors(i, n), Ei.subVectors(r, n), Ai.subVectors(t, n);
            const a = Ti.dot(Ai),
                c = Ei.dot(Ai);
            if (a <= 0 && c <= 0) return e.copy(n);
            Li.subVectors(t, i);
            const l = Ti.dot(Li),
                u = Ei.dot(Li);
            if (l >= 0 && u <= l) return e.copy(i);
            const h = a * u - l * c;
            if (h <= 0 && a >= 0 && l <= 0) return o = a / (a - l), e.copy(n).addScaledVector(Ti, o);
            Pi.subVectors(t, r);
            const p = Ti.dot(Pi),
                f = Ei.dot(Pi);
            if (f >= 0 && p <= f) return e.copy(r);
            const d = p * c - a * f;
            if (d <= 0 && c >= 0 && f <= 0) return s = c / (c - f), e.copy(n).addScaledVector(Ei, s);
            const m = l * f - p * u;
            if (m <= 0 && u - l >= 0 && p - f >= 0) return Ci.subVectors(r, i), s = (u - l) / (u - l + (p - f)), e.copy(i).addScaledVector(Ci, s);
            const g = 1 / (m + d + h);
            return o = d * g, s = h * g, e.copy(n).addScaledVector(Ti, o).addScaledVector(Ei, s)
        },
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    });
    const Ri = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        Ii = {
            h: 0,
            s: 0,
            l: 0
        },
        Di = {
            h: 0,
            s: 0,
            l: 0
        };

    function Ni(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }

    function ki(t, e, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }

    function Ui(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }

    function Bi(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }

    function zi(t, e, n, i, r, o) {
        this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new yn, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Ni, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
    }
    Object.assign(Ni.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setScalar: function(t) {
            return this.r = t, this.g = t, this.b = t, this
        },
        setHex: function(t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function(t, e, n) {
            return this.r = t, this.g = e, this.b = n, this
        },
        setHSL: function(t, e, n) {
            if (t = on.euclideanModulo(t, 1), e = on.clamp(e, 0, 1), n = on.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
            else {
                const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                    r = 2 * n - i;
                this.r = ki(r, i, t + 1 / 3), this.g = ki(r, i, t), this.b = ki(r, i, t - 1 / 3)
            }
            return this
        },
        setStyle: function(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            let n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                let t;
                const i = n[1],
                    r = n[2];
                switch (i) {
                    case "rgb":
                    case "rgba":
                        if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this;
                        if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
                            const n = parseFloat(t[1]) / 360,
                                i = parseInt(t[2], 10) / 100,
                                r = parseInt(t[3], 10) / 100;
                            return e(t[5]), this.setHSL(n, i, r)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                const t = n[1],
                    e = t.length;
                if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
            }
            return t && t.length > 0 ? this.setColorName(t) : this
        },
        setColorName: function(t) {
            const e = Ri[t];
            return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        },
        copyLinearToGamma: function(t, e) {
            void 0 === e && (e = 2);
            const n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
        },
        convertGammaToLinear: function(t) {
            return this.copyGammaToLinear(this, t), this
        },
        convertLinearToGamma: function(t) {
            return this.copyLinearToGamma(this, t), this
        },
        copySRGBToLinear: function(t) {
            return this.r = Ui(t.r), this.g = Ui(t.g), this.b = Ui(t.b), this
        },
        copyLinearToSRGB: function(t) {
            return this.r = Bi(t.r), this.g = Bi(t.g), this.b = Bi(t.b), this
        },
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                h: 0,
                s: 0,
                l: 0
            });
            const e = this.r,
                n = this.g,
                i = this.b,
                r = Math.max(e, n, i),
                o = Math.min(e, n, i);
            let s, a;
            const c = (o + r) / 2;
            if (o === r) s = 0, a = 0;
            else {
                const t = r - o;
                switch (a = c <= .5 ? t / (r + o) : t / (2 - r - o), r) {
                    case e:
                        s = (n - i) / t + (n < i ? 6 : 0);
                        break;
                    case n:
                        s = (i - e) / t + 2;
                        break;
                    case i:
                        s = (e - n) / t + 4
                }
                s /= 6
            }
            return t.h = s, t.s = a, t.l = c, t
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(t, e, n) {
            return this.getHSL(Ii), Ii.h += t, Ii.s += e, Ii.l += n, this.setHSL(Ii.h, Ii.s, Ii.l), this
        },
        add: function(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function(t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        },
        multiply: function(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function(t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        lerpHSL: function(t, e) {
            this.getHSL(Ii), t.getHSL(Di);
            const n = on.lerp(Ii.h, Di.h, e),
                i = on.lerp(Ii.s, Di.s, e),
                r = on.lerp(Ii.l, Di.l, e);
            return this.setHSL(n, i, r), this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        },
        fromBufferAttribute: function(t, e) {
            return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
        },
        toJSON: function() {
            return this.getHex()
        }
    }), Ni.NAMES = Ri, Object.assign(zi.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    let Fi = 0;

    function ji() {
        Object.defineProperty(this, "id", {
            value: Fi++
        }), this.uuid = on.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
    }

    function Hi(t) {
        ji.call(this), this.type = "MeshBasicMaterial", this.color = new Ni(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
    }
    ji.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: ji,
        isMaterial: !0,
        onBeforeCompile: function() {},
        customProgramCacheKey: function() {
            return this.onBeforeCompile.toString()
        },
        setValues: function(t) {
            if (void 0 !== t)
                for (const e in t) {
                    const n = t[e];
                    if (void 0 === n) {
                        console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                        continue
                    }
                    if ("shading" === e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                        continue
                    }
                    const i = this[e];
                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                }
        },
        toJSON: function(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function i(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                const e = i(t.textures),
                    r = i(t.images);
                e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
                const t = e.length;
                n = new Array(t);
                for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(ji.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Hi.prototype = Object.create(ji.prototype), Hi.prototype.constructor = Hi, Hi.prototype.isMeshBasicMaterial = !0, Hi.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    };
    const Gi = new yn,
        Vi = new sn;

    function Wi(t, e, n) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function qi(t, e, n) {
        Wi.call(this, new Int8Array(t), e, n)
    }

    function Xi(t, e, n) {
        Wi.call(this, new Uint8Array(t), e, n)
    }

    function Zi(t, e, n) {
        Wi.call(this, new Uint8ClampedArray(t), e, n)
    }

    function Yi(t, e, n) {
        Wi.call(this, new Int16Array(t), e, n)
    }

    function $i(t, e, n) {
        Wi.call(this, new Uint16Array(t), e, n)
    }

    function Ji(t, e, n) {
        Wi.call(this, new Int32Array(t), e, n)
    }

    function Ki(t, e, n) {
        Wi.call(this, new Uint32Array(t), e, n)
    }

    function Qi(t, e, n) {
        Wi.call(this, new Float32Array(t), e, n)
    }

    function tr(t, e, n) {
        Wi.call(this, new Float64Array(t), e, n)
    }

    function er() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function nr(t) {
        if (0 === t.length) return -1 / 0;
        let e = t[0];
        for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
        return e
    }
    Object.defineProperty(Wi.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(Wi.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(t) {
            return this.usage = t, this
        },
        copy: function(t) {
            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize, n *= e.itemSize;
            for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t), this
        },
        copyColorsArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Ni), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new sn), e[n++] = r.x, e[n++] = r.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new yn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new pn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
            }
            return this
        },
        applyMatrix3: function(t) {
            if (2 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++) Vi.fromBufferAttribute(this, e), Vi.applyMatrix3(t), this.setXY(e, Vi.x, Vi.y);
            else if (3 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++) Gi.fromBufferAttribute(this, e), Gi.applyMatrix3(t), this.setXYZ(e, Gi.x, Gi.y, Gi.z);
            return this
        },
        applyMatrix4: function(t) {
            for (let e = 0, n = this.count; e < n; e++) Gi.x = this.getX(e), Gi.y = this.getY(e), Gi.z = this.getZ(e), Gi.applyMatrix4(t), this.setXYZ(e, Gi.x, Gi.y, Gi.z);
            return this
        },
        applyNormalMatrix: function(t) {
            for (let e = 0, n = this.count; e < n; e++) Gi.x = this.getX(e), Gi.y = this.getY(e), Gi.z = this.getZ(e), Gi.applyNormalMatrix(t), this.setXYZ(e, Gi.x, Gi.y, Gi.z);
            return this
        },
        transformDirection: function(t) {
            for (let e = 0, n = this.count; e < n; e++) Gi.x = this.getX(e), Gi.y = this.getY(e), Gi.z = this.getZ(e), Gi.transformDirection(t), this.setXYZ(e, Gi.x, Gi.y, Gi.z);
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
        },
        setXYZ: function(t, e, n, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
        },
        setXYZW: function(t, e, n, i, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), qi.prototype = Object.create(Wi.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(Wi.prototype), Xi.prototype.constructor = Xi, Zi.prototype = Object.create(Wi.prototype), Zi.prototype.constructor = Zi, Yi.prototype = Object.create(Wi.prototype), Yi.prototype.constructor = Yi, $i.prototype = Object.create(Wi.prototype), $i.prototype.constructor = $i, Ji.prototype = Object.create(Wi.prototype), Ji.prototype.constructor = Ji, Ki.prototype = Object.create(Wi.prototype), Ki.prototype.constructor = Ki, Qi.prototype = Object.create(Wi.prototype), Qi.prototype.constructor = Qi, tr.prototype = Object.create(Wi.prototype), tr.prototype.constructor = tr, Object.assign(er.prototype, {
        computeGroups: function(t) {
            const e = [];
            let n, i, r = void 0;
            const o = t.faces;
            for (i = 0; i < o.length; i++) {
                const t = o[i];
                t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = {
                    start: 3 * i,
                    materialIndex: r
                })
            }
            void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e
        },
        fromGeometry: function(t) {
            const e = t.faces,
                n = t.vertices,
                i = t.faceVertexUvs,
                r = i[0] && i[0].length > 0,
                o = i[1] && i[1].length > 0,
                s = t.morphTargets,
                a = s.length;
            let c;
            if (a > 0) {
                c = [];
                for (let t = 0; t < a; t++) c[t] = {
                    name: s[t].name,
                    data: []
                };
                this.morphTargets.position = c
            }
            const l = t.morphNormals,
                u = l.length;
            let h;
            if (u > 0) {
                h = [];
                for (let t = 0; t < u; t++) h[t] = {
                    name: l[t].name,
                    data: []
                };
                this.morphTargets.normal = h
            }
            const p = t.skinIndices,
                f = t.skinWeights,
                d = p.length === n.length,
                m = f.length === n.length;
            n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (let t = 0; t < e.length; t++) {
                const g = e[t];
                this.vertices.push(n[g.a], n[g.b], n[g.c]);
                const v = g.vertexNormals;
                if (3 === v.length) this.normals.push(v[0], v[1], v[2]);
                else {
                    const t = g.normal;
                    this.normals.push(t, t, t)
                }
                const y = g.vertexColors;
                if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
                else {
                    const t = g.color;
                    this.colors.push(t, t, t)
                }
                if (!0 === r) {
                    const e = i[0][t];
                    void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t), this.uvs.push(new sn, new sn, new sn))
                }
                if (!0 === o) {
                    const e = i[1][t];
                    void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t), this.uvs2.push(new sn, new sn, new sn))
                }
                for (let t = 0; t < a; t++) {
                    const e = s[t].vertices;
                    c[t].data.push(e[g.a], e[g.b], e[g.c])
                }
                for (let e = 0; e < u; e++) {
                    const n = l[e].vertexNormals[t];
                    h[e].data.push(n.a, n.b, n.c)
                }
                d && this.skinIndices.push(p[g.a], p[g.b], p[g.c]), m && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        }
    });
    let ir = 1;
    const rr = new En,
        or = new Vn,
        sr = new yn,
        ar = new oi,
        cr = new oi,
        lr = new yn;

    function ur() {
        Object.defineProperty(this, "id", {
            value: ir += 2
        }), this.uuid = on.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    ur.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: ur,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new(nr(t) > 65535 ? Ki : $i)(t, 1) : this.index = t
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        setAttribute: function(t, e) {
            return this.attributes[t] = e, this
        },
        deleteAttribute: function(t) {
            return delete this.attributes[t], this
        },
        addGroup: function(t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        },
        applyMatrix4: function(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const e = (new an).getNormalMatrix(t);
                n.applyNormalMatrix(e), n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function(t) {
            return rr.makeRotationX(t), this.applyMatrix4(rr), this
        },
        rotateY: function(t) {
            return rr.makeRotationY(t), this.applyMatrix4(rr), this
        },
        rotateZ: function(t) {
            return rr.makeRotationZ(t), this.applyMatrix4(rr), this
        },
        translate: function(t, e, n) {
            return rr.makeTranslation(t, e, n), this.applyMatrix4(rr), this
        },
        scale: function(t, e, n) {
            return rr.makeScale(t, e, n), this.applyMatrix4(rr), this
        },
        lookAt: function(t) {
            return or.lookAt(t), or.updateMatrix(), this.applyMatrix4(or.matrix), this
        },
        center: function() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(sr).negate(), this.translate(sr.x, sr.y, sr.z), this
        },
        setFromObject: function(t) {
            const e = t.geometry;
            if (t.isPoints || t.isLine) {
                const t = new Qi(3 * e.vertices.length, 3),
                    n = new Qi(3 * e.colors.length, 3);
                if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    const t = new Qi(e.lineDistances.length, 1);
                    this.setAttribute("lineDistance", t.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new Qi(e, 3)), this
        },
        updateFromObject: function(t) {
            let e = t.geometry;
            if (t.isMesh) {
                let t = e.__directGeometry;
                if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e);
                t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t
            }
            if (!0 === e.verticesNeedUpdate) {
                const t = this.attributes.position;
                void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1
            }
            if (!0 === e.normalsNeedUpdate) {
                const t = this.attributes.normal;
                void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1
            }
            if (!0 === e.colorsNeedUpdate) {
                const t = this.attributes.color;
                void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1
            }
            if (e.uvsNeedUpdate) {
                const t = this.attributes.uv;
                void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1
            }
            if (e.lineDistancesNeedUpdate) {
                const t = this.attributes.lineDistance;
                void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1
            }
            return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new er).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            const e = new Float32Array(3 * t.vertices.length);
            if (this.setAttribute("position", new Wi(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                const e = new Float32Array(3 * t.normals.length);
                this.setAttribute("normal", new Wi(e, 3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                const e = new Float32Array(3 * t.colors.length);
                this.setAttribute("color", new Wi(e, 3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                const e = new Float32Array(2 * t.uvs.length);
                this.setAttribute("uv", new Wi(e, 2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                const e = new Float32Array(2 * t.uvs2.length);
                this.setAttribute("uv2", new Wi(e, 2).copyVector2sArray(t.uvs2))
            }
            this.groups = t.groups;
            for (const e in t.morphTargets) {
                const n = [],
                    i = t.morphTargets[e];
                for (let t = 0, e = i.length; t < e; t++) {
                    const e = i[t],
                        r = new Qi(3 * e.data.length, 3);
                    r.name = e.name, n.push(r.copyVector3sArray(e.data))
                }
                this.morphAttributes[e] = n
            }
            if (t.skinIndices.length > 0) {
                const e = new Qi(4 * t.skinIndices.length, 4);
                this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                const e = new Qi(4 * t.skinWeights.length, 4);
                this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new oi);
            const t = this.attributes.position,
                e = this.morphAttributes.position;
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t), e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        ar.setFromBufferAttribute(n), this.morphTargetsRelative ? (lr.addVectors(this.boundingBox.min, ar.min), this.boundingBox.expandByPoint(lr), lr.addVectors(this.boundingBox.max, ar.max), this.boundingBox.expandByPoint(lr)) : (this.boundingBox.expandByPoint(ar.min), this.boundingBox.expandByPoint(ar.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new ci);
            const t = this.attributes.position,
                e = this.morphAttributes.position;
            if (t) {
                const n = this.boundingSphere.center;
                if (ar.setFromBufferAttribute(t), e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        cr.setFromBufferAttribute(n), this.morphTargetsRelative ? (lr.addVectors(ar.min, cr.min), ar.expandByPoint(lr), lr.addVectors(ar.max, cr.max), ar.expandByPoint(lr)) : (ar.expandByPoint(cr.min), ar.expandByPoint(cr.max))
                    }
                ar.getCenter(n);
                let i = 0;
                for (let e = 0, r = t.count; e < r; e++) lr.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(lr));
                if (e)
                    for (let r = 0, o = e.length; r < o; r++) {
                        const o = e[r],
                            s = this.morphTargetsRelative;
                        for (let e = 0, r = o.count; e < r; e++) lr.fromBufferAttribute(o, e), s && (sr.fromBufferAttribute(t, e), lr.add(sr)), i = Math.max(i, n.distanceToSquared(lr))
                    }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            const t = this.index,
                e = this.getAttribute("position");
            if (void 0 !== e) {
                let n = this.getAttribute("normal");
                if (void 0 === n) n = new Wi(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                else
                    for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                const i = new yn,
                    r = new yn,
                    o = new yn,
                    s = new yn,
                    a = new yn,
                    c = new yn,
                    l = new yn,
                    u = new yn;
                if (t)
                    for (let h = 0, p = t.count; h < p; h += 3) {
                        const p = t.getX(h + 0),
                            f = t.getX(h + 1),
                            d = t.getX(h + 2);
                        i.fromBufferAttribute(e, p), r.fromBufferAttribute(e, f), o.fromBufferAttribute(e, d), l.subVectors(o, r), u.subVectors(i, r), l.cross(u), s.fromBufferAttribute(n, p), a.fromBufferAttribute(n, f), c.fromBufferAttribute(n, d), s.add(l), a.add(l), c.add(l), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(d, c.x, c.y, c.z)
                    } else
                        for (let t = 0, s = e.count; t < s; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), l.subVectors(o, r), u.subVectors(i, r), l.cross(u), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
            void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const n = this.attributes;
            for (const i in n) {
                if (void 0 === t.attributes[i]) continue;
                const r = n[i].array,
                    o = t.attributes[i],
                    s = o.array,
                    a = o.itemSize * e,
                    c = Math.min(s.length, r.length - a);
                for (let t = 0, e = a; t < c; t++, e++) r[e] = s[t]
            }
            return this
        },
        normalizeNormals: function() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++) lr.fromBufferAttribute(t, e), lr.normalize(), t.setXYZ(e, lr.x, lr.y, lr.z)
        },
        toNonIndexed: function() {
            function t(t, e) {
                const n = t.array,
                    i = t.itemSize,
                    r = t.normalized,
                    o = new n.constructor(e.length * i);
                let s = 0,
                    a = 0;
                for (let t = 0, r = e.length; t < r; t++) {
                    s = e[t] * i;
                    for (let t = 0; t < i; t++) o[a++] = n[s++]
                }
                return new Wi(o, i, r)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            const e = new ur,
                n = this.index.array,
                i = this.attributes;
            for (const r in i) {
                const o = t(i[r], n);
                e.setAttribute(r, o)
            }
            const r = this.morphAttributes;
            for (const i in r) {
                const o = [],
                    s = r[i];
                for (let e = 0, i = s.length; e < i; e++) {
                    const i = t(s[e], n);
                    o.push(i)
                }
                e.morphAttributes[i] = o
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const o = this.groups;
            for (let t = 0, n = o.length; t < n; t++) {
                const n = o[t];
                e.addGroup(n.start, n.count, n.materialIndex)
            }
            return e
        },
        toJSON: function() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                const e = this.parameters;
                for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            const e = this.index;
            null !== e && (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array)
            });
            const n = this.attributes;
            for (const e in n) {
                const i = n[e],
                    r = i.toJSON(t.data);
                "" !== i.name && (r.name = i.name), t.data.attributes[e] = r
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
                const n = this.morphAttributes[e],
                    o = [];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e],
                        r = i.toJSON(t.data);
                    "" !== i.name && (r.name = i.name), o.push(r)
                }
                o.length > 0 && (i[e] = o, r = !0)
            }
            r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
            const o = this.groups;
            o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
            const s = this.boundingSphere;
            return null !== s && (t.data.boundingSphere = {
                center: s.center.toArray(),
                radius: s.radius
            }), t
        },
        clone: function() {
            return (new ur).copy(this)
        },
        copy: function(t) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
                const n = i[t];
                this.setAttribute(t, n.clone(e))
            }
            const r = t.morphAttributes;
            for (const t in r) {
                const n = [],
                    i = r[t];
                for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                this.morphAttributes[t] = n
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const o = t.groups;
            for (let t = 0, e = o.length; t < e; t++) {
                const e = o[t];
                this.addGroup(e.start, e.count, e.materialIndex)
            }
            const s = t.boundingBox;
            null !== s && (this.boundingBox = s.clone());
            const a = t.boundingSphere;
            return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    const hr = new En,
        pr = new gi,
        fr = new ci,
        dr = new yn,
        mr = new yn,
        gr = new yn,
        vr = new yn,
        yr = new yn,
        br = new yn,
        xr = new yn,
        wr = new yn,
        _r = new yn,
        Mr = new sn,
        Sr = new sn,
        Tr = new sn,
        Er = new yn,
        Cr = new yn;

    function Ar(t, e) {
        Vn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ur, this.material = void 0 !== e ? e : new Hi, this.updateMorphTargets()
    }

    function Lr(t, e, n, i, r, o, s, a) {
        let c;
        if (c = 1 === e.side ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, 2 !== e.side, a), null === c) return null;
        Cr.copy(a), Cr.applyMatrix4(t.matrixWorld);
        const l = n.ray.origin.distanceTo(Cr);
        return l < n.near || l > n.far ? null : {
            distance: l,
            point: Cr.clone(),
            object: t
        }
    }

    function Pr(t, e, n, i, r, o, s, a, c, l, u, h) {
        dr.fromBufferAttribute(r, l), mr.fromBufferAttribute(r, u), gr.fromBufferAttribute(r, h);
        const p = t.morphTargetInfluences;
        if (e.morphTargets && o && p) {
            xr.set(0, 0, 0), wr.set(0, 0, 0), _r.set(0, 0, 0);
            for (let t = 0, e = o.length; t < e; t++) {
                const e = p[t],
                    n = o[t];
                0 !== e && (vr.fromBufferAttribute(n, l), yr.fromBufferAttribute(n, u), br.fromBufferAttribute(n, h), s ? (xr.addScaledVector(vr, e), wr.addScaledVector(yr, e), _r.addScaledVector(br, e)) : (xr.addScaledVector(vr.sub(dr), e), wr.addScaledVector(yr.sub(mr), e), _r.addScaledVector(br.sub(gr), e)))
            }
            dr.add(xr), mr.add(wr), gr.add(_r)
        }
        t.isSkinnedMesh && (t.boneTransform(l, dr), t.boneTransform(u, mr), t.boneTransform(h, gr));
        const f = Lr(t, e, n, i, dr, mr, gr, Er);
        if (f) {
            a && (Mr.fromBufferAttribute(a, l), Sr.fromBufferAttribute(a, u), Tr.fromBufferAttribute(a, h), f.uv = Oi.getUV(Er, dr, mr, gr, Mr, Sr, Tr, new sn)), c && (Mr.fromBufferAttribute(c, l), Sr.fromBufferAttribute(c, u), Tr.fromBufferAttribute(c, h), f.uv2 = Oi.getUV(Er, dr, mr, gr, Mr, Sr, Tr, new sn));
            const t = new zi(l, u, h);
            Oi.getNormal(dr, mr, gr, t.normal), f.face = t
        }
        return f
    }
    Ar.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: Ar,
        isMesh: !0,
        copy: function(t) {
            return Vn.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
        },
        updateMorphTargets: function() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes,
                    n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function(t, e) {
            const n = this.geometry,
                i = this.material,
                r = this.matrixWorld;
            if (void 0 === i) return;
            if (null === n.boundingSphere && n.computeBoundingSphere(), fr.copy(n.boundingSphere), fr.applyMatrix4(r), !1 === t.ray.intersectsSphere(fr)) return;
            if (hr.getInverse(r), pr.copy(t.ray).applyMatrix4(hr), null !== n.boundingBox && !1 === pr.intersectsBox(n.boundingBox)) return;
            let o;
            if (n.isBufferGeometry) {
                const r = n.index,
                    s = n.attributes.position,
                    a = n.morphAttributes.position,
                    c = n.morphTargetsRelative,
                    l = n.attributes.uv,
                    u = n.attributes.uv2,
                    h = n.groups,
                    p = n.drawRange;
                if (null !== r)
                    if (Array.isArray(i))
                        for (let n = 0, f = h.length; n < f; n++) {
                            const f = h[n],
                                d = i[f.materialIndex];
                            for (let n = Math.max(f.start, p.start), i = Math.min(f.start + f.count, p.start + p.count); n < i; n += 3) {
                                const i = r.getX(n),
                                    h = r.getX(n + 1),
                                    p = r.getX(n + 2);
                                o = Pr(this, d, t, pr, s, a, c, l, u, i, h, p), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = f.materialIndex, e.push(o))
                            }
                        } else {
                            for (let n = Math.max(0, p.start), h = Math.min(r.count, p.start + p.count); n < h; n += 3) {
                                const h = r.getX(n),
                                    p = r.getX(n + 1),
                                    f = r.getX(n + 2);
                                o = Pr(this, i, t, pr, s, a, c, l, u, h, p, f), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                            }
                        } else if (void 0 !== s)
                            if (Array.isArray(i))
                                for (let n = 0, r = h.length; n < r; n++) {
                                    const r = h[n],
                                        f = i[r.materialIndex];
                                    for (let n = Math.max(r.start, p.start), i = Math.min(r.start + r.count, p.start + p.count); n < i; n += 3) {
                                        o = Pr(this, f, t, pr, s, a, c, l, u, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = r.materialIndex, e.push(o))
                                    }
                                } else {
                                    for (let n = Math.max(0, p.start), r = Math.min(s.count, p.start + p.count); n < r; n += 3) {
                                        o = Pr(this, i, t, pr, s, a, c, l, u, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                                    }
                                }
            } else if (n.isGeometry) {
                const r = Array.isArray(i),
                    s = n.vertices,
                    a = n.faces;
                let c;
                const l = n.faceVertexUvs[0];
                l.length > 0 && (c = l);
                for (let n = 0, l = a.length; n < l; n++) {
                    const l = a[n],
                        u = r ? i[l.materialIndex] : i;
                    if (void 0 === u) continue;
                    const h = s[l.a],
                        p = s[l.b],
                        f = s[l.c];
                    if (o = Lr(this, u, t, pr, h, p, f, Er), o) {
                        if (c && c[n]) {
                            const t = c[n];
                            Mr.copy(t[0]), Sr.copy(t[1]), Tr.copy(t[2]), o.uv = Oi.getUV(Er, h, p, f, Mr, Sr, Tr, new sn)
                        }
                        o.face = l, o.faceIndex = n, e.push(o)
                    }
                }
            }
        }
    });
    let Or = 0;
    const Rr = new En,
        Ir = new Vn,
        Dr = new yn;

    function Nr() {
        Object.defineProperty(this, "id", {
            value: Or += 2
        }), this.uuid = on.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }
    Nr.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: Nr,
        isGeometry: !0,
        applyMatrix4: function(t) {
            const e = (new an).getNormalMatrix(t);
            for (let e = 0, n = this.vertices.length; e < n; e++) {
                this.vertices[e].applyMatrix4(t)
            }
            for (let t = 0, n = this.faces.length; t < n; t++) {
                const n = this.faces[t];
                n.normal.applyMatrix3(e).normalize();
                for (let t = 0, i = n.vertexNormals.length; t < i; t++) n.vertexNormals[t].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function(t) {
            return Rr.makeRotationX(t), this.applyMatrix4(Rr), this
        },
        rotateY: function(t) {
            return Rr.makeRotationY(t), this.applyMatrix4(Rr), this
        },
        rotateZ: function(t) {
            return Rr.makeRotationZ(t), this.applyMatrix4(Rr), this
        },
        translate: function(t, e, n) {
            return Rr.makeTranslation(t, e, n), this.applyMatrix4(Rr), this
        },
        scale: function(t, e, n) {
            return Rr.makeScale(t, e, n), this.applyMatrix4(Rr), this
        },
        lookAt: function(t) {
            return Ir.lookAt(t), Ir.updateMatrix(), this.applyMatrix4(Ir.matrix), this
        },
        fromBufferGeometry: function(t) {
            const e = this,
                n = null !== t.index ? t.index : void 0,
                i = t.attributes;
            if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
            const r = i.position,
                o = i.normal,
                s = i.color,
                a = i.uv,
                c = i.uv2;
            void 0 !== c && (this.faceVertexUvs[1] = []);
            for (let t = 0; t < r.count; t++) e.vertices.push((new yn).fromBufferAttribute(r, t)), void 0 !== s && e.colors.push((new Ni).fromBufferAttribute(s, t));

            function l(t, n, i, r) {
                const l = void 0 === s ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                    u = new zi(t, n, i, void 0 === o ? [] : [(new yn).fromBufferAttribute(o, t), (new yn).fromBufferAttribute(o, n), (new yn).fromBufferAttribute(o, i)], l, r);
                e.faces.push(u), void 0 !== a && e.faceVertexUvs[0].push([(new sn).fromBufferAttribute(a, t), (new sn).fromBufferAttribute(a, n), (new sn).fromBufferAttribute(a, i)]), void 0 !== c && e.faceVertexUvs[1].push([(new sn).fromBufferAttribute(c, t), (new sn).fromBufferAttribute(c, n), (new sn).fromBufferAttribute(c, i)])
            }
            const u = t.groups;
            if (u.length > 0)
                for (let t = 0; t < u.length; t++) {
                    const e = u[t],
                        i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) void 0 !== n ? l(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex) : l(t, t + 1, t + 2, e.materialIndex)
                } else if (void 0 !== n)
                    for (let t = 0; t < n.count; t += 3) l(n.getX(t), n.getX(t + 1), n.getX(t + 2));
                else
                    for (let t = 0; t < r.count; t += 3) l(t, t + 1, t + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: function() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Dr).negate(), this.translate(Dr.x, Dr.y, Dr.z), this
        },
        normalize: function() {
            this.computeBoundingSphere();
            const t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                n = 0 === e ? 1 : 1 / e,
                i = new En;
            return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
        },
        computeFaceNormals: function() {
            const t = new yn,
                e = new yn;
            for (let n = 0, i = this.faces.length; n < i; n++) {
                const i = this.faces[n],
                    r = this.vertices[i.a],
                    o = this.vertices[i.b],
                    s = this.vertices[i.c];
                t.subVectors(s, o), e.subVectors(r, o), t.cross(e), t.normalize(), i.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            void 0 === t && (t = !0);
            const e = new Array(this.vertices.length);
            for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new yn;
            if (t) {
                const t = new yn,
                    n = new yn;
                for (let i = 0, r = this.faces.length; i < r; i++) {
                    const r = this.faces[i],
                        o = this.vertices[r.a],
                        s = this.vertices[r.b],
                        a = this.vertices[r.c];
                    t.subVectors(a, s), n.subVectors(o, s), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t)
                }
            } else {
                this.computeFaceNormals();
                for (let t = 0, n = this.faces.length; t < n; t++) {
                    const n = this.faces[t];
                    e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal)
                }
            }
            for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize();
            for (let t = 0, n = this.faces.length; t < n; t++) {
                const n = this.faces[t],
                    i = n.vertexNormals;
                3 === i.length ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c])) : (i[0] = e[n.a].clone(), i[1] = e[n.b].clone(), i[2] = e[n.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            this.computeFaceNormals();
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t],
                    n = e.vertexNormals;
                3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t];
                e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []);
                for (let t = 0, n = e.vertexNormals.length; t < n; t++) e.__originalVertexNormals[t] ? e.__originalVertexNormals[t].copy(e.vertexNormals[t]) : e.__originalVertexNormals[t] = e.vertexNormals[t].clone()
            }
            const t = new Nr;
            t.faces = this.faces;
            for (let e = 0, n = this.morphTargets.length; e < n; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                    const t = this.morphNormals[e].faceNormals,
                        n = this.morphNormals[e].vertexNormals;
                    for (let e = 0, i = this.faces.length; e < i; e++) {
                        const e = new yn,
                            i = {
                                a: new yn,
                                b: new yn,
                                c: new yn
                            };
                        t.push(e), n.push(i)
                    }
                }
                const n = this.morphNormals[e];
                t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
                for (let t = 0, e = this.faces.length; t < e; t++) {
                    const e = this.faces[t],
                        i = n.faceNormals[t],
                        r = n.vertexNormals[t];
                    i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2])
                }
            }
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t];
                e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
            }
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new oi), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new ci), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, n) {
            if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
            let i, r = this.vertices.length,
                o = this.vertices,
                s = t.vertices,
                a = this.faces,
                c = t.faces,
                l = this.colors,
                u = t.colors;
            void 0 === n && (n = 0), void 0 !== e && (i = (new an).getNormalMatrix(e));
            for (let t = 0, n = s.length; t < n; t++) {
                const n = s[t].clone();
                void 0 !== e && n.applyMatrix4(e), o.push(n)
            }
            for (let t = 0, e = u.length; t < e; t++) l.push(u[t].clone());
            for (let t = 0, e = c.length; t < e; t++) {
                let e, o, s, l = c[t],
                    u = l.vertexNormals,
                    h = l.vertexColors;
                e = new zi(l.a + r, l.b + r, l.c + r), e.normal.copy(l.normal), void 0 !== i && e.normal.applyMatrix3(i).normalize();
                for (let t = 0, n = u.length; t < n; t++) o = u[t].clone(), void 0 !== i && o.applyMatrix3(i).normalize(), e.vertexNormals.push(o);
                e.color.copy(l.color);
                for (let t = 0, n = h.length; t < n; t++) s = h[t], e.vertexColors.push(s.clone());
                e.materialIndex = l.materialIndex + n, a.push(e)
            }
            for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                const n = t.faceVertexUvs[e];
                void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t],
                        r = [];
                    for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone());
                    this.faceVertexUvs[e].push(r)
                }
            }
        },
        mergeMesh: function(t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function() {
            const t = {},
                e = [],
                n = [],
                i = Math.pow(10, 4);
            for (let r = 0, o = this.vertices.length; r < o; r++) {
                const o = this.vertices[r],
                    s = Math.round(o.x * i) + "_" + Math.round(o.y * i) + "_" + Math.round(o.z * i);
                void 0 === t[s] ? (t[s] = r, e.push(this.vertices[r]), n[r] = e.length - 1) : n[r] = n[t[s]]
            }
            const r = [];
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t];
                e.a = n[e.a], e.b = n[e.b], e.c = n[e.c];
                const i = [e.a, e.b, e.c];
                for (let e = 0; e < 3; e++)
                    if (i[e] === i[(e + 1) % 3]) {
                        r.push(t);
                        break
                    }
            }
            for (let t = r.length - 1; t >= 0; t--) {
                const e = r[t];
                this.faces.splice(e, 1);
                for (let t = 0, n = this.faceVertexUvs.length; t < n; t++) this.faceVertexUvs[t].splice(e, 1)
            }
            const o = this.vertices.length - e.length;
            return this.vertices = e, o
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                this.vertices.push(new yn(n.x, n.y, n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            const t = this.faces,
                e = t.length;
            for (let n = 0; n < e; n++) t[n]._id = n;
            t.sort((function(t, e) {
                return t.materialIndex - e.materialIndex
            }));
            const n = this.faceVertexUvs[0],
                i = this.faceVertexUvs[1];
            let r, o;
            n && n.length === e && (r = []), i && i.length === e && (o = []);
            for (let s = 0; s < e; s++) {
                const e = t[s]._id;
                r && r.push(n[e]), o && o.push(i[e])
            }
            r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o)
        },
        toJSON: function() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                const e = this.parameters;
                for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            const e = [];
            for (let t = 0; t < this.vertices.length; t++) {
                const n = this.vertices[t];
                e.push(n.x, n.y, n.z)
            }
            const n = [],
                i = [],
                r = {},
                o = [],
                s = {},
                a = [],
                c = {};
            for (let t = 0; t < this.faces.length; t++) {
                const e = this.faces[t],
                    i = !0,
                    r = !1,
                    o = void 0 !== this.faceVertexUvs[0][t],
                    s = e.normal.length() > 0,
                    a = e.vertexNormals.length > 0,
                    c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
                    f = e.vertexColors.length > 0;
                let d = 0;
                if (d = l(d, 0, 0), d = l(d, 1, i), d = l(d, 2, r), d = l(d, 3, o), d = l(d, 4, s), d = l(d, 5, a), d = l(d, 6, c), d = l(d, 7, f), n.push(d), n.push(e.a, e.b, e.c), n.push(e.materialIndex), o) {
                    const e = this.faceVertexUvs[0][t];
                    n.push(p(e[0]), p(e[1]), p(e[2]))
                }
                if (s && n.push(u(e.normal)), a) {
                    const t = e.vertexNormals;
                    n.push(u(t[0]), u(t[1]), u(t[2]))
                }
                if (c && n.push(h(e.color)), f) {
                    const t = e.vertexColors;
                    n.push(h(t[0]), h(t[1]), h(t[2]))
                }
            }

            function l(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }

            function u(t) {
                const e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== r[e] || (r[e] = i.length / 3, i.push(t.x, t.y, t.z)), r[e]
            }

            function h(t) {
                const e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== s[e] || (s[e] = o.length, o.push(t.getHex())), s[e]
            }

            function p(t) {
                const e = t.x.toString() + t.y.toString();
                return void 0 !== c[e] || (c[e] = a.length / 2, a.push(t.x, t.y)), c[e]
            }
            return t.data = {}, t.data.vertices = e, t.data.normals = i, o.length > 0 && (t.data.colors = o), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t
        },
        clone: function() {
            return (new Nr).copy(this)
        },
        copy: function(t) {
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            const e = t.vertices;
            for (let t = 0, n = e.length; t < n; t++) this.vertices.push(e[t].clone());
            const n = t.colors;
            for (let t = 0, e = n.length; t < e; t++) this.colors.push(n[t].clone());
            const i = t.faces;
            for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone());
            for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                const n = t.faceVertexUvs[e];
                void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t],
                        r = [];
                    for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t];
                        r.push(e.clone())
                    }
                    this.faceVertexUvs[e].push(r)
                }
            }
            const r = t.morphTargets;
            for (let t = 0, e = r.length; t < e; t++) {
                const e = {};
                if (e.name = r[t].name, void 0 !== r[t].vertices) {
                    e.vertices = [];
                    for (let n = 0, i = r[t].vertices.length; n < i; n++) e.vertices.push(r[t].vertices[n].clone())
                }
                if (void 0 !== r[t].normals) {
                    e.normals = [];
                    for (let n = 0, i = r[t].normals.length; n < i; n++) e.normals.push(r[t].normals[n].clone())
                }
                this.morphTargets.push(e)
            }
            const o = t.morphNormals;
            for (let t = 0, e = o.length; t < e; t++) {
                const e = {};
                if (void 0 !== o[t].vertexNormals) {
                    e.vertexNormals = [];
                    for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) {
                        const i = o[t].vertexNormals[n],
                            r = {};
                        r.a = i.a.clone(), r.b = i.b.clone(), r.c = i.c.clone(), e.vertexNormals.push(r)
                    }
                }
                if (void 0 !== o[t].faceNormals) {
                    e.faceNormals = [];
                    for (let n = 0, i = o[t].faceNormals.length; n < i; n++) e.faceNormals.push(o[t].faceNormals[n].clone())
                }
                this.morphNormals.push(e)
            }
            const s = t.skinWeights;
            for (let t = 0, e = s.length; t < e; t++) this.skinWeights.push(s[t].clone());
            const a = t.skinIndices;
            for (let t = 0, e = a.length; t < e; t++) this.skinIndices.push(a[t].clone());
            const c = t.lineDistances;
            for (let t = 0, e = c.length; t < e; t++) this.lineDistances.push(c[t]);
            const l = t.boundingBox;
            null !== l && (this.boundingBox = l.clone());
            const u = t.boundingSphere;
            return null !== u && (this.boundingSphere = u.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    class kr extends Nr {
        constructor(t, e, n, i, r, o) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: o
            }, this.fromBufferGeometry(new Ur(t, e, n, i, r, o)), this.mergeVertices()
        }
    }
    class Ur extends ur {
        constructor(t, e, n, i, r, o) {
            super(), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: o
            };
            const s = this;
            t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
            const a = [],
                c = [],
                l = [],
                u = [];
            let h = 0,
                p = 0;

            function f(t, e, n, i, r, o, f, d, m, g, v) {
                const y = o / m,
                    b = f / g,
                    x = o / 2,
                    w = f / 2,
                    _ = d / 2,
                    M = m + 1,
                    S = g + 1;
                let T = 0,
                    E = 0;
                const C = new yn;
                for (let o = 0; o < S; o++) {
                    const s = o * b - w;
                    for (let a = 0; a < M; a++) {
                        const h = a * y - x;
                        C[t] = h * i, C[e] = s * r, C[n] = _, c.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[n] = d > 0 ? 1 : -1, l.push(C.x, C.y, C.z), u.push(a / m), u.push(1 - o / g), T += 1
                    }
                }
                for (let t = 0; t < g; t++)
                    for (let e = 0; e < m; e++) {
                        const n = h + e + M * t,
                            i = h + e + M * (t + 1),
                            r = h + (e + 1) + M * (t + 1),
                            o = h + (e + 1) + M * t;
                        a.push(n, i, o), a.push(i, r, o), E += 6
                    }
                s.addGroup(p, E, v), p += E, h += T
            }
            f("z", "y", "x", -1, -1, n, e, t, o, r, 0), f("z", "y", "x", 1, -1, n, e, -t, o, r, 1), f("x", "z", "y", 1, 1, t, n, e, i, o, 2), f("x", "z", "y", 1, -1, t, n, -e, i, o, 3), f("x", "y", "z", 1, -1, t, e, n, i, r, 4), f("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Qi(c, 3)), this.setAttribute("normal", new Qi(l, 3)), this.setAttribute("uv", new Qi(u, 2))
        }
    }

    function Br(t) {
        const e = {};
        for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
                const r = t[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
            }
        }
        return e
    }

    function zr(t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const i = Br(t[n]);
            for (const t in i) e[t] = i[t]
        }
        return e
    }
    const Fr = {
        clone: Br,
        merge: zr
    };

    function jr(t) {
        ji.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }

    function Hr() {
        Vn.call(this), this.type = "Camera", this.matrixWorldInverse = new En, this.projectionMatrix = new En, this.projectionMatrixInverse = new En
    }

    function Gr(t, e, n, i) {
        Hr.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    jr.prototype = Object.create(ji.prototype), jr.prototype.constructor = jr, jr.prototype.isShaderMaterial = !0, jr.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Br(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this
    }, jr.prototype.toJSON = function(t) {
        const e = ji.prototype.toJSON.call(this, t);
        e.uniforms = {};
        for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture ? e.uniforms[n] = {
                type: "t",
                value: i.toJSON(t).uuid
            } : i && i.isColor ? e.uniforms[n] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? e.uniforms[n] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? e.uniforms[n] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? e.uniforms[n] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? e.uniforms[n] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? e.uniforms[n] = {
                type: "m4",
                value: i.toArray()
            } : e.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        const n = {};
        for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e
    }, Hr.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: Hr,
        isCamera: !0,
        copy: function(t, e) {
            return Vn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
        },
        getWorldDirection: function(t) {
            void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new yn), this.updateMatrixWorld(!0);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        },
        updateMatrixWorld: function(t) {
            Vn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        updateWorldMatrix: function(t, e) {
            Vn.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Gr.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: Gr,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return Hr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        },
        setFocalLength: function(t) {
            const e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * on.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            const t = Math.tan(.5 * on.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * on.RAD2DEG * Math.atan(Math.tan(.5 * on.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, n, i, r, o) {
            this.aspect = t / e, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            let t = this.near,
                e = t * Math.tan(.5 * on.DEG2RAD * this.fov) / this.zoom,
                n = 2 * e,
                i = this.aspect * n,
                r = -.5 * i,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                const t = o.fullWidth,
                    s = o.fullHeight;
                r += o.offsetX * i / t, e -= o.offsetY * n / s, i *= o.width / t, n *= o.height / s
            }
            const s = this.filmOffset;
            0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            const e = Vn.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    });

    function Vr(t, e, n) {
        if (Vn.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = n;
        const i = new Gr(90, 1, t, e);
        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new yn(1, 0, 0)), this.add(i);
        const r = new Gr(90, 1, t, e);
        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new yn(-1, 0, 0)), this.add(r);
        const o = new Gr(90, 1, t, e);
        o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new yn(0, 1, 0)), this.add(o);
        const s = new Gr(90, 1, t, e);
        s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new yn(0, -1, 0)), this.add(s);
        const a = new Gr(90, 1, t, e);
        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new yn(0, 0, 1)), this.add(a);
        const c = new Gr(90, 1, t, e);
        c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new yn(0, 0, -1)), this.add(c), this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const l = t.xr.enabled,
                u = t.getRenderTarget();
            t.xr.enabled = !1;
            const h = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = l
        }, this.clear = function(t, e, i, r) {
            const o = t.getRenderTarget();
            for (let o = 0; o < 6; o++) t.setRenderTarget(n, o), t.clear(e, i, r);
            t.setRenderTarget(o)
        }
    }

    function Wr(t, e, n) {
        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), fn.call(this, t, t, e)
    }

    function qr(t, e, n, i, r, o, s, a, c, l, u, h) {
        hn.call(this, null, o, s, a, c, l, i, r, u, h), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1
        }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
    Vr.prototype = Object.create(Vn.prototype), Vr.prototype.constructor = Vr, Wr.prototype = Object.create(fn.prototype), Wr.prototype.constructor = Wr, Wr.prototype.isWebGLCubeRenderTarget = !0, Wr.prototype.fromEquirectangularTexture = function(t, e) {
        this.texture.type = e.type, this.texture.format = e.format, this.texture.encoding = e.encoding;
        const n = new Wn,
            i = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#include <common>", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV = equirectUv( direction );", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
            },
            r = new jr({
                name: "CubemapFromEquirect",
                uniforms: Br(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: 1,
                blending: 0
            });
        r.uniforms.tEquirect.value = e;
        const o = new Ar(new Ur(5, 5, 5), r);
        n.add(o);
        return new Vr(1, 10, this).update(t, n), o.geometry.dispose(), o.material.dispose(), this
    }, qr.prototype = Object.create(hn.prototype), qr.prototype.constructor = qr, qr.prototype.isDataTexture = !0;
    const Xr = new ci,
        Zr = new yn;

    function Yr(t, e, n, i, r, o) {
        this.planes = [void 0 !== t ? t : new xi, void 0 !== e ? e : new xi, void 0 !== n ? n : new xi, void 0 !== i ? i : new xi, void 0 !== r ? r : new xi, void 0 !== o ? o : new xi]
    }
    Object.assign(Yr.prototype, {
        set: function(t, e, n, i, r, o) {
            const s = this.planes;
            return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this
        },
        setFromProjectionMatrix: function(t) {
            const e = this.planes,
                n = t.elements,
                i = n[0],
                r = n[1],
                o = n[2],
                s = n[3],
                a = n[4],
                c = n[5],
                l = n[6],
                u = n[7],
                h = n[8],
                p = n[9],
                f = n[10],
                d = n[11],
                m = n[12],
                g = n[13],
                v = n[14],
                y = n[15];
            return e[0].setComponents(s - i, u - a, d - h, y - m).normalize(), e[1].setComponents(s + i, u + a, d + h, y + m).normalize(), e[2].setComponents(s + r, u + c, d + p, y + g).normalize(), e[3].setComponents(s - r, u - c, d - p, y - g).normalize(), e[4].setComponents(s - o, u - l, d - f, y - v).normalize(), e[5].setComponents(s + o, u + l, d + f, y + v).normalize(), this
        },
        intersectsObject: function(t) {
            const e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(), Xr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Xr)
        },
        intersectsSprite: function(t) {
            return Xr.center.set(0, 0, 0), Xr.radius = .7071067811865476, Xr.applyMatrix4(t.matrixWorld), this.intersectsSphere(Xr)
        },
        intersectsSphere: function(t) {
            const e = this.planes,
                n = t.center,
                i = -t.radius;
            for (let t = 0; t < 6; t++) {
                if (e[t].distanceToPoint(n) < i) return !1
            }
            return !0
        },
        intersectsBox: function(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = e[n];
                if (Zr.x = i.normal.x > 0 ? t.max.x : t.min.x, Zr.y = i.normal.y > 0 ? t.max.y : t.min.y, Zr.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Zr) < 0) return !1
            }
            return !0
        },
        containsPoint: function(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0) return !1;
            return !0
        }
    });
    const $r = {
        common: {
            diffuse: {
                value: new Ni(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new an
            },
            uv2Transform: {
                value: new an
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new sn(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Ni(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Ni(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new an
            }
        },
        sprite: {
            diffuse: {
                value: new Ni(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new sn(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new an
            }
        }
    };

    function Jr() {
        let t = null,
            e = !1,
            n = null,
            i = null;

        function r(e, o) {
            n(e, o), i = t.requestAnimationFrame(r)
        }
        return {
            start: function() {
                !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
            },
            stop: function() {
                t.cancelAnimationFrame(i), e = !1
            },
            setAnimationLoop: function(t) {
                n = t
            },
            setContext: function(e) {
                t = e
            }
        }
    }

    function Kr(t, e) {
        const n = e.isWebGL2,
            i = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
            },
            remove: function(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                const n = i.get(e);
                n && (t.deleteBuffer(n.buffer), i.delete(e))
            },
            update: function(e, r) {
                e.isInterleavedBufferAttribute && (e = e.data);
                const o = i.get(e);
                void 0 === o ? i.set(e, function(e, n) {
                    const i = e.array,
                        r = e.usage,
                        o = t.createBuffer();
                    t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback();
                    let s = 5126;
                    return i instanceof Float32Array ? s = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? s = 5123 : i instanceof Int16Array ? s = 5122 : i instanceof Uint32Array ? s = 5125 : i instanceof Int32Array ? s = 5124 : i instanceof Int8Array ? s = 5120 : i instanceof Uint8Array && (s = 5121), {
                        buffer: o,
                        type: s,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, r)) : o.version < e.version && (! function(e, i, r) {
                    const o = i.array,
                        s = i.updateRange;
                    t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1)
                }(o.buffer, e, r), o.version = e.version)
            }
        }
    }

    function Qr(t, e, n, i) {
        Nr.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        }, this.fromBufferGeometry(new to(t, e, n, i)), this.mergeVertices()
    }

    function to(t, e, n, i) {
        ur.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        const r = (t = t || 1) / 2,
            o = (e = e || 1) / 2,
            s = Math.floor(n) || 1,
            a = Math.floor(i) || 1,
            c = s + 1,
            l = a + 1,
            u = t / s,
            h = e / a,
            p = [],
            f = [],
            d = [],
            m = [];
        for (let t = 0; t < l; t++) {
            const e = t * h - o;
            for (let n = 0; n < c; n++) {
                const i = n * u - r;
                f.push(i, -e, 0), d.push(0, 0, 1), m.push(n / s), m.push(1 - t / a)
            }
        }
        for (let t = 0; t < a; t++)
            for (let e = 0; e < s; e++) {
                const n = e + c * t,
                    i = e + c * (t + 1),
                    r = e + 1 + c * (t + 1),
                    o = e + 1 + c * t;
                p.push(n, i, o), p.push(i, r, o)
            }
        this.setIndex(p), this.setAttribute("position", new Qi(f, 3)), this.setAttribute("normal", new Qi(d, 3)), this.setAttribute("uv", new Qi(m, 2))
    }
    Qr.prototype = Object.create(Nr.prototype), Qr.prototype.constructor = Qr, to.prototype = Object.create(ur.prototype), to.prototype.constructor = to;
    const eo = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        },
        no = {
            basic: {
                uniforms: zr([$r.common, $r.specularmap, $r.envmap, $r.aomap, $r.lightmap, $r.fog]),
                vertexShader: eo.meshbasic_vert,
                fragmentShader: eo.meshbasic_frag
            },
            lambert: {
                uniforms: zr([$r.common, $r.specularmap, $r.envmap, $r.aomap, $r.lightmap, $r.emissivemap, $r.fog, $r.lights, {
                    emissive: {
                        value: new Ni(0)
                    }
                }]),
                vertexShader: eo.meshlambert_vert,
                fragmentShader: eo.meshlambert_frag
            },
            phong: {
                uniforms: zr([$r.common, $r.specularmap, $r.envmap, $r.aomap, $r.lightmap, $r.emissivemap, $r.bumpmap, $r.normalmap, $r.displacementmap, $r.fog, $r.lights, {
                    emissive: {
                        value: new Ni(0)
                    },
                    specular: {
                        value: new Ni(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: eo.meshphong_vert,
                fragmentShader: eo.meshphong_frag
            },
            standard: {
                uniforms: zr([$r.common, $r.envmap, $r.aomap, $r.lightmap, $r.emissivemap, $r.bumpmap, $r.normalmap, $r.displacementmap, $r.roughnessmap, $r.metalnessmap, $r.fog, $r.lights, {
                    emissive: {
                        value: new Ni(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: eo.meshphysical_vert,
                fragmentShader: eo.meshphysical_frag
            },
            toon: {
                uniforms: zr([$r.common, $r.aomap, $r.lightmap, $r.emissivemap, $r.bumpmap, $r.normalmap, $r.displacementmap, $r.gradientmap, $r.fog, $r.lights, {
                    emissive: {
                        value: new Ni(0)
                    }
                }]),
                vertexShader: eo.meshtoon_vert,
                fragmentShader: eo.meshtoon_frag
            },
            matcap: {
                uniforms: zr([$r.common, $r.bumpmap, $r.normalmap, $r.displacementmap, $r.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: eo.meshmatcap_vert,
                fragmentShader: eo.meshmatcap_frag
            },
            points: {
                uniforms: zr([$r.points, $r.fog]),
                vertexShader: eo.points_vert,
                fragmentShader: eo.points_frag
            },
            dashed: {
                uniforms: zr([$r.common, $r.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: eo.linedashed_vert,
                fragmentShader: eo.linedashed_frag
            },
            depth: {
                uniforms: zr([$r.common, $r.displacementmap]),
                vertexShader: eo.depth_vert,
                fragmentShader: eo.depth_frag
            },
            normal: {
                uniforms: zr([$r.common, $r.bumpmap, $r.normalmap, $r.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: eo.normal_vert,
                fragmentShader: eo.normal_frag
            },
            sprite: {
                uniforms: zr([$r.sprite, $r.fog]),
                vertexShader: eo.sprite_vert,
                fragmentShader: eo.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new an
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: eo.background_vert,
                fragmentShader: eo.background_frag
            },
            cube: {
                uniforms: zr([$r.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: eo.cube_vert,
                fragmentShader: eo.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: eo.equirect_vert,
                fragmentShader: eo.equirect_frag
            },
            distanceRGBA: {
                uniforms: zr([$r.common, $r.displacementmap, {
                    referencePosition: {
                        value: new yn
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: eo.distanceRGBA_vert,
                fragmentShader: eo.distanceRGBA_frag
            },
            shadow: {
                uniforms: zr([$r.lights, $r.fog, {
                    color: {
                        value: new Ni(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: eo.shadow_vert,
                fragmentShader: eo.shadow_frag
            }
        };

    function io(t, e, n, i) {
        const r = new Ni(0);
        let o, s, a = 0,
            c = null,
            l = 0,
            u = null;

        function h(t, n) {
            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
        }
        return {
            getClearColor: function() {
                return r
            },
            setClearColor: function(t, e) {
                r.set(t), a = void 0 !== e ? e : 1, h(r, a)
            },
            getClearAlpha: function() {
                return a
            },
            setClearAlpha: function(t) {
                a = t, h(r, a)
            },
            render: function(e, i, p, f) {
                let d = !0 === i.isScene ? i.background : null;
                const m = t.xr,
                    g = m.getSession && m.getSession();
                if (g && "additive" === g.environmentBlendMode && (d = null), null === d ? h(r, a) : d && d.isColor && (h(d, 1), f = !0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && (d.isCubeTexture || d.isWebGLCubeRenderTarget || 306 === d.mapping)) {
                    void 0 === s && (s = new Ar(new Ur(1, 1, 1), new jr({
                        name: "BackgroundCubeMaterial",
                        uniforms: Br(no.cube.uniforms),
                        vertexShader: no.cube.vertexShader,
                        fragmentShader: no.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), s.geometry.deleteAttribute("normal"), s.geometry.deleteAttribute("uv"), s.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(s.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), n.update(s));
                    const i = d.isWebGLCubeRenderTarget ? d.texture : d;
                    s.material.uniforms.envMap.value = i, s.material.uniforms.flipEnvMap.value = i.isCubeTexture ? -1 : 1, c === d && l === i.version && u === t.toneMapping || (s.material.needsUpdate = !0, c = d, l = i.version, u = t.toneMapping), e.unshift(s, s.geometry, s.material, 0, 0, null)
                } else d && d.isTexture && (void 0 === o && (o = new Ar(new to(2, 2), new jr({
                    name: "BackgroundMaterial",
                    uniforms: Br(no.background.uniforms),
                    vertexShader: no.background.vertexShader,
                    fragmentShader: no.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), n.update(o)), o.material.uniforms.t2D.value = d, !0 === d.matrixAutoUpdate && d.updateMatrix(), o.material.uniforms.uvTransform.value.copy(d.matrix), c === d && l === d.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = d, l = d.version, u = t.toneMapping), e.unshift(o, o.geometry, o.material, 0, 0, null))
            }
        }
    }

    function ro(t, e, n, i) {
        const r = t.getParameter(34921),
            o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            s = i.isWebGL2 || null !== o,
            a = {},
            c = p(null);
        let l = c;

        function u(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
        }

        function h(e) {
            return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
        }

        function p(t) {
            const e = [],
                n = [],
                i = [];
            for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: e,
                enabledAttributes: n,
                attributeDivisors: i,
                object: t,
                attributes: {}
            }
        }

        function f() {
            const t = l.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0
        }

        function d(t) {
            m(t, 0)
        }

        function m(n, r) {
            const o = l.newAttributes,
                s = l.enabledAttributes,
                a = l.attributeDivisors;
            if (o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== r) {
                (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r
            }
        }

        function g() {
            const e = l.newAttributes,
                n = l.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
        }

        function v(e, n, r, o, s, a) {
            !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, o, s, a)
        }

        function y() {
            b(), l !== c && (l = c, u(l.object))
        }

        function b() {
            c.geometry = null, c.program = null, c.wireframe = !1
        }
        return {
            setup: function(r, c, h, y, b) {
                let x = !1;
                if (s) {
                    const e = function(e, n, r) {
                        const s = !0 === r.wireframe;
                        let c = a[e.id];
                        void 0 === c && (c = {}, a[e.id] = c);
                        let l = c[n.id];
                        void 0 === l && (l = {}, c[n.id] = l);
                        let u = l[s];
                        void 0 === u && (u = p(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), l[s] = u);
                        return u
                    }(y, h, c);
                    l !== e && (l = e, u(l.object)), x = function(t) {
                        const e = l.attributes,
                            n = t.attributes;
                        if (Object.keys(e).length !== Object.keys(n).length) return !0;
                        for (const t in n) {
                            const i = e[t],
                                r = n[t];
                            if (i.attribute !== r) return !0;
                            if (i.data !== r.data) return !0
                        }
                        return !1
                    }(y), x && function(t) {
                        const e = {},
                            n = t.attributes;
                        for (const t in n) {
                            const i = n[t],
                                r = {};
                            r.attribute = i, i.data && (r.data = i.data), e[t] = r
                        }
                        l.attributes = e
                    }(y)
                } else {
                    const t = !0 === c.wireframe;
                    l.geometry === y.id && l.program === h.id && l.wireframe === t || (l.geometry = y.id, l.program = h.id, l.wireframe = t, x = !0)
                }!0 === r.isInstancedMesh && (x = !0), null !== b && n.update(b, 34963), x && (! function(r, o, s, a) {
                    if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                    f();
                    const c = a.attributes,
                        l = s.getAttributes(),
                        u = o.defaultAttributeValues;
                    for (const e in l) {
                        const i = l[e];
                        if (i >= 0) {
                            const o = c[e];
                            if (void 0 !== o) {
                                const e = o.normalized,
                                    r = o.itemSize,
                                    s = n.get(o);
                                if (void 0 === s) continue;
                                const c = s.buffer,
                                    l = s.type,
                                    u = s.bytesPerElement;
                                if (o.isInterleavedBufferAttribute) {
                                    const n = o.data,
                                        s = n.stride,
                                        h = o.offset;
                                    n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : d(i), t.bindBuffer(34962, c), v(i, r, l, e, s * u, h * u)
                                } else o.isInstancedBufferAttribute ? (m(i, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : d(i), t.bindBuffer(34962, c), v(i, r, l, e, 0, 0)
                            } else if ("instanceMatrix" === e) {
                                const e = n.get(r.instanceMatrix);
                                if (void 0 === e) continue;
                                const o = e.buffer,
                                    s = e.type;
                                m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48)
                            } else if (void 0 !== u) {
                                const n = u[e];
                                if (void 0 !== n) switch (n.length) {
                                    case 2:
                                        t.vertexAttrib2fv(i, n);
                                        break;
                                    case 3:
                                        t.vertexAttrib3fv(i, n);
                                        break;
                                    case 4:
                                        t.vertexAttrib4fv(i, n);
                                        break;
                                    default:
                                        t.vertexAttrib1fv(i, n)
                                }
                            }
                        }
                    }
                    g()
                }(r, c, h, y), null !== b && t.bindBuffer(34963, n.get(b).buffer))
            },
            reset: y,
            resetDefaultState: b,
            dispose: function() {
                y();
                for (const t in a) {
                    const e = a[t];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) h(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete a[t]
                }
            },
            releaseStatesOfGeometry: function(t) {
                if (void 0 === a[t.id]) return;
                const e = a[t.id];
                for (const t in e) {
                    const n = e[t];
                    for (const t in n) h(n[t].object), delete n[t];
                    delete e[t]
                }
                delete a[t.id]
            },
            releaseStatesOfProgram: function(t) {
                for (const e in a) {
                    const n = a[e];
                    if (void 0 === n[t.id]) continue;
                    const i = n[t.id];
                    for (const t in i) h(i[t].object), delete i[t];
                    delete n[t.id]
                }
            },
            initAttributes: f,
            enableAttribute: d,
            disableUnusedAttributes: g
        }
    }

    function oo(t, e, n, i) {
        const r = i.isWebGL2;
        let o;
        this.setMode = function(t) {
            o = t
        }, this.render = function(e, i) {
            t.drawArrays(o, e, i), n.update(i, o)
        }, this.renderInstances = function(i, s, a, c) {
            if (0 === c) return;
            let l, u;
            if (r) l = t, u = "drawArraysInstanced";
            else if (l = e.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[u](o, s, a, c), n.update(a, o, c)
        }
    }

    function so(t, e, n) {
        let i;

        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
        let s = void 0 !== n.precision ? n.precision : "highp";
        const a = r(s);
        a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
        const c = !0 === n.logarithmicDepthBuffer,
            l = t.getParameter(34930),
            u = t.getParameter(35660),
            h = t.getParameter(3379),
            p = t.getParameter(34076),
            f = t.getParameter(34921),
            d = t.getParameter(36347),
            m = t.getParameter(36348),
            g = t.getParameter(36349),
            v = u > 0,
            y = o || !!e.get("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function() {
                if (void 0 !== i) return i;
                const n = e.get("EXT_texture_filter_anisotropic");
                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, i
            },
            getMaxPrecision: r,
            precision: s,
            logarithmicDepthBuffer: c,
            maxTextures: l,
            maxVertexTextures: u,
            maxTextureSize: h,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: d,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: o ? t.getParameter(36183) : 0
        }
    }

    function ao() {
        const t = this;
        let e = null,
            n = 0,
            i = !1,
            r = !1;
        const o = new xi,
            s = new an,
            a = {
                value: null,
                needsUpdate: !1
            };

        function c() {
            a.value !== e && (a.value = e, a.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
        }

        function l(e, n, i, r) {
            let c = null !== e ? e.length : 0,
                l = null;
            if (0 !== c) {
                if (l = a.value, !0 !== r || null === l) {
                    const t = i + 4 * c,
                        r = n.matrixWorldInverse;
                    s.getNormalMatrix(r), (null === l || l.length < t) && (l = new Float32Array(t));
                    for (let t = 0, n = i; t !== c; ++t, n += 4) o.copy(e[t]).applyMatrix4(r, s), o.normal.toArray(l, n), l[n + 3] = o.constant
                }
                a.value = l, a.needsUpdate = !0
            }
            return t.numPlanes = c, t.numIntersection = 0, l
        }
        this.uniform = a, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, o) {
            const s = 0 !== t.length || r || 0 !== n || i;
            return i = r, e = l(t, o, 0), n = t.length, s
        }, this.beginShadows = function() {
            r = !0, l(null)
        }, this.endShadows = function() {
            r = !1, c()
        }, this.setState = function(t, o, s, u, h, p) {
            if (!i || null === t || 0 === t.length || r && !s) r ? l(null) : c();
            else {
                const i = r ? 0 : n,
                    s = 4 * i;
                let c = h.clippingState || null;
                a.value = c, c = l(t, u, s, p);
                for (let t = 0; t !== s; ++t) c[t] = e[t];
                h.clippingState = c, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += i
            }
        }
    }

    function co(t) {
        const e = {};
        return {
            get: function(n) {
                if (void 0 !== e[n]) return e[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
            }
        }
    }

    function lo(t, e, n, i) {
        const r = new WeakMap,
            o = new WeakMap;

        function s(t) {
            const a = t.target,
                c = r.get(a);
            null !== c.index && e.remove(c.index);
            for (const t in c.attributes) e.remove(c.attributes[t]);
            a.removeEventListener("dispose", s), r.delete(a);
            const l = o.get(c);
            l && (e.remove(l), o.delete(c)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
        }

        function a(t) {
            const n = [],
                i = t.index,
                r = t.attributes.position;
            let s = 0;
            if (null !== i) {
                const t = i.array;
                s = i.version;
                for (let e = 0, i = t.length; e < i; e += 3) {
                    const i = t[e + 0],
                        r = t[e + 1],
                        o = t[e + 2];
                    n.push(i, r, r, o, o, i)
                }
            } else {
                const t = r.array;
                s = r.version;
                for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                    const t = e + 0,
                        i = e + 1,
                        r = e + 2;
                    n.push(t, i, i, r, r, t)
                }
            }
            const a = new(nr(n) > 65535 ? Ki : $i)(n, 1);
            a.version = s;
            const c = o.get(t);
            c && e.remove(c), o.set(t, a)
        }
        return {
            get: function(t, e) {
                let i = r.get(e);
                return i || (e.addEventListener("dispose", s), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new ur).setFromObject(t)), i = e._bufferGeometry), r.set(e, i), n.memory.geometries++, i)
            },
            update: function(t) {
                const n = t.attributes;
                for (const t in n) e.update(n[t], 34962);
                const i = t.morphAttributes;
                for (const t in i) {
                    const n = i[t];
                    for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
                }
            },
            getWireframeAttribute: function(t) {
                const e = o.get(t);
                if (e) {
                    const n = t.index;
                    null !== n && e.version < n.version && a(t)
                } else a(t);
                return o.get(t)
            }
        }
    }

    function uo(t, e, n, i) {
        const r = i.isWebGL2;
        let o, s, a;
        this.setMode = function(t) {
            o = t
        }, this.setIndex = function(t) {
            s = t.type, a = t.bytesPerElement
        }, this.render = function(e, i) {
            t.drawElements(o, i, s, e * a), n.update(i, o)
        }, this.renderInstances = function(i, c, l, u) {
            if (0 === u) return;
            let h, p;
            if (r) h = t, p = "drawElementsInstanced";
            else if (h = e.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[p](o, l, s, c * a, u), n.update(l, o, u)
        }
    }

    function ho(t) {
        const e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function() {
                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
            },
            update: function(t, n, i) {
                switch (i = i || 1, e.calls++, n) {
                    case 4:
                        e.triangles += i * (t / 3);
                        break;
                    case 1:
                        e.lines += i * (t / 2);
                        break;
                    case 3:
                        e.lines += i * (t - 1);
                        break;
                    case 2:
                        e.lines += i * t;
                        break;
                    case 0:
                        e.points += i * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }

    function po(t, e) {
        return t[0] - e[0]
    }

    function fo(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function mo(t) {
        const e = {},
            n = new Float32Array(8),
            i = [];
        for (let t = 0; t < 8; t++) i[t] = [t, 0];
        return {
            update: function(r, o, s, a) {
                const c = r.morphTargetInfluences,
                    l = void 0 === c ? 0 : c.length;
                let u = e[o.id];
                if (void 0 === u) {
                    u = [];
                    for (let t = 0; t < l; t++) u[t] = [t, 0];
                    e[o.id] = u
                }
                for (let t = 0; t < l; t++) {
                    const e = u[t];
                    e[0] = t, e[1] = c[t]
                }
                u.sort(fo);
                for (let t = 0; t < 8; t++) t < l && u[t][1] ? (i[t][0] = u[t][0], i[t][1] = u[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);
                i.sort(po);
                const h = s.morphTargets && o.morphAttributes.position,
                    p = s.morphNormals && o.morphAttributes.normal;
                let f = 0;
                for (let t = 0; t < 8; t++) {
                    const e = i[t],
                        r = e[0],
                        s = e[1];
                    r !== Number.MAX_SAFE_INTEGER && s ? (h && o.getAttribute("morphTarget" + t) !== h[r] && o.setAttribute("morphTarget" + t, h[r]), p && o.getAttribute("morphNormal" + t) !== p[r] && o.setAttribute("morphNormal" + t, p[r]), n[t] = s, f += s) : (h && void 0 !== o.getAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), p && void 0 !== o.getAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0)
                }
                const d = o.morphTargetsRelative ? 1 : 1 - f;
                a.getUniforms().setValue(t, "morphTargetBaseInfluence", d), a.getUniforms().setValue(t, "morphTargetInfluences", n)
            }
        }
    }

    function go(t, e, n, i) {
        let r = new WeakMap;
        return {
            update: function(t) {
                const o = i.render.frame,
                    s = t.geometry,
                    a = e.get(t, s);
                return r.get(a) !== o && (s.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, o)), t.isInstancedMesh && n.update(t.instanceMatrix, 34962), a
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }

    function vo(t, e, n, i, r, o, s, a, c, l) {
        t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, s = void 0 !== s ? s : 1022, hn.call(this, t, e, n, i, r, o, s, a, c, l), this.flipY = !1
    }

    function yo(t, e, n, i) {
        hn.call(this, null), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }

    function bo(t, e, n, i) {
        hn.call(this, null), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }
    no.physical = {
        uniforms: zr([no.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new sn(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Ni(0)
            },
            transparency: {
                value: 0
            }
        }]),
        vertexShader: eo.meshphysical_vert,
        fragmentShader: eo.meshphysical_frag
    }, vo.prototype = Object.create(hn.prototype), vo.prototype.constructor = vo, vo.prototype.isCubeTexture = !0, Object.defineProperty(vo.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    }), yo.prototype = Object.create(hn.prototype), yo.prototype.constructor = yo, yo.prototype.isDataTexture2DArray = !0, bo.prototype = Object.create(hn.prototype), bo.prototype.constructor = bo, bo.prototype.isDataTexture3D = !0;
    const xo = new hn,
        wo = new yo,
        _o = new bo,
        Mo = new vo,
        So = [],
        To = [],
        Eo = new Float32Array(16),
        Co = new Float32Array(9),
        Ao = new Float32Array(4);

    function Lo(t, e, n) {
        const i = t[0];
        if (i <= 0 || i > 0) return t;
        let r = e * n,
            o = So[r];
        if (void 0 === o && (o = new Float32Array(r), So[r] = o), 0 !== e) {
            i.toArray(o, 0);
            for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(o, r)
        }
        return o
    }

    function Po(t, e) {
        if (t.length !== e.length) return !1;
        for (let n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }

    function Oo(t, e) {
        for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
    }

    function Ro(t, e) {
        let n = To[e];
        void 0 === n && (n = new Int32Array(e), To[e] = n);
        for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
        return n
    }

    function Io(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
    }

    function Do(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
        else {
            if (Po(n, e)) return;
            t.uniform2fv(this.addr, e), Oo(n, e)
        }
    }

    function No(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
        else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
        else {
            if (Po(n, e)) return;
            t.uniform3fv(this.addr, e), Oo(n, e)
        }
    }

    function ko(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
        else {
            if (Po(n, e)) return;
            t.uniform4fv(this.addr, e), Oo(n, e)
        }
    }

    function Uo(t, e) {
        const n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Po(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), Oo(n, e)
        } else {
            if (Po(n, i)) return;
            Ao.set(i), t.uniformMatrix2fv(this.addr, !1, Ao), Oo(n, i)
        }
    }

    function Bo(t, e) {
        const n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Po(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), Oo(n, e)
        } else {
            if (Po(n, i)) return;
            Co.set(i), t.uniformMatrix3fv(this.addr, !1, Co), Oo(n, i)
        }
    }

    function zo(t, e) {
        const n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Po(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), Oo(n, e)
        } else {
            if (Po(n, i)) return;
            Eo.set(i), t.uniformMatrix4fv(this.addr, !1, Eo), Oo(n, i)
        }
    }

    function Fo(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || xo, r)
    }

    function jo(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || wo, r)
    }

    function Ho(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || _o, r)
    }

    function Go(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Mo, r)
    }

    function Vo(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
    }

    function Wo(t, e) {
        const n = this.cache;
        Po(n, e) || (t.uniform2iv(this.addr, e), Oo(n, e))
    }

    function qo(t, e) {
        const n = this.cache;
        Po(n, e) || (t.uniform3iv(this.addr, e), Oo(n, e))
    }

    function Xo(t, e) {
        const n = this.cache;
        Po(n, e) || (t.uniform4iv(this.addr, e), Oo(n, e))
    }

    function Zo(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
    }

    function Yo(t, e) {
        t.uniform1fv(this.addr, e)
    }

    function $o(t, e) {
        t.uniform1iv(this.addr, e)
    }

    function Jo(t, e) {
        t.uniform2iv(this.addr, e)
    }

    function Ko(t, e) {
        t.uniform3iv(this.addr, e)
    }

    function Qo(t, e) {
        t.uniform4iv(this.addr, e)
    }

    function ts(t, e) {
        const n = Lo(e, this.size, 2);
        t.uniform2fv(this.addr, n)
    }

    function es(t, e) {
        const n = Lo(e, this.size, 3);
        t.uniform3fv(this.addr, n)
    }

    function ns(t, e) {
        const n = Lo(e, this.size, 4);
        t.uniform4fv(this.addr, n)
    }

    function is(t, e) {
        const n = Lo(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n)
    }

    function rs(t, e) {
        const n = Lo(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n)
    }

    function os(t, e) {
        const n = Lo(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n)
    }

    function ss(t, e, n) {
        const i = e.length,
            r = Ro(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || xo, r[t])
    }

    function as(t, e, n) {
        const i = e.length,
            r = Ro(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Mo, r[t])
    }

    function cs(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
            switch (t) {
                case 5126:
                    return Io;
                case 35664:
                    return Do;
                case 35665:
                    return No;
                case 35666:
                    return ko;
                case 35674:
                    return Uo;
                case 35675:
                    return Bo;
                case 35676:
                    return zo;
                case 5124:
                case 35670:
                    return Vo;
                case 35667:
                case 35671:
                    return Wo;
                case 35668:
                case 35672:
                    return qo;
                case 35669:
                case 35673:
                    return Xo;
                case 5125:
                    return Zo;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Fo;
                case 35679:
                case 36299:
                case 36307:
                    return Ho;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Go;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return jo
            }
        }(e.type)
    }

    function ls(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
            switch (t) {
                case 5126:
                    return Yo;
                case 35664:
                    return ts;
                case 35665:
                    return es;
                case 35666:
                    return ns;
                case 35674:
                    return is;
                case 35675:
                    return rs;
                case 35676:
                    return os;
                case 5124:
                case 35670:
                    return $o;
                case 35667:
                case 35671:
                    return Jo;
                case 35668:
                case 35672:
                    return Ko;
                case 35669:
                case 35673:
                    return Qo;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return ss;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return as
            }
        }(e.type)
    }

    function us(t) {
        this.id = t, this.seq = [], this.map = {}
    }
    ls.prototype.updateCache = function(t) {
        let e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Oo(e, t)
    }, us.prototype.setValue = function(t, e, n) {
        const i = this.seq;
        for (let r = 0, o = i.length; r !== o; ++r) {
            const o = i[r];
            o.setValue(t, e[o.id], n)
        }
    };
    const hs = /([\w\d_]+)(\])?(\[|\.)?/g;

    function ps(t, e) {
        t.seq.push(e), t.map[e.id] = e
    }

    function fs(t, e, n) {
        const i = t.name,
            r = i.length;
        for (hs.lastIndex = 0;;) {
            const o = hs.exec(i),
                s = hs.lastIndex;
            let a = o[1],
                c = "]" === o[2],
                l = o[3];
            if (c && (a |= 0), void 0 === l || "[" === l && s + 2 === r) {
                ps(n, void 0 === l ? new cs(a, t, e) : new ls(a, t, e));
                break
            } {
                let t = n.map[a];
                void 0 === t && (t = new us(a), ps(n, t)), n = t
            }
        }
    }

    function ds(t, e) {
        this.seq = [], this.map = {};
        const n = t.getProgramParameter(e, 35718);
        for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i);
            fs(n, t.getUniformLocation(e, n.name), this)
        }
    }

    function ms(t, e, n) {
        const i = t.createShader(e);
        return t.shaderSource(i, n), t.compileShader(i), i
    }
    ds.prototype.setValue = function(t, e, n, i) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, n, i)
    }, ds.prototype.setOptional = function(t, e, n) {
        const i = e[n];
        void 0 !== i && this.setValue(t, n, i)
    }, ds.upload = function(t, e, n, i) {
        for (let r = 0, o = e.length; r !== o; ++r) {
            const o = e[r],
                s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(t, s.value, i)
        }
    }, ds.seqWithValue = function(t, e) {
        const n = [];
        for (let i = 0, r = t.length; i !== r; ++i) {
            const r = t[i];
            r.id in e && n.push(r)
        }
        return n
    };
    let gs = 0;

    function vs(t) {
        switch (t) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
                return ["LogLuv", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
        }
    }

    function ys(t, e, n) {
        const i = t.getShaderParameter(e, 35713),
            r = t.getShaderInfoLog(e).trim();
        if (i && "" === r) return "";
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
            const e = t.split("\n");
            for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(t.getShaderSource(e))
    }

    function bs(t, e) {
        const n = vs(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function xs(t, e) {
        const n = vs(e);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }

    function ws(t, e) {
        let n;
        switch (e) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "OptimizedCineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
        }
        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function _s(t) {
        return "" !== t
    }

    function Ms(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }

    function Ss(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const Ts = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Es(t) {
        return t.replace(Ts, Cs)
    }

    function Cs(t, e) {
        const n = eo[e];
        if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
        return Es(n)
    }
    const As = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Ls = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

    function Ps(t) {
        return t.replace(Ls, Rs).replace(As, Os)
    }

    function Os(t, e, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Rs(t, e, n, i)
    }

    function Rs(t, e, n, i) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[ i \]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
        return r
    }

    function Is(t) {
        let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
    }

    function Ds(t, e, n, i) {
        const r = t.getContext(),
            o = n.defines;
        let s = n.vertexShader,
            a = n.fragmentShader;
        const c = function(t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
            }(n),
            l = function(t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap) switch (t.envMapMode) {
                    case 301:
                    case 302:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        e = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case 303:
                    case 304:
                        e = "ENVMAP_TYPE_EQUIREC"
                }
                return e
            }(n),
            u = function(t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap) switch (t.envMapMode) {
                    case 302:
                    case 304:
                        e = "ENVMAP_MODE_REFRACTION"
                }
                return e
            }(n),
            h = function(t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap) switch (t.combine) {
                    case 0:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        e = "ENVMAP_BLENDING_ADD"
                }
                return e
            }(n),
            p = t.gammaFactor > 0 ? t.gammaFactor : 1,
            f = n.isWebGL2 ? "" : function(t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(_s).join("\n")
            }(n),
            d = function(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(o),
            m = r.createProgram();
        let g, v;
        if (n.isRawShaderMaterial ? (g = [d].filter(_s).join("\n"), g.length > 0 && (g += "\n"), v = [f, d].filter(_s).join("\n"), v.length > 0 && (v += "\n")) : (g = [Is(n), "#define SHADER_NAME " + n.shaderName, d, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(_s).join("\n"), v = [f, Is(n), "#define SHADER_NAME " + n.shaderName, d, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? eo.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? ws("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", eo.encodings_pars_fragment, n.map ? bs("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? bs("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? bs("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? bs("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? bs("lightMapTexelToLinear", n.lightMapEncoding) : "", xs("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(_s).join("\n")), s = Es(s), s = Ms(s, n), s = Ss(s, n), a = Es(a), a = Ms(a, n), a = Ss(a, n), s = Ps(s), a = Ps(a), n.isWebGL2 && !n.isRawShaderMaterial) {
            let t = !1;
            const e = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== s.match(e) && null !== a.match(e) && (t = !0, s = s.replace(e, ""), a = a.replace(e, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#version 300 es\n", "#define varying in", t ? "" : "out highp vec4 pc_fragColor;", t ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v
        }
        const y = v + a,
            b = ms(r, 35633, g + s),
            x = ms(r, 35632, y);
        if (r.attachShader(m, b), r.attachShader(m, x), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
            const t = r.getProgramInfoLog(m).trim(),
                e = r.getShaderInfoLog(b).trim(),
                n = r.getShaderInfoLog(x).trim();
            let i = !0,
                o = !0;
            if (!1 === r.getProgramParameter(m, 35714)) {
                i = !1;
                const e = ys(r, b, "vertex"),
                    n = ys(r, x, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n)
            } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1);
            o && (this.diagnostics = {
                runnable: i,
                programLog: t,
                vertexShader: {
                    log: e,
                    prefix: g
                },
                fragmentShader: {
                    log: n,
                    prefix: v
                }
            })
        }
        let w, _;
        return r.deleteShader(b), r.deleteShader(x), this.getUniforms = function() {
            return void 0 === w && (w = new ds(r, m)), w
        }, this.getAttributes = function() {
            return void 0 === _ && (_ = function(t, e) {
                const n = {},
                    i = t.getProgramParameter(e, 35721);
                for (let r = 0; r < i; r++) {
                    const i = t.getActiveAttrib(e, r).name;
                    n[i] = t.getAttribLocation(e, i)
                }
                return n
            }(r, m)), _
        }, this.destroy = function() {
            i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
        }, this.name = n.shaderName, this.id = gs++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = b, this.fragmentShader = x, this
    }

    function Ns(t, e, n, i) {
        const r = [],
            o = n.isWebGL2,
            s = n.logarithmicDepthBuffer,
            a = n.floatVertexTextures,
            c = n.maxVertexUniforms,
            l = n.vertexTextures;
        let u = n.precision;
        const h = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            p = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

        function f(t) {
            let e;
            return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e
        }
        return {
            getParameters: function(i, r, p, d, m, g, v) {
                const y = d.fog,
                    b = i.isMeshStandardMaterial ? d.environment : null,
                    x = i.envMap || b,
                    w = h[i.type],
                    _ = v.isSkinnedMesh ? function(t) {
                        const e = t.skeleton.bones;
                        if (a) return 1024; {
                            const t = c,
                                n = Math.floor((t - 20) / 4),
                                i = Math.min(n, e.length);
                            return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                        }
                    }(v) : 0;
                null !== i.precision && (u = n.getMaxPrecision(i.precision), u !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", u, "instead."));
                const M = function(t, e) {
                    let n;
                    if (e) {
                        const i = no[e];
                        n = {
                            name: t.name || t.type,
                            uniforms: Fr.clone(i.uniforms),
                            vertexShader: i.vertexShader,
                            fragmentShader: i.fragmentShader
                        }
                    } else n = {
                        name: t.name || t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                    return n
                }(i, w);
                i.onBeforeCompile(M, t);
                const S = t.getRenderTarget();
                return {
                    isWebGL2: o,
                    shaderID: w,
                    shaderName: M.name,
                    uniforms: M.uniforms,
                    vertexShader: M.vertexShader,
                    fragmentShader: M.fragmentShader,
                    defines: i.defines,
                    isRawShaderMaterial: i.isRawShaderMaterial,
                    isShaderMaterial: i.isShaderMaterial,
                    precision: u,
                    instancing: !0 === v.isInstancedMesh,
                    supportsVertexTextures: l,
                    outputEncoding: null !== S ? f(S.texture) : t.outputEncoding,
                    map: !!i.map,
                    mapEncoding: f(i.map),
                    matcap: !!i.matcap,
                    matcapEncoding: f(i.matcap),
                    envMap: !!x,
                    envMapMode: x && x.mapping,
                    envMapEncoding: f(x),
                    envMapCubeUV: !!x && (306 === x.mapping || 307 === x.mapping),
                    lightMap: !!i.lightMap,
                    lightMapEncoding: f(i.lightMap),
                    aoMap: !!i.aoMap,
                    emissiveMap: !!i.emissiveMap,
                    emissiveMapEncoding: f(i.emissiveMap),
                    bumpMap: !!i.bumpMap,
                    normalMap: !!i.normalMap,
                    objectSpaceNormalMap: 1 === i.normalMapType,
                    tangentSpaceNormalMap: 0 === i.normalMapType,
                    clearcoatMap: !!i.clearcoatMap,
                    clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!i.clearcoatNormalMap,
                    displacementMap: !!i.displacementMap,
                    roughnessMap: !!i.roughnessMap,
                    metalnessMap: !!i.metalnessMap,
                    specularMap: !!i.specularMap,
                    alphaMap: !!i.alphaMap,
                    gradientMap: !!i.gradientMap,
                    sheen: !!i.sheen,
                    combine: i.combine,
                    vertexTangents: i.normalMap && i.vertexTangents,
                    vertexColors: i.vertexColors,
                    vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
                    uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
                    fog: !!y,
                    useFog: i.fog,
                    fogExp2: y && y.isFogExp2,
                    flatShading: i.flatShading,
                    sizeAttenuation: i.sizeAttenuation,
                    logarithmicDepthBuffer: s,
                    skinning: i.skinning && _ > 0,
                    maxBones: _,
                    useVertexTexture: a,
                    morphTargets: i.morphTargets,
                    morphNormals: i.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: r.directional.length,
                    numPointLights: r.point.length,
                    numSpotLights: r.spot.length,
                    numRectAreaLights: r.rectArea.length,
                    numHemiLights: r.hemi.length,
                    numDirLightShadows: r.directionalShadowMap.length,
                    numPointLightShadows: r.pointShadowMap.length,
                    numSpotLightShadows: r.spotShadowMap.length,
                    numClippingPlanes: m,
                    numClipIntersection: g,
                    dithering: i.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && p.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: i.toneMapped ? t.toneMapping : 0,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: i.premultipliedAlpha,
                    alphaTest: i.alphaTest,
                    doubleSided: 2 === i.side,
                    flipSided: 1 === i.side,
                    depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                    index0AttributeName: i.index0AttributeName,
                    extensionDerivatives: i.extensions && i.extensions.derivatives,
                    extensionFragDepth: i.extensions && i.extensions.fragDepth,
                    extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                    extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: o || null !== e.get("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: o || null !== e.get("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: o || null !== e.get("EXT_shader_texture_lod"),
                    customProgramCacheKey: i.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function(e) {
                const n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                    for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                if (void 0 === e.isRawShaderMaterial) {
                    for (let t = 0; t < p.length; t++) n.push(e[p[t]]);
                    n.push(t.outputEncoding), n.push(t.gammaFactor)
                }
                return n.push(e.customProgramCacheKey), n.join()
            },
            acquireProgram: function(e, n) {
                let o;
                for (let t = 0, e = r.length; t < e; t++) {
                    const e = r[t];
                    if (e.cacheKey === n) {
                        o = e, ++o.usedTimes;
                        break
                    }
                }
                return void 0 === o && (o = new Ds(t, n, e, i), r.push(o)), o
            },
            releaseProgram: function(t) {
                if (0 == --t.usedTimes) {
                    const e = r.indexOf(t);
                    r[e] = r[r.length - 1], r.pop(), t.destroy()
                }
            },
            programs: r
        }
    }

    function ks() {
        let t = new WeakMap;
        return {
            get: function(e) {
                let n = t.get(e);
                return void 0 === n && (n = {}, t.set(e, n)), n
            },
            remove: function(e) {
                t.delete(e)
            },
            update: function(e, n, i) {
                t.get(e)[n] = i
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }

    function Us(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function Bs(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function zs() {
        const t = [];
        let e = 0;
        const n = [],
            i = [],
            r = {
                id: -1
            };

        function o(n, i, o, s, a, c) {
            let l = t[e];
            return void 0 === l ? (l = {
                id: n.id,
                object: n,
                geometry: i,
                material: o,
                program: o.program || r,
                groupOrder: s,
                renderOrder: n.renderOrder,
                z: a,
                group: c
            }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = o, l.program = o.program || r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = c), e++, l
        }
        return {
            opaque: n,
            transparent: i,
            init: function() {
                e = 0, n.length = 0, i.length = 0
            },
            push: function(t, e, r, s, a, c) {
                const l = o(t, e, r, s, a, c);
                (!0 === r.transparent ? i : n).push(l)
            },
            unshift: function(t, e, r, s, a, c) {
                const l = o(t, e, r, s, a, c);
                (!0 === r.transparent ? i : n).unshift(l)
            },
            finish: function() {
                for (let n = e, i = t.length; n < i; n++) {
                    const e = t[n];
                    if (null === e.id) break;
                    e.id = null, e.object = null, e.geometry = null, e.material = null, e.program = null, e.group = null
                }
            },
            sort: function(t, e) {
                n.length > 1 && n.sort(t || Us), i.length > 1 && i.sort(e || Bs)
            }
        }
    }

    function Fs() {
        let t = new WeakMap;

        function e(n) {
            const i = n.target;
            i.removeEventListener("dispose", e), t.delete(i)
        }
        return {
            get: function(n, i) {
                const r = t.get(n);
                let o;
                return void 0 === r ? (o = new zs, t.set(n, new WeakMap), t.get(n).set(i, o), n.addEventListener("dispose", e)) : (o = r.get(i), void 0 === o && (o = new zs, r.set(i, o))), o
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }

    function js() {
        const t = {};
        return {
            get: function(e) {
                if (void 0 !== t[e.id]) return t[e.id];
                let n;
                switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new yn,
                            color: new Ni
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new yn,
                            direction: new yn,
                            color: new Ni,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new yn,
                            color: new Ni,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new yn,
                            skyColor: new Ni,
                            groundColor: new Ni
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Ni,
                            position: new yn,
                            halfWidth: new yn,
                            halfHeight: new yn
                        }
                }
                return t[e.id] = n, n
            }
        }
    }
    let Hs = 0;

    function Gs(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }

    function Vs() {
        const t = new js,
            e = function() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new sn
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new sn,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            }(),
            n = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
        for (let t = 0; t < 9; t++) n.probe.push(new yn);
        const i = new yn,
            r = new En,
            o = new En;
        return {
            setup: function(s, a, c) {
                let l = 0,
                    u = 0,
                    h = 0;
                for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);
                let p = 0,
                    f = 0,
                    d = 0,
                    m = 0,
                    g = 0,
                    v = 0,
                    y = 0,
                    b = 0;
                const x = c.matrixWorldInverse;
                s.sort(Gs);
                for (let a = 0, c = s.length; a < c; a++) {
                    const c = s[a],
                        w = c.color,
                        _ = c.intensity,
                        M = c.distance,
                        S = c.shadow && c.shadow.map ? c.shadow.map.texture : null;
                    if (c.isAmbientLight) l += w.r * _, u += w.g * _, h += w.b * _;
                    else if (c.isLightProbe)
                        for (let t = 0; t < 9; t++) n.probe[t].addScaledVector(c.sh.coefficients[t], _);
                    else if (c.isDirectionalLight) {
                        const r = t.get(c);
                        if (r.color.copy(c.color).multiplyScalar(c.intensity), r.direction.setFromMatrixPosition(c.matrixWorld), i.setFromMatrixPosition(c.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(x), c.castShadow) {
                            const t = c.shadow,
                                i = e.get(c);
                            i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.directionalShadow[p] = i, n.directionalShadowMap[p] = S, n.directionalShadowMatrix[p] = c.shadow.matrix, v++
                        }
                        n.directional[p] = r, p++
                    } else if (c.isSpotLight) {
                        const r = t.get(c);
                        if (r.position.setFromMatrixPosition(c.matrixWorld), r.position.applyMatrix4(x), r.color.copy(w).multiplyScalar(_), r.distance = M, r.direction.setFromMatrixPosition(c.matrixWorld), i.setFromMatrixPosition(c.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(x), r.coneCos = Math.cos(c.angle), r.penumbraCos = Math.cos(c.angle * (1 - c.penumbra)), r.decay = c.decay, c.castShadow) {
                            const t = c.shadow,
                                i = e.get(c);
                            i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.spotShadow[d] = i, n.spotShadowMap[d] = S, n.spotShadowMatrix[d] = c.shadow.matrix, b++
                        }
                        n.spot[d] = r, d++
                    } else if (c.isRectAreaLight) {
                        const e = t.get(c);
                        e.color.copy(w).multiplyScalar(_), e.position.setFromMatrixPosition(c.matrixWorld), e.position.applyMatrix4(x), o.identity(), r.copy(c.matrixWorld), r.premultiply(x), o.extractRotation(r), e.halfWidth.set(.5 * c.width, 0, 0), e.halfHeight.set(0, .5 * c.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), n.rectArea[m] = e, m++
                    } else if (c.isPointLight) {
                        const i = t.get(c);
                        if (i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(x), i.color.copy(c.color).multiplyScalar(c.intensity), i.distance = c.distance, i.decay = c.decay, c.castShadow) {
                            const t = c.shadow,
                                i = e.get(c);
                            i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, n.pointShadow[f] = i, n.pointShadowMap[f] = S, n.pointShadowMatrix[f] = c.shadow.matrix, y++
                        }
                        n.point[f] = i, f++
                    } else if (c.isHemisphereLight) {
                        const e = t.get(c);
                        e.direction.setFromMatrixPosition(c.matrixWorld), e.direction.transformDirection(x), e.direction.normalize(), e.skyColor.copy(c.color).multiplyScalar(_), e.groundColor.copy(c.groundColor).multiplyScalar(_), n.hemi[g] = e, g++
                    }
                }
                n.ambient[0] = l, n.ambient[1] = u, n.ambient[2] = h;
                const w = n.hash;
                w.directionalLength === p && w.pointLength === f && w.spotLength === d && w.rectAreaLength === m && w.hemiLength === g && w.numDirectionalShadows === v && w.numPointShadows === y && w.numSpotShadows === b || (n.directional.length = p, n.spot.length = d, n.rectArea.length = m, n.point.length = f, n.hemi.length = g, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = y, n.spotShadowMatrix.length = b, w.directionalLength = p, w.pointLength = f, w.spotLength = d, w.rectAreaLength = m, w.hemiLength = g, w.numDirectionalShadows = v, w.numPointShadows = y, w.numSpotShadows = b, n.version = Hs++)
            },
            state: n
        }
    }

    function Ws() {
        const t = new Vs,
            e = [],
            n = [];
        return {
            init: function() {
                e.length = 0, n.length = 0
            },
            state: {
                lightsArray: e,
                shadowsArray: n,
                lights: t
            },
            setupLights: function(i) {
                t.setup(e, n, i)
            },
            pushLight: function(t) {
                e.push(t)
            },
            pushShadow: function(t) {
                n.push(t)
            }
        }
    }

    function qs() {
        let t = new WeakMap;

        function e(n) {
            const i = n.target;
            i.removeEventListener("dispose", e), t.delete(i)
        }
        return {
            get: function(n, i) {
                let r;
                return !1 === t.has(n) ? (r = new Ws, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new Ws, t.get(n).set(i, r)) : r = t.get(n).get(i), r
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }

    function Xs(t) {
        ji.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
    }

    function Zs(t) {
        ji.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new yn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
    }
    Xs.prototype = Object.create(ji.prototype), Xs.prototype.constructor = Xs, Xs.prototype.isMeshDepthMaterial = !0, Xs.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, Zs.prototype = Object.create(ji.prototype), Zs.prototype.constructor = Zs, Zs.prototype.isMeshDistanceMaterial = !0, Zs.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    };

    function Ys(t, e, n) {
        let i = new Yr;
        const r = new sn,
            o = new sn,
            s = new pn,
            a = [],
            c = [],
            l = {},
            u = {
                0: 1,
                1: 0,
                2: 2
            },
            h = new jr({
                defines: {
                    SAMPLE_RATE: 2 / 8,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new sn
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            }),
            p = h.clone();
        p.defines.HORIZONAL_PASS = 1;
        const f = new ur;
        f.setAttribute("position", new Wi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const d = new Ar(f, h),
            m = this;

        function g(n, i) {
            const r = e.update(d);
            h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, h, d, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, d, null)
        }

        function v(t, e, n) {
            const i = t << 0 | e << 1 | n << 2;
            let r = a[i];
            return void 0 === r && (r = new Xs({
                depthPacking: 3201,
                morphTargets: t,
                skinning: e
            }), a[i] = r), r
        }

        function y(t, e, n) {
            const i = t << 0 | e << 1 | n << 2;
            let r = c[i];
            return void 0 === r && (r = new Zs({
                morphTargets: t,
                skinning: e
            }), c[i] = r), r
        }

        function b(e, n, i, r, o, s, a) {
            let c = null,
                h = v,
                p = e.customDepthMaterial;
            if (!0 === r.isPointLight && (h = y, p = e.customDistanceMaterial), void 0 === p) {
                let t = !1;
                !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                let r = !1;
                !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                c = h(t, r, !0 === e.isInstancedMesh)
            } else c = p;
            if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                const t = c.uuid,
                    e = i.uuid;
                let n = l[t];
                void 0 === n && (n = {}, l[t] = n);
                let r = n[e];
                void 0 === r && (r = c.clone(), n[e] = r), c = r
            }
            return c.visible = i.visible, c.wireframe = i.wireframe, c.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = o, c.farDistance = s), c
        }

        function x(n, r, o, s, a) {
            if (!1 === n.visible) return;
            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                const i = e.update(n),
                    r = n.material;
                if (Array.isArray(r)) {
                    const e = i.groups;
                    for (let c = 0, l = e.length; c < l; c++) {
                        const l = e[c],
                            u = r[l.materialIndex];
                        if (u && u.visible) {
                            const e = b(n, i, u, s, o.near, o.far, a);
                            t.renderBufferDirect(o, null, i, e, n, l)
                        }
                    }
                } else if (r.visible) {
                    const e = b(n, i, r, s, o.near, o.far, a);
                    t.renderBufferDirect(o, null, i, e, n, null)
                }
            }
            const c = n.children;
            for (let t = 0, e = c.length; t < e; t++) x(c[t], r, o, s, a)
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, a, c) {
            if (!1 === m.enabled) return;
            if (!1 === m.autoUpdate && !1 === m.needsUpdate) return;
            if (0 === e.length) return;
            const l = t.getRenderTarget(),
                u = t.getActiveCubeFace(),
                h = t.getActiveMipmapLevel(),
                p = t.state;
            p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
            for (let l = 0, u = e.length; l < u; l++) {
                const u = e[l],
                    h = u.shadow;
                if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                if (void 0 === h) {
                    console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                    continue
                }
                r.copy(h.mapSize);
                const f = h.getFrameExtents();
                if (r.multiply(f), o.copy(h.mapSize), (r.x > n || r.y > n) && (r.x > n && (o.x = Math.floor(n / f.x), r.x = o.x * f.x, h.mapSize.x = o.x), r.y > n && (o.y = Math.floor(n / f.y), r.y = o.y * f.y, h.mapSize.y = o.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) {
                    const t = {
                        minFilter: 1006,
                        magFilter: 1006,
                        format: 1023
                    };
                    h.map = new fn(r.x, r.y, t), h.map.texture.name = u.name + ".shadowMap", h.mapPass = new fn(r.x, r.y, t), h.camera.updateProjectionMatrix()
                }
                if (null === h.map) {
                    const t = {
                        minFilter: 1003,
                        magFilter: 1003,
                        format: 1023
                    };
                    h.map = new fn(r.x, r.y, t), h.map.texture.name = u.name + ".shadowMap", h.camera.updateProjectionMatrix()
                }
                t.setRenderTarget(h.map), t.clear();
                const d = h.getViewportCount();
                for (let t = 0; t < d; t++) {
                    const e = h.getViewport(t);
                    s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), p.viewport(s), h.updateMatrices(u, t), i = h.getFrustum(), x(a, c, h.camera, u, this.type)
                }
                h.isPointLightShadow || 3 !== this.type || g(h, c), h.needsUpdate = !1
            }
            m.needsUpdate = !1, t.setRenderTarget(l, u, h)
        }
    }

    function $s(t, e, n) {
        const i = n.isWebGL2;
        const r = new function() {
                let e = !1;
                const n = new pn;
                let i = null;
                const r = new pn(0, 0, 0, 0);
                return {
                    setMask: function(n) {
                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, i, o, s, a) {
                        !0 === a && (e *= s, i *= s, o *= s), n.set(e, i, o, s), !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n))
                    },
                    reset: function() {
                        e = !1, i = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            o = new function() {
                let e = !1,
                    n = null,
                    i = null,
                    r = null;
                return {
                    setTest: function(t) {
                        t ? I(2929) : D(2929)
                    },
                    setMask: function(i) {
                        n === i || e || (t.depthMask(i), n = i)
                    },
                    setFunc: function(e) {
                        if (i !== e) {
                            if (e) switch (e) {
                                case 0:
                                    t.depthFunc(512);
                                    break;
                                case 1:
                                    t.depthFunc(519);
                                    break;
                                case 2:
                                    t.depthFunc(513);
                                    break;
                                case 3:
                                    t.depthFunc(515);
                                    break;
                                case 4:
                                    t.depthFunc(514);
                                    break;
                                case 5:
                                    t.depthFunc(518);
                                    break;
                                case 6:
                                    t.depthFunc(516);
                                    break;
                                case 7:
                                    t.depthFunc(517);
                                    break;
                                default:
                                    t.depthFunc(515)
                            } else t.depthFunc(515);
                            i = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        r !== e && (t.clearDepth(e), r = e)
                    },
                    reset: function() {
                        e = !1, n = null, i = null, r = null
                    }
                }
            },
            s = new function() {
                let e = !1,
                    n = null,
                    i = null,
                    r = null,
                    o = null,
                    s = null,
                    a = null,
                    c = null,
                    l = null;
                return {
                    setTest: function(t) {
                        e || (t ? I(2960) : D(2960))
                    },
                    setMask: function(i) {
                        n === i || e || (t.stencilMask(i), n = i)
                    },
                    setFunc: function(e, n, s) {
                        i === e && r === n && o === s || (t.stencilFunc(e, n, s), i = e, r = n, o = s)
                    },
                    setOp: function(e, n, i) {
                        s === e && a === n && c === i || (t.stencilOp(e, n, i), s = e, a = n, c = i)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        l !== e && (t.clearStencil(e), l = e)
                    },
                    reset: function() {
                        e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null
                    }
                }
            };
        let a = {},
            c = null,
            l = null,
            u = null,
            h = null,
            p = null,
            f = null,
            d = null,
            m = null,
            g = null,
            v = !1,
            y = null,
            b = null,
            x = null,
            w = null,
            _ = null;
        const M = t.getParameter(35661);
        let S = !1,
            T = 0;
        const E = t.getParameter(7938); - 1 !== E.indexOf("WebGL") ? (T = parseFloat(/^WebGL\ ([0-9])/.exec(E)[1]), S = T >= 1) : -1 !== E.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(E)[1]), S = T >= 2);
        let C = null,
            A = {};
        const L = new pn,
            P = new pn;

        function O(e, n, i) {
            const r = new Uint8Array(4),
                o = t.createTexture();
            t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
            for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return o
        }
        const R = {};

        function I(e) {
            !0 !== a[e] && (t.enable(e), a[e] = !0)
        }

        function D(e) {
            !1 !== a[e] && (t.disable(e), a[e] = !1)
        }
        R[3553] = O(3553, 3553, 1), R[34067] = O(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), s.setClear(0), I(2929), o.setFunc(3), B(!1), z(1), I(2884), U(0);
        const N = {
            100: 32774,
            101: 32778,
            102: 32779
        };
        if (i) N[103] = 32775, N[104] = 32776;
        else {
            const t = e.get("EXT_blend_minmax");
            null !== t && (N[103] = t.MIN_EXT, N[104] = t.MAX_EXT)
        }
        const k = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };

        function U(e, n, i, r, o, s, a, c) {
            if (0 !== e) {
                if (l || (I(3042), l = !0), 5 === e) o = o || n, s = s || i, a = a || r, n === h && o === d || (t.blendEquationSeparate(N[n], N[o]), h = n, d = o), i === p && r === f && s === m && a === g || (t.blendFuncSeparate(k[i], k[r], k[s], k[a]), p = i, f = r, m = s, g = a), u = e, v = null;
                else if (e !== u || c !== v) {
                    if (100 === h && 100 === d || (t.blendEquation(32774), h = 100, d = 100), c) switch (e) {
                        case 1:
                            t.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(1, 1);
                            break;
                        case 3:
                            t.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            t.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case 1:
                            t.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(770, 1);
                            break;
                        case 3:
                            t.blendFunc(0, 769);
                            break;
                        case 4:
                            t.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    }
                    p = null, f = null, m = null, g = null, u = e, v = c
                }
            } else l && (D(3042), l = !1)
        }

        function B(e) {
            y !== e && (e ? t.frontFace(2304) : t.frontFace(2305), y = e)
        }

        function z(e) {
            0 !== e ? (I(2884), e !== b && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : D(2884), b = e
        }

        function F(e, n, i) {
            e ? (I(32823), w === n && _ === i || (t.polygonOffset(n, i), w = n, _ = i)) : D(32823)
        }

        function j(e) {
            void 0 === e && (e = 33984 + M - 1), C !== e && (t.activeTexture(e), C = e)
        }
        return {
            buffers: {
                color: r,
                depth: o,
                stencil: s
            },
            enable: I,
            disable: D,
            useProgram: function(e) {
                return c !== e && (t.useProgram(e), c = e, !0)
            },
            setBlending: U,
            setMaterial: function(t, e) {
                2 === t.side ? D(2884) : I(2884);
                let n = 1 === t.side;
                e && (n = !n), B(n), 1 === t.blending && !1 === t.transparent ? U(0) : U(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite);
                const i = t.stencilWrite;
                s.setTest(i), i && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), F(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            },
            setFlipSided: B,
            setCullFace: z,
            setLineWidth: function(e) {
                e !== x && (S && t.lineWidth(e), x = e)
            },
            setPolygonOffset: F,
            setScissorTest: function(t) {
                t ? I(3089) : D(3089)
            },
            activeTexture: j,
            bindTexture: function(e, n) {
                null === C && j();
                let i = A[C];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                }, A[C] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || R[e]), i.type = e, i.texture = n)
            },
            unbindTexture: function() {
                const e = A[C];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage3D: function() {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function(e) {
                !1 === L.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), L.copy(e))
            },
            viewport: function(e) {
                !1 === P.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), P.copy(e))
            },
            reset: function() {
                a = {}, C = null, A = {}, c = null, u = null, y = null, b = null, r.reset(), o.reset(), s.reset()
            }
        }
    }

    function Js(t, e, n, i, r, o, s) {
        const a = r.isWebGL2,
            c = r.maxTextures,
            l = r.maxCubemapSize,
            u = r.maxTextureSize,
            h = r.maxSamples,
            p = new WeakMap;
        let f, d = !1;
        try {
            d = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (t) {}

        function m(t, e) {
            return d ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function g(t, e, n, i) {
            let r = 1;
            if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const i = e ? on.floorPowerOfTwo : Math.floor,
                        o = i(r * t.width),
                        s = i(r * t.height);
                    void 0 === f && (f = m(o, s));
                    const a = n ? m(o, s) : f;
                    a.width = o, a.height = s;
                    return a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a
                }
                return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
            }
            return t
        }

        function v(t) {
            return on.isPowerOfTwo(t.width) && on.isPowerOfTwo(t.height)
        }

        function y(t, e) {
            return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        }

        function b(e, n, r, o) {
            t.generateMipmap(e);
            i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
        }

        function x(n, i, r) {
            if (!1 === a) return i;
            if (null !== n) {
                if (void 0 !== t[n]) return t[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let o = i;
            return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
        }

        function w(t) {
            return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
        }

        function _(e) {
            const n = e.target;
            n.removeEventListener("dispose", _),
                function(e) {
                    const n = i.get(e);
                    if (void 0 === n.__webglInit) return;
                    t.deleteTexture(n.__webglTexture), i.remove(e)
                }(n), n.isVideoTexture && p.delete(n), s.memory.textures--
        }

        function M(e) {
            const n = e.target;
            n.removeEventListener("dispose", M),
                function(e) {
                    const n = i.get(e),
                        r = i.get(e.texture);
                    if (!e) return;
                    void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget)
                        for (let e = 0; e < 6; e++) t.deleteFramebuffer(n.__webglFramebuffer[e]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
                    else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                    i.remove(e.texture), i.remove(e)
                }(n), s.memory.textures--
        }
        let S = 0;

        function T(t, e) {
            const r = i.get(t);
            if (t.isVideoTexture && function(t) {
                    const e = s.render.frame;
                    p.get(t) !== e && (p.set(t, e), t.update())
                }(t), t.version > 0 && r.__version !== t.version) {
                const n = t.image;
                if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== n.complete) return void R(r, t, e);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
        }

        function E(e, r) {
            if (6 !== e.image.length) return;
            const s = i.get(e);
            if (e.version > 0 && s.__version !== e.version) {
                O(s, e), n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture), t.pixelStorei(37440, e.flipY);
                const i = e && (e.isCompressedTexture || e.image[0].isCompressedTexture),
                    c = e.image[0] && e.image[0].isDataTexture,
                    u = [];
                for (let t = 0; t < 6; t++) u[t] = i || c ? c ? e.image[t].image : e.image[t] : g(e.image[t], !1, !0, l);
                const h = u[0],
                    p = v(h) || a,
                    f = o.convert(e.format),
                    d = o.convert(e.type),
                    m = x(e.internalFormat, f, d);
                let w;
                if (P(34067, e, p), i) {
                    for (let t = 0; t < 6; t++) {
                        w = u[t].mipmaps;
                        for (let i = 0; i < w.length; i++) {
                            const r = w[i];
                            1023 !== e.format && 1022 !== e.format ? null !== f ? n.compressedTexImage2D(34069 + t, i, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, i, m, r.width, r.height, 0, f, d, r.data)
                        }
                    }
                    s.__maxMipLevel = w.length - 1
                } else {
                    w = e.mipmaps;
                    for (let t = 0; t < 6; t++)
                        if (c) {
                            n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, f, d, u[t].data);
                            for (let e = 0; e < w.length; e++) {
                                const i = w[e].image[t].image;
                                n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, f, d, i.data)
                            }
                        } else {
                            n.texImage2D(34069 + t, 0, m, f, d, u[t]);
                            for (let e = 0; e < w.length; e++) {
                                const i = w[e];
                                n.texImage2D(34069 + t, e + 1, m, f, d, i.image[t])
                            }
                        }
                    s.__maxMipLevel = w.length
                }
                y(e, p) && b(34067, e, h.width, h.height), s.__version = e.version, e.onUpdate && e.onUpdate(e)
            } else n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture)
        }

        function C(t, e) {
            n.activeTexture(33984 + e), n.bindTexture(34067, i.get(t).__webglTexture)
        }
        const A = {
                1e3: 10497,
                1001: 33071,
                1002: 33648
            },
            L = {
                1003: 9728,
                1004: 9984,
                1005: 9986,
                1006: 9729,
                1007: 9985,
                1008: 9987
            };

        function P(n, o, s) {
            s ? (t.texParameteri(n, 10242, A[o.wrapS]), t.texParameteri(n, 10243, A[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[o.wrapR]), t.texParameteri(n, 10240, L[o.magFilter]), t.texParameteri(n, 10241, L[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), 1001 === o.wrapS && 1001 === o.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(o.magFilter)), t.texParameteri(n, 10241, w(o.minFilter)), 1003 !== o.minFilter && 1006 !== o.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            const c = e.get("EXT_texture_filter_anisotropic");
            if (c) {
                if (1015 === o.type && null === e.get("OES_texture_float_linear")) return;
                if (1016 === o.type && null === (a || e.get("OES_texture_half_float_linear"))) return;
                (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
            }
        }

        function O(e, n) {
            void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", _), e.__webglTexture = t.createTexture(), s.memory.textures++)
        }

        function R(e, i, r) {
            let s = 3553;
            i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), O(e, i), n.activeTexture(33984 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment);
            const c = function(t) {
                    return !a && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter)
                }(i) && !1 === v(i.image),
                l = g(i.image, c, !1, u),
                h = v(l) || a,
                p = o.convert(i.format);
            let f, d = o.convert(i.type),
                m = x(i.internalFormat, p, d);
            P(s, i, h);
            const w = i.mipmaps;
            if (i.isDepthTexture) m = 6402, a ? m = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i.format && 6402 === m && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = 1012, d = o.convert(i.type)), 1027 === i.format && 6402 === m && (m = 34041, 1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = 1020, d = o.convert(i.type))), n.texImage2D(3553, 0, m, l.width, l.height, 0, p, d, null);
            else if (i.isDataTexture)
                if (w.length > 0 && h) {
                    for (let t = 0, e = w.length; t < e; t++) f = w[t], n.texImage2D(3553, t, m, f.width, f.height, 0, p, d, f.data);
                    i.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
                } else n.texImage2D(3553, 0, m, l.width, l.height, 0, p, d, l.data), e.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (let t = 0, e = w.length; t < e; t++) f = w[t], 1023 !== i.format && 1022 !== i.format ? null !== p ? n.compressedTexImage2D(3553, t, m, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, f.width, f.height, 0, p, d, f.data);
                e.__maxMipLevel = w.length - 1
            } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, p, d, l.data), e.__maxMipLevel = 0;
            else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, p, d, l.data), e.__maxMipLevel = 0;
            else if (w.length > 0 && h) {
                for (let t = 0, e = w.length; t < e; t++) f = w[t], n.texImage2D(3553, t, m, p, d, f);
                i.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
            } else n.texImage2D(3553, 0, m, p, d, l), e.__maxMipLevel = 0;
            y(i, h) && b(s, i, l.width, l.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
        }

        function I(e, r, s, a) {
            const c = o.convert(r.texture.format),
                l = o.convert(r.texture.type),
                u = x(r.texture.internalFormat, c, l);
            n.texImage2D(a, 0, u, r.width, r.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, s, a, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
        }

        function D(e, n, i) {
            if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                let r = 33189;
                if (i) {
                    const e = n.depthTexture;
                    e && e.isDepthTexture && (1015 === e.type ? r = 36012 : 1014 === e.type && (r = 33190));
                    const i = k(n);
                    t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                } else t.renderbufferStorage(36161, r, n.width, n.height);
                t.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    const e = k(n);
                    t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                t.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
                const e = o.convert(n.texture.format),
                    r = o.convert(n.texture.type),
                    s = x(n.texture.internalFormat, e, r);
                if (i) {
                    const e = k(n);
                    t.renderbufferStorageMultisample(36161, e, s, n.width, n.height)
                } else t.renderbufferStorage(36161, s, n.width, n.height)
            }
            t.bindRenderbuffer(36161, null)
        }

        function N(e) {
            const n = i.get(e),
                r = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
                if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(e, n) {
                    if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), T(n.depthTexture, 0);
                    const r = i.get(n.depthTexture).__webglTexture;
                    if (1026 === n.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                    else {
                        if (1027 !== n.depthTexture.format) throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                    }
                }(n.__webglFramebuffer, e)
            } else if (r) {
                n.__webglDepthbuffer = [];
                for (let i = 0; i < 6; i++) t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), D(n.__webglDepthbuffer[i], e, !1)
            } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), D(n.__webglDepthbuffer, e, !1);
            t.bindFramebuffer(36160, null)
        }

        function k(t) {
            return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0
        }
        let U = !1,
            B = !1;
        this.allocateTextureUnit = function() {
            const t = S;
            return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), S += 1, t
        }, this.resetTextureUnits = function() {
            S = 0
        }, this.setTexture2D = T, this.setTexture2DArray = function(t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
        }, this.setTexture3D = function(t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
        }, this.setTextureCube = E, this.setTextureCubeDynamic = C, this.setupRenderTarget = function(e) {
            const r = i.get(e),
                c = i.get(e.texture);
            e.addEventListener("dispose", M), c.__webglTexture = t.createTexture(), s.memory.textures++;
            const l = !0 === e.isWebGLCubeRenderTarget,
                u = !0 === e.isWebGLMultisampleRenderTarget,
                h = v(e) || a;
            if (!a || 1022 !== e.texture.format || 1015 !== e.texture.type && 1016 !== e.texture.type || (e.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), l) {
                r.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++) r.__webglFramebuffer[e] = t.createFramebuffer()
            } else if (r.__webglFramebuffer = t.createFramebuffer(), u)
                if (a) {
                    r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
                    const n = o.convert(e.texture.format),
                        i = o.convert(e.texture.type),
                        s = x(e.texture.internalFormat, n, i),
                        a = k(e);
                    t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), D(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (l) {
                n.bindTexture(34067, c.__webglTexture), P(34067, e.texture, h);
                for (let t = 0; t < 6; t++) I(r.__webglFramebuffer[t], e, 36064, 34069 + t);
                y(e.texture, h) && b(34067, e.texture, e.width, e.height), n.bindTexture(34067, null)
            } else n.bindTexture(3553, c.__webglTexture), P(3553, e.texture, h), I(r.__webglFramebuffer, e, 36064, 3553), y(e.texture, h) && b(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);
            e.depthBuffer && N(e)
        }, this.updateRenderTargetMipmap = function(t) {
            const e = t.texture;
            if (y(e, v(t) || a)) {
                const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                    o = i.get(e).__webglTexture;
                n.bindTexture(r, o), b(r, e, t.width, t.height), n.bindTexture(r, null)
            }
        }, this.updateMultisampleRenderTarget = function(e) {
            if (e.isWebGLMultisampleRenderTarget)
                if (a) {
                    const n = i.get(e);
                    t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                    const r = e.width,
                        o = e.height;
                    let s = 16384;
                    e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function(t, e) {
            t && t.isWebGLRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U = !0), t = t.texture), T(t, e)
        }, this.safeSetTextureCube = function(t, e) {
            t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? E(t, e) : C(t, e)
        }
    }

    function Ks(t, e, n) {
        const i = n.isWebGL2;
        return {
            convert: function(t) {
                let n;
                if (1009 === t) return 5121;
                if (1017 === t) return 32819;
                if (1018 === t) return 32820;
                if (1019 === t) return 33635;
                if (1010 === t) return 5120;
                if (1011 === t) return 5122;
                if (1012 === t) return 5123;
                if (1013 === t) return 5124;
                if (1014 === t) return 5125;
                if (1015 === t) return 5126;
                if (1016 === t) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                if (1021 === t) return 6406;
                if (1022 === t) return 6407;
                if (1023 === t) return 6408;
                if (1024 === t) return 6409;
                if (1025 === t) return 6410;
                if (1026 === t) return 6402;
                if (1027 === t) return 34041;
                if (1028 === t) return 6403;
                if (1029 === t) return 36244;
                if (1030 === t) return 33319;
                if (1031 === t) return 33320;
                if (1032 === t) return 36248;
                if (1033 === t) return 36249;
                if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                    if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                    if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                    if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                    if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                    if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                    if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : 1020 === t ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }

    function Qs(t) {
        Gr.call(this), this.cameras = t || []
    }

    function ta() {
        Vn.call(this), this.type = "Group"
    }

    function ea() {
        this._targetRay = null, this._grip = null
    }

    function na(t, e) {
        const n = this;
        let i = null,
            r = 1,
            o = null,
            s = "local-floor",
            a = null;
        const c = [],
            l = new Map,
            u = new Gr;
        u.layers.enable(1), u.viewport = new pn;
        const h = new Gr;
        h.layers.enable(2), h.viewport = new pn;
        const p = [u, h],
            f = new Qs;
        f.layers.enable(1), f.layers.enable(2);
        let d = null,
            m = null;

        function g(t) {
            const e = l.get(t.inputSource);
            e && e.dispatchEvent({
                type: t.type
            })
        }

        function v() {
            l.forEach((function(t, e) {
                t.disconnect(e)
            })), l.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), S.stop(), n.isPresenting = !1, n.dispatchEvent({
                type: "sessionend"
            })
        }

        function y(t) {
            o = t, S.setContext(i), S.start(), n.isPresenting = !0, n.dispatchEvent({
                type: "sessionstart"
            })
        }

        function b(t) {
            const e = i.inputSources;
            for (let t = 0; t < c.length; t++) l.set(e[t], c[t]);
            for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e],
                    i = l.get(n);
                i && (i.dispatchEvent({
                    type: "disconnected",
                    data: n
                }), l.delete(n))
            }
            for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e],
                    i = l.get(n);
                i && i.dispatchEvent({
                    type: "connected",
                    data: n
                })
            }
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
            let e = c[t];
            return void 0 === e && (e = new ea, c[t] = e), e.getTargetRaySpace()
        }, this.getControllerGrip = function(t) {
            let e = c[t];
            return void 0 === e && (e = new ea, c[t] = e), e.getGripSpace()
        }, this.setFramebufferScaleFactor = function(t) {
            r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(t) {
            s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            return o
        }, this.getSession = function() {
            return i
        }, this.setSession = function(t) {
            if (i = t, null !== i) {
                i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v);
                const t = e.getContextAttributes();
                !0 !== t.xrCompatible && e.makeXRCompatible();
                const n = {
                        antialias: t.antialias,
                        alpha: t.alpha,
                        depth: t.depth,
                        stencil: t.stencil,
                        framebufferScaleFactor: r
                    },
                    o = new XRWebGLLayer(i, e, n);
                i.updateRenderState({
                    baseLayer: o
                }), i.requestReferenceSpace(s).then(y), i.addEventListener("inputsourceschange", b)
            }
        };
        const x = new yn,
            w = new yn;

        function _(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
        }
        this.getCamera = function(t) {
            f.near = h.near = u.near = t.near, f.far = h.far = u.far = t.far, d === f.near && m === f.far || (i.updateRenderState({
                depthNear: f.near,
                depthFar: f.far
            }), d = f.near, m = f.far);
            const e = t.parent,
                n = f.cameras;
            _(f, e);
            for (let t = 0; t < n.length; t++) _(n[t], e);
            t.matrixWorld.copy(f.matrixWorld);
            const r = t.children;
            for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
            return 2 === n.length ? function(t, e, n) {
                x.setFromMatrixPosition(e.matrixWorld), w.setFromMatrixPosition(n.matrixWorld);
                const i = x.distanceTo(w),
                    r = e.projectionMatrix.elements,
                    o = n.projectionMatrix.elements,
                    s = r[14] / (r[10] - 1),
                    a = r[14] / (r[10] + 1),
                    c = (r[9] + 1) / r[5],
                    l = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (o[8] + 1) / o[0],
                    p = s * u,
                    f = s * h,
                    d = i / (-u + h),
                    m = d * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(d), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                const g = s + d,
                    v = a + d,
                    y = p - m,
                    b = f + (i - m),
                    _ = c * a / v * g,
                    M = l * a / v * g;
                t.projectionMatrix.makePerspective(y, b, _, M, g, v)
            }(f, u, h) : f.projectionMatrix.copy(u.projectionMatrix), f
        };
        let M = null;
        const S = new Jr;
        S.setAnimationLoop((function(e, n) {
            if (a = n.getViewerPose(o), null !== a) {
                const e = a.views,
                    n = i.renderState.baseLayer;
                t.setFramebuffer(n.framebuffer);
                let r = !1;
                e.length !== f.cameras.length && (f.cameras.length = 0, r = !0);
                for (let t = 0; t < e.length; t++) {
                    const i = e[t],
                        o = n.getViewport(i),
                        s = p[t];
                    s.matrix.fromArray(i.transform.matrix), s.projectionMatrix.fromArray(i.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === t && f.matrix.copy(s.matrix), !0 === r && f.cameras.push(s)
                }
            }
            const r = i.inputSources;
            for (let t = 0; t < c.length; t++) {
                const e = c[t],
                    i = r[t];
                e.update(i, n, o)
            }
            M && M(e, n)
        })), this.setAnimationLoop = function(t) {
            M = t
        }, this.dispose = function() {}
    }

    function ia(t) {
        function e(e, n, i) {
            e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
            const r = n.envMap || i;
            let o, s;
            r && (e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio, e.maxMipLevel.value = t.get(r).__maxMipLevel), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? o = n.map : n.specularMap ? o = n.specularMap : n.displacementMap ? o = n.displacementMap : n.normalMap ? o = n.normalMap : n.bumpMap ? o = n.bumpMap : n.roughnessMap ? o = n.roughnessMap : n.metalnessMap ? o = n.metalnessMap : n.alphaMap ? o = n.alphaMap : n.emissiveMap && (o = n.emissiveMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uvTransform.value.copy(o.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
        }

        function n(t, e, n) {
            t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(t, e) {
                t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            },
            refreshMaterialUniforms: function(t, i, r, o, s) {
                i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshStandardMaterial ? (e(t, i, r), i.isMeshPhysicalMaterial ? function(t, e, i) {
                    n(t, e, i), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                    e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                    e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                    t.transparency.value = e.transparency
                }(t, i, r) : n(t, i, r)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                    t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                }(t, i), i.isLineDashedMaterial && function(t, e) {
                    t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let r;
                    e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                    void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                }(t, i, o, s) : i.isSpriteMaterial ? function(t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let n;
                    e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
            }
        }
    }

    function ra(t) {
        const e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            n = void 0 !== t.context ? t.context : null,
            i = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            o = void 0 === t.stencil || t.stencil,
            s = void 0 !== t.antialias && t.antialias,
            a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            l = void 0 !== t.powerPreference ? t.powerPreference : "default",
            u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
        let h = null,
            p = null;
        this.domElement = e, this.debug = {
            checkShaderErrors: !0
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        const f = this;
        let d = !1,
            m = null,
            g = 0,
            v = 0,
            y = null,
            b = null,
            x = -1,
            w = null,
            _ = null;
        const M = new pn,
            S = new pn;
        let T = null,
            E = e.width,
            C = e.height,
            A = 1,
            L = null,
            P = null;
        const O = new pn(0, 0, E, C),
            R = new pn(0, 0, E, C);
        let I = !1;
        const D = new Yr,
            N = new ao;
        let k = !1,
            U = !1;
        const B = new En,
            z = new yn,
            F = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };

        function j() {
            return null === y ? A : 1
        }
        let H, G, V, W, q, X, Z, Y, $, J, K, Q, tt, et, nt, it, rt, ot, st, at = n;

        function ct(t, n) {
            for (let i = 0; i < t.length; i++) {
                const r = t[i],
                    o = e.getContext(r, n);
                if (null !== o) return o
            }
            return null
        }
        try {
            const t = {
                alpha: i,
                depth: r,
                stencil: o,
                antialias: s,
                premultipliedAlpha: a,
                preserveDrawingBuffer: c,
                powerPreference: l,
                failIfMajorPerformanceCaveat: u
            };
            if (e.addEventListener("webglcontextlost", pt, !1), e.addEventListener("webglcontextrestored", ft, !1), null === at) {
                const e = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === f.isWebGL1Renderer && e.shift(), at = ct(e, t), null === at) throw ct(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === at.getShaderPrecisionFormat && (at.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (t) {
            throw console.error("THREE.WebGLRenderer: " + t.message), t
        }

        function lt() {
            H = new co(at), G = new so(at, H, t), !1 === G.isWebGL2 && (H.get("WEBGL_depth_texture"), H.get("OES_texture_float"), H.get("OES_texture_half_float"), H.get("OES_texture_half_float_linear"), H.get("OES_standard_derivatives"), H.get("OES_element_index_uint"), H.get("OES_vertex_array_object"), H.get("ANGLE_instanced_arrays")), H.get("OES_texture_float_linear"), ot = new Ks(at, H, G), V = new $s(at, H, G), V.scissor(S.copy(R).multiplyScalar(A).floor()), V.viewport(M.copy(O).multiplyScalar(A).floor()), W = new ho(at), q = new ks, X = new Js(at, H, V, q, G, ot, W), Z = new Kr(at, G), st = new ro(at, H, Z, G), Y = new lo(at, Z, W, st), $ = new go(at, Y, Z, W), nt = new mo(at), J = new Ns(f, H, G, st), K = new ia(q), Q = new Fs, tt = new qs, et = new io(f, V, $, a), it = new oo(at, H, W, G), rt = new uo(at, H, W, G), W.programs = J.programs, f.capabilities = G, f.extensions = H, f.properties = q, f.renderLists = Q, f.state = V, f.info = W
        }
        lt();
        const ut = new na(f, at);
        this.xr = ut;
        const ht = new Ys(f, $, G.maxTextureSize);

        function pt(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), d = !0
        }

        function ft() {
            console.log("THREE.WebGLRenderer: Context Restored."), d = !1, lt()
        }

        function dt(t) {
            const e = t.target;
            e.removeEventListener("dispose", dt),
                function(t) {
                    mt(t), q.remove(t)
                }(e)
        }

        function mt(t) {
            const e = q.get(t).program;
            t.program = void 0, void 0 !== e && J.releaseProgram(e)
        }
        this.shadowMap = ht, this.getContext = function() {
            return at
        }, this.getContextAttributes = function() {
            return at.getContextAttributes()
        }, this.forceContextLoss = function() {
            const t = H.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function() {
            const t = H.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function() {
            return A
        }, this.setPixelRatio = function(t) {
            void 0 !== t && (A = t, this.setSize(E, C, !1))
        }, this.getSize = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new sn), t.set(E, C)
        }, this.setSize = function(t, n, i) {
            ut.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t, C = n, e.width = Math.floor(t * A), e.height = Math.floor(n * A), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
        }, this.getDrawingBufferSize = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new sn), t.set(E * A, C * A).floor()
        }, this.setDrawingBufferSize = function(t, n, i) {
            E = t, C = n, A = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
        }, this.getCurrentViewport = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new pn), t.copy(M)
        }, this.getViewport = function(t) {
            return t.copy(O)
        }, this.setViewport = function(t, e, n, i) {
            t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), V.viewport(M.copy(O).multiplyScalar(A).floor())
        }, this.getScissor = function(t) {
            return t.copy(R)
        }, this.setScissor = function(t, e, n, i) {
            t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i), V.scissor(S.copy(R).multiplyScalar(A).floor())
        }, this.getScissorTest = function() {
            return I
        }, this.setScissorTest = function(t) {
            V.setScissorTest(I = t)
        }, this.setOpaqueSort = function(t) {
            L = t
        }, this.setTransparentSort = function(t) {
            P = t
        }, this.getClearColor = function() {
            return et.getClearColor()
        }, this.setClearColor = function() {
            et.setClearColor.apply(et, arguments)
        }, this.getClearAlpha = function() {
            return et.getClearAlpha()
        }, this.setClearAlpha = function() {
            et.setClearAlpha.apply(et, arguments)
        }, this.clear = function(t, e, n) {
            let i = 0;
            (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), at.clear(i)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            e.removeEventListener("webglcontextlost", pt, !1), e.removeEventListener("webglcontextrestored", ft, !1), Q.dispose(), tt.dispose(), q.dispose(), $.dispose(), st.dispose(), ut.dispose(), vt.stop()
        }, this.renderBufferImmediate = function(t, e) {
            st.initAttributes();
            const n = q.get(t);
            t.hasPositions && !n.position && (n.position = at.createBuffer()), t.hasNormals && !n.normal && (n.normal = at.createBuffer()), t.hasUvs && !n.uv && (n.uv = at.createBuffer()), t.hasColors && !n.color && (n.color = at.createBuffer());
            const i = e.getAttributes();
            t.hasPositions && (at.bindBuffer(34962, n.position), at.bufferData(34962, t.positionArray, 35048), st.enableAttribute(i.position), at.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (at.bindBuffer(34962, n.normal), at.bufferData(34962, t.normalArray, 35048), st.enableAttribute(i.normal), at.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (at.bindBuffer(34962, n.uv), at.bufferData(34962, t.uvArray, 35048), st.enableAttribute(i.uv), at.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (at.bindBuffer(34962, n.color), at.bufferData(34962, t.colorArray, 35048), st.enableAttribute(i.color), at.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), st.disableUnusedAttributes(), at.drawArrays(4, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function(t, e, n, i, r, o) {
            null === e && (e = F);
            const s = r.isMesh && r.matrixWorld.determinant() < 0,
                a = _t(t, e, i, r);
            V.setMaterial(i, s);
            let c = n.index;
            const l = n.attributes.position;
            if (null === c) {
                if (void 0 === l || 0 === l.count) return
            } else if (0 === c.count) return;
            let u, h = 1;
            !0 === i.wireframe && (c = Y.getWireframeAttribute(n), h = 2), (i.morphTargets || i.morphNormals) && nt.update(r, n, i, a), st.setup(r, i, a, n, c);
            let p = it;
            null !== c && (u = Z.get(c), p = rt, p.setIndex(u));
            const f = null !== c ? c.count : l.count,
                d = n.drawRange.start * h,
                m = n.drawRange.count * h,
                g = null !== o ? o.start * h : 0,
                v = null !== o ? o.count * h : 1 / 0,
                y = Math.max(d, g),
                b = Math.min(f, d + m, g + v) - 1,
                x = Math.max(0, b - y + 1);
            if (0 !== x) {
                if (r.isMesh) !0 === i.wireframe ? (V.setLineWidth(i.wireframeLinewidth * j()), p.setMode(1)) : p.setMode(4);
                else if (r.isLine) {
                    let t = i.linewidth;
                    void 0 === t && (t = 1), V.setLineWidth(t * j()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                if (r.isInstancedMesh) p.renderInstances(n, y, x, r.count);
                else if (n.isInstancedBufferGeometry) {
                    const t = Math.min(n.instanceCount, n._maxInstanceCount);
                    p.renderInstances(n, y, x, t)
                } else p.render(y, x)
            }
        }, this.compile = function(t, e) {
            p = tt.get(t, e), p.init(), t.traverse((function(t) {
                t.isLight && (p.pushLight(t), t.castShadow && p.pushShadow(t))
            })), p.setupLights(e);
            const n = new WeakMap;
            t.traverse((function(e) {
                let i = e.material;
                if (i)
                    if (Array.isArray(i))
                        for (let r = 0; r < i.length; r++) {
                            let o = i[r];
                            !1 === n.has(o) && (wt(o, t, e), n.set(o))
                        } else !1 === n.has(i) && (wt(i, t, e), n.set(i))
            }))
        };
        let gt = null;
        const vt = new Jr;

        function yt(t, e, n, i) {
            if (!1 === t.visible) return;
            if (t.layers.test(e.layers))
                if (t.isGroup) n = t.renderOrder;
                else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
            else if (t.isSprite) {
                if (!t.frustumCulled || D.intersectsSprite(t)) {
                    i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                    const e = $.update(t),
                        r = t.material;
                    r.visible && h.push(t, e, r, n, z.z, null)
                }
            } else if (t.isImmediateRenderObject) i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B), h.push(t, null, t.material, n, z.z, null);
            else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== W.render.frame && (t.skeleton.update(), t.skeleton.frame = W.render.frame), !t.frustumCulled || D.intersectsObject(t))) {
                i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                const e = $.update(t),
                    r = t.material;
                if (Array.isArray(r)) {
                    const i = e.groups;
                    for (let o = 0, s = i.length; o < s; o++) {
                        const s = i[o],
                            a = r[s.materialIndex];
                        a && a.visible && h.push(t, e, a, n, z.z, s)
                    }
                } else r.visible && h.push(t, e, r, n, z.z, null)
            }
            const r = t.children;
            for (let t = 0, o = r.length; t < o; t++) yt(r[t], e, n, i)
        }

        function bt(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null;
            for (let r = 0, o = t.length; r < o; r++) {
                const o = t[r],
                    s = o.object,
                    a = o.geometry,
                    c = null === i ? o.material : i,
                    l = o.group;
                if (n.isArrayCamera) {
                    _ = n;
                    const t = n.cameras;
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        s.layers.test(i.layers) && (V.viewport(M.copy(i.viewport)), p.setupLights(i), xt(s, e, i, a, c, l))
                    }
                } else _ = null, xt(s, e, n, a, c, l)
            }
        }

        function xt(t, e, n, i, r, o) {
            if (t.onBeforeRender(f, e, n, i, r, o), p = tt.get(e, _ || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                const i = _t(n, e, r, t);
                V.setMaterial(r), st.reset(),
                    function(t, e) {
                        t.render((function(t) {
                            f.renderBufferImmediate(t, e)
                        }))
                    }(t, i)
            } else f.renderBufferDirect(n, e, i, r, t, o);
            t.onAfterRender(f, e, n, i, r, o), p = tt.get(e, _ || n)
        }

        function wt(t, e, n) {
            !0 !== e.isScene && (e = F);
            const i = q.get(t),
                r = p.state.lights,
                o = p.state.shadowsArray,
                s = r.state.version,
                a = J.getParameters(t, r.state, o, e, N.numPlanes, N.numIntersection, n),
                c = J.getProgramCacheKey(a);
            let l = i.program,
                u = !0;
            if (void 0 === l) t.addEventListener("dispose", dt);
            else if (l.cacheKey !== c) mt(t);
            else if (i.lightsStateVersion !== s) i.lightsStateVersion = s, u = !1;
            else {
                if (void 0 !== a.shaderID) return;
                u = !1
            }
            u && (l = J.acquireProgram(a, c), i.program = l, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding, t.program = l);
            const h = l.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (let e = 0; e < f.maxMorphTargets; e++) h["morphTarget" + e] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                for (let e = 0; e < f.maxMorphNormals; e++) h["morphNormal" + e] >= 0 && t.numSupportedMorphNormals++
            }
            const d = i.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = N.numPlanes, i.numIntersection = N.numIntersection, d.clippingPlanes = N.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.needsLights = function(t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t), i.lightsStateVersion = s, i.needsLights && (d.ambientLightColor.value = r.state.ambient, d.lightProbe.value = r.state.probe, d.directionalLights.value = r.state.directional, d.directionalLightShadows.value = r.state.directionalShadow, d.spotLights.value = r.state.spot, d.spotLightShadows.value = r.state.spotShadow, d.rectAreaLights.value = r.state.rectArea, d.pointLights.value = r.state.point, d.pointLightShadows.value = r.state.pointShadow, d.hemisphereLights.value = r.state.hemi, d.directionalShadowMap.value = r.state.directionalShadowMap, d.directionalShadowMatrix.value = r.state.directionalShadowMatrix, d.spotShadowMap.value = r.state.spotShadowMap, d.spotShadowMatrix.value = r.state.spotShadowMatrix, d.pointShadowMap.value = r.state.pointShadowMap, d.pointShadowMatrix.value = r.state.pointShadowMatrix);
            const m = i.program.getUniforms(),
                g = ds.seqWithValue(m.seq, d);
            i.uniformsList = g
        }

        function _t(t, e, n, i) {
            !0 !== e.isScene && (e = F), X.resetTextureUnits();
            const r = e.fog,
                o = n.isMeshStandardMaterial ? e.environment : null,
                s = null === y ? f.outputEncoding : y.texture.encoding,
                a = q.get(n),
                c = p.state.lights;
            if (!0 === k && (!0 === U || t !== w)) {
                const e = t === w && n.id === x;
                N.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, a, e)
            }
            n.version === a.__version ? void 0 === a.program || n.fog && a.fog !== r || a.environment !== o || a.needsLights && a.lightsStateVersion !== c.state.version ? wt(n, e, i) : void 0 === a.numClippingPlanes || a.numClippingPlanes === N.numPlanes && a.numIntersection === N.numIntersection ? a.outputEncoding !== s && wt(n, e, i) : wt(n, e, i) : (wt(n, e, i), a.__version = n.version);
            let l = !1,
                u = !1,
                h = !1;
            const d = a.program,
                m = d.getUniforms(),
                g = a.uniforms;
            if (V.useProgram(d.program) && (l = !0, u = !0, h = !0), n.id !== x && (x = n.id, u = !0), l || w !== t) {
                if (m.setValue(at, "projectionMatrix", t.projectionMatrix), G.logarithmicDepthBuffer && m.setValue(at, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), w !== t && (w = t, u = !0, h = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                    const e = m.map.cameraPosition;
                    void 0 !== e && e.setValue(at, z.setFromMatrixPosition(t.matrixWorld))
                }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && m.setValue(at, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && m.setValue(at, "viewMatrix", t.matrixWorldInverse)
            }
            if (n.skinning) {
                m.setOptional(at, i, "bindMatrix"), m.setOptional(at, i, "bindMatrixInverse");
                const t = i.skeleton;
                if (t) {
                    const e = t.bones;
                    if (G.floatVertexTextures) {
                        if (void 0 === t.boneTexture) {
                            let n = Math.sqrt(4 * e.length);
                            n = on.ceilPowerOfTwo(n), n = Math.max(n, 4);
                            const i = new Float32Array(n * n * 4);
                            i.set(t.boneMatrices);
                            const r = new qr(i, n, n, 1023, 1015);
                            t.boneMatrices = i, t.boneTexture = r, t.boneTextureSize = n
                        }
                        m.setValue(at, "boneTexture", t.boneTexture, X), m.setValue(at, "boneTextureSize", t.boneTextureSize)
                    } else m.setOptional(at, t, "boneMatrices")
                }
            }
            var v, b;
            return (u || a.receiveShadow !== i.receiveShadow) && (a.receiveShadow = i.receiveShadow, m.setValue(at, "receiveShadow", i.receiveShadow)), u && (m.setValue(at, "toneMappingExposure", f.toneMappingExposure), a.needsLights && (b = h, (v = g).ambientLightColor.needsUpdate = b, v.lightProbe.needsUpdate = b, v.directionalLights.needsUpdate = b, v.directionalLightShadows.needsUpdate = b, v.pointLights.needsUpdate = b, v.pointLightShadows.needsUpdate = b, v.spotLights.needsUpdate = b, v.spotLightShadows.needsUpdate = b, v.rectAreaLights.needsUpdate = b, v.hemisphereLights.needsUpdate = b), r && n.fog && K.refreshFogUniforms(g, r), K.refreshMaterialUniforms(g, n, o, A, C), void 0 !== g.ltc_1 && (g.ltc_1.value = $r.LTC_1), void 0 !== g.ltc_2 && (g.ltc_2.value = $r.LTC_2), ds.upload(at, a.uniformsList, g, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ds.upload(at, a.uniformsList, g, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && m.setValue(at, "center", i.center), m.setValue(at, "modelViewMatrix", i.modelViewMatrix), m.setValue(at, "normalMatrix", i.normalMatrix), m.setValue(at, "modelMatrix", i.matrixWorld), d
        }
        vt.setAnimationLoop((function(t) {
            ut.isPresenting || gt && gt(t)
        })), "undefined" != typeof window && vt.setContext(window), this.setAnimationLoop = function(t) {
            gt = t, ut.setAnimationLoop(t), null === t ? vt.stop() : vt.start()
        }, this.render = function(t, e) {
            let n, i;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === d) return;
            st.resetDefaultState(), x = -1, w = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === ut.enabled && !0 === ut.isPresenting && (e = ut.getCamera(e)), !0 === t.isScene && t.onBeforeRender(f, t, e, n || y), p = tt.get(t, e), p.init(), B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), D.setFromProjectionMatrix(B), U = this.localClippingEnabled, k = N.init(this.clippingPlanes, U, e), h = Q.get(t, e), h.init(), yt(t, e, 0, f.sortObjects), h.finish(), !0 === f.sortObjects && h.sort(L, P), !0 === k && N.beginShadows();
            const r = p.state.shadowsArray;
            ht.render(r, t, e), p.setupLights(e), !0 === k && N.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), et.render(h, t, e, i);
            const o = h.opaque,
                s = h.transparent;
            o.length > 0 && bt(o, t, e), s.length > 0 && bt(s, t, e), !0 === t.isScene && t.onAfterRender(f, t, e), null !== y && (X.updateRenderTargetMipmap(y), X.updateMultisampleRenderTarget(y)), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), h = null, p = null
        }, this.setFramebuffer = function(t) {
            m !== t && null === y && at.bindFramebuffer(36160, t), m = t
        }, this.getActiveCubeFace = function() {
            return g
        }, this.getActiveMipmapLevel = function() {
            return v
        }, this.getRenderTarget = function() {
            return y
        }, this.setRenderTarget = function(t, e, n) {
            y = t, g = e, v = n, t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t);
            let i = m,
                r = !1;
            if (t) {
                const n = q.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget ? (i = n[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : n, M.copy(t.viewport), S.copy(t.scissor), T = t.scissorTest
            } else M.copy(O).multiplyScalar(A).floor(), S.copy(R).multiplyScalar(A).floor(), T = I;
            if (b !== i && (at.bindFramebuffer(36160, i), b = i), V.viewport(M), V.scissor(S), V.setScissorTest(T), r) {
                const i = q.get(t.texture);
                at.framebufferTexture2D(36160, 36064, 34069 + (e || 0), i.__webglTexture, n || 0)
            }
        }, this.readRenderTargetPixels = function(t, e, n, i, r, o, s) {
            if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let a = q.get(t).__webglFramebuffer;
            if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
                let s = !1;
                a !== b && (at.bindFramebuffer(36160, a), s = !0);
                try {
                    const a = t.texture,
                        c = a.format,
                        l = a.type;
                    if (1023 !== c && ot.convert(c) !== at.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!(1009 === l || ot.convert(l) === at.getParameter(35738) || 1015 === l && (G.isWebGL2 || H.get("OES_texture_float") || H.get("WEBGL_color_buffer_float")) || 1016 === l && (G.isWebGL2 ? H.get("EXT_color_buffer_float") : H.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    36053 === at.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && at.readPixels(e, n, i, r, ot.convert(c), ot.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    s && at.bindFramebuffer(36160, b)
                }
            }
        }, this.copyFramebufferToTexture = function(t, e, n) {
            void 0 === n && (n = 0);
            const i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                o = Math.floor(e.image.height * i),
                s = ot.convert(e.format);
            X.setTexture2D(e, 0), at.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0), V.unbindTexture()
        }, this.copyTextureToTexture = function(t, e, n, i) {
            void 0 === i && (i = 0);
            const r = e.image.width,
                o = e.image.height,
                s = ot.convert(n.format),
                a = ot.convert(n.type);
            X.setTexture2D(n, 0), at.pixelStorei(37440, n.flipY), at.pixelStorei(37441, n.premultiplyAlpha), at.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? at.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? at.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : at.texSubImage2D(3553, i, t.x, t.y, s, a, e.image), 0 === i && n.generateMipmaps && at.generateMipmap(3553), V.unbindTexture()
        }, this.initTexture = function(t) {
            X.setTexture2D(t, 0), V.unbindTexture()
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }

    function oa(t) {
        ra.call(this, t)
    }

    function sa(t, e) {
        this.name = "", this.color = new Ni(t), this.density = void 0 !== e ? e : 25e-5
    }

    function aa(t, e, n) {
        this.name = "", this.color = new Ni(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
    }

    function ca(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = on.generateUUID()
    }
    Qs.prototype = Object.assign(Object.create(Gr.prototype), {
        constructor: Qs,
        isArrayCamera: !0
    }), ta.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: ta,
        isGroup: !0
    }), Object.assign(ea.prototype, {
        constructor: ea,
        getTargetRaySpace: function() {
            return null === this._targetRay && (this._targetRay = new ta, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
        },
        getGripSpace: function() {
            return null === this._grip && (this._grip = new ta, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
        },
        dispatchEvent: function(t) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), this
        },
        disconnect: function(t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), this
        },
        update: function(t, e, n) {
            let i = null,
                r = null;
            const o = this._targetRay,
                s = this._grip;
            return t && (null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), null !== s && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)))), null !== o && (o.visible = null !== i), null !== s && (s.visible = null !== r), this
        }
    }), Object.assign(na.prototype, nn.prototype), oa.prototype = Object.assign(Object.create(ra.prototype), {
        constructor: oa,
        isWebGL1Renderer: !0
    }), Object.assign(sa.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new sa(this.color, this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }), Object.assign(aa.prototype, {
        isFog: !0,
        clone: function() {
            return new aa(this.color, this.near, this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }), Object.defineProperty(ca.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(ca.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(t) {
            return this.usage = t, this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
        },
        copyAt: function(t, e, n) {
            t *= this.stride, n *= e.stride;
            for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        clone: function(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = on.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new ca(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
            return e.setUsage(this.usage), e
        },
        onUpload: function(t) {
            return this.onUploadCallback = t, this
        },
        toJSON: function(t) {
            return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = on.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    });
    const la = new yn;

    function ua(t, e, n, i) {
        this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
    }

    function ha(t) {
        ji.call(this), this.type = "SpriteMaterial", this.color = new Ni(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
    }
    let pa;
    Object.defineProperties(ua.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }), Object.assign(ua.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function(t) {
            for (let e = 0, n = this.data.count; e < n; e++) la.x = this.getX(e), la.y = this.getY(e), la.z = this.getZ(e), la.applyMatrix4(t), this.setXYZ(e, la.x, la.y, la.z);
            return this
        },
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e, this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e, this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e, this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e, this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
        },
        setXYZ: function(t, e, n, i) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
        },
        setXYZW: function(t, e, n, i, r) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
        },
        clone: function(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                }
                return new Wi(new this.array.constructor(t), this.itemSize, this.normalized)
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ua(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        },
        toJSON: function(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }), ha.prototype = Object.create(ji.prototype), ha.prototype.constructor = ha, ha.prototype.isSpriteMaterial = !0, ha.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
    };
    const fa = new yn,
        da = new yn,
        ma = new yn,
        ga = new sn,
        va = new sn,
        ya = new En,
        ba = new yn,
        xa = new yn,
        wa = new yn,
        _a = new sn,
        Ma = new sn,
        Sa = new sn;

    function Ta(t) {
        if (Vn.call(this), this.type = "Sprite", void 0 === pa) {
            pa = new ur;
            const t = new ca(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
            pa.setIndex([0, 1, 2, 0, 2, 3]), pa.setAttribute("position", new ua(t, 3, 0, !1)), pa.setAttribute("uv", new ua(t, 2, 3, !1))
        }
        this.geometry = pa, this.material = void 0 !== t ? t : new ha, this.center = new sn(.5, .5)
    }

    function Ea(t, e, n, i, r, o) {
        ga.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (va.x = o * ga.x - r * ga.y, va.y = r * ga.x + o * ga.y) : va.copy(ga), t.copy(e), t.x += va.x, t.y += va.y, t.applyMatrix4(ya)
    }
    Ta.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: Ta,
        isSprite: !0,
        raycast: function(t, e) {
            null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), da.setFromMatrixScale(this.matrixWorld), ya.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ma.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && da.multiplyScalar(-ma.z);
            const n = this.material.rotation;
            let i, r;
            0 !== n && (r = Math.cos(n), i = Math.sin(n));
            const o = this.center;
            Ea(ba.set(-.5, -.5, 0), ma, o, da, i, r), Ea(xa.set(.5, -.5, 0), ma, o, da, i, r), Ea(wa.set(.5, .5, 0), ma, o, da, i, r), _a.set(0, 0), Ma.set(1, 0), Sa.set(1, 1);
            let s = t.ray.intersectTriangle(ba, xa, wa, !1, fa);
            if (null === s && (Ea(xa.set(-.5, .5, 0), ma, o, da, i, r), Ma.set(0, 1), s = t.ray.intersectTriangle(ba, wa, xa, !1, fa), null === s)) return;
            const a = t.ray.origin.distanceTo(fa);
            a < t.near || a > t.far || e.push({
                distance: a,
                point: fa.clone(),
                uv: Oi.getUV(fa, ba, xa, wa, _a, Ma, Sa, new sn),
                face: null,
                object: this
            })
        },
        copy: function(t) {
            return Vn.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
        }
    });
    const Ca = new yn,
        Aa = new yn;

    function La() {
        Vn.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }), this.autoUpdate = !0
    }

    function Pa(t, e) {
        t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Ar.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new En, this.bindMatrixInverse = new En
    }
    La.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: La,
        isLOD: !0,
        copy: function(t) {
            Vn.prototype.copy.call(this, t, !1);
            const e = t.levels;
            for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this.autoUpdate = t.autoUpdate, this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0), e = Math.abs(e);
            const n = this.levels;
            let i;
            for (i = 0; i < n.length && !(e < n[i].distance); i++);
            return n.splice(i, 0, {
                distance: e,
                object: t
            }), this.add(t), this
        },
        getCurrentLevel: function() {
            return this._currentLevel
        },
        getObjectForDistance: function(t) {
            const e = this.levels;
            if (e.length > 0) {
                let n, i;
                for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                return e[n - 1].object
            }
            return null
        },
        raycast: function(t, e) {
            if (this.levels.length > 0) {
                Ca.setFromMatrixPosition(this.matrixWorld);
                const n = t.ray.origin.distanceTo(Ca);
                this.getObjectForDistance(n).raycast(t, e)
            }
        },
        update: function(t) {
            const e = this.levels;
            if (e.length > 1) {
                Ca.setFromMatrixPosition(t.matrixWorld), Aa.setFromMatrixPosition(this.matrixWorld);
                const n = Ca.distanceTo(Aa) / t.zoom;
                let i, r;
                for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
            }
        },
        toJSON: function(t) {
            const e = Vn.prototype.toJSON.call(this, t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
            const n = this.levels;
            for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                e.object.levels.push({
                    object: i.object.uuid,
                    distance: i.distance
                })
            }
            return e
        }
    }), Pa.prototype = Object.assign(Object.create(Ar.prototype), {
        constructor: Pa,
        isSkinnedMesh: !0,
        copy: function(t) {
            return Ar.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
        },
        bind: function(t, e) {
            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            const t = new pn,
                e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
                t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                const i = 1 / t.manhattanLength();
                i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
            }
        },
        updateMatrixWorld: function(t) {
            Ar.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        boneTransform: function() {
            const t = new yn,
                e = new pn,
                n = new pn,
                i = new yn,
                r = new En;
            return function(o, s) {
                const a = this.skeleton,
                    c = this.geometry;
                e.fromBufferAttribute(c.attributes.skinIndex, o), n.fromBufferAttribute(c.attributes.skinWeight, o), t.fromBufferAttribute(c.attributes.position, o).applyMatrix4(this.bindMatrix), s.set(0, 0, 0);
                for (let o = 0; o < 4; o++) {
                    const c = n.getComponent(o);
                    if (0 !== c) {
                        const n = e.getComponent(o);
                        r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]), s.addScaledVector(i.copy(t).applyMatrix4(r), c)
                    }
                }
                return s.applyMatrix4(this.bindMatrixInverse)
            }
        }()
    });
    const Oa = new En,
        Ra = new En;

    function Ia(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new En)
        }
    }

    function Da() {
        Vn.call(this), this.type = "Bone"
    }
    Object.assign(Ia.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = new En;
                this.bones[t] && e.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(e)
            }
        },
        pose: function() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = this.bones[t];
                e && e.matrixWorld.getInverse(this.boneInverses[t])
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = this.bones[t];
                e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
            }
        },
        update: function() {
            const t = this.bones,
                e = this.boneInverses,
                n = this.boneMatrices,
                i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
                const r = t[i] ? t[i].matrixWorld : Ra;
                Oa.multiplyMatrices(r, e[i]), Oa.toArray(n, 16 * i)
            }
            void 0 !== i && (i.needsUpdate = !0)
        },
        clone: function() {
            return new Ia(this.bones, this.boneInverses)
        },
        getBoneByName: function(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
                const n = this.bones[e];
                if (n.name === t) return n
            }
        },
        dispose: function() {
            this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
        }
    }), Da.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: Da,
        isBone: !0
    });
    const Na = new En,
        ka = new En,
        Ua = [],
        Ba = new Ar;

    function za(t, e, n) {
        Ar.call(this, t, e), this.instanceMatrix = new Wi(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1
    }

    function Fa(t) {
        ji.call(this), this.type = "LineBasicMaterial", this.color = new Ni(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
    }
    za.prototype = Object.assign(Object.create(Ar.prototype), {
        constructor: za,
        isInstancedMesh: !0,
        copy: function(t) {
            return Ar.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this
        },
        getMatrixAt: function(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t)
        },
        raycast: function(t, e) {
            const n = this.matrixWorld,
                i = this.count;
            if (Ba.geometry = this.geometry, Ba.material = this.material, void 0 !== Ba.material)
                for (let r = 0; r < i; r++) {
                    this.getMatrixAt(r, Na), ka.multiplyMatrices(n, Na), Ba.matrixWorld = ka, Ba.raycast(t, Ua);
                    for (let t = 0, n = Ua.length; t < n; t++) {
                        const n = Ua[t];
                        n.instanceId = r, n.object = this, e.push(n)
                    }
                    Ua.length = 0
                }
        },
        setMatrixAt: function(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t)
        },
        updateMorphTargets: function() {}
    }), Fa.prototype = Object.create(ji.prototype), Fa.prototype.constructor = Fa, Fa.prototype.isLineBasicMaterial = !0, Fa.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
    };
    const ja = new yn,
        Ha = new yn,
        Ga = new En,
        Va = new gi,
        Wa = new ci;

    function qa(t, e, n) {
        1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Vn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new ur, this.material = void 0 !== e ? e : new Fa, this.updateMorphTargets()
    }
    qa.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: qa,
        isLine: !0,
        copy: function(t) {
            return Vn.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
        },
        computeLineDistances: function() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [0];
                    for (let t = 1, i = e.count; t < i; t++) ja.fromBufferAttribute(e, t - 1), Ha.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += ja.distanceTo(Ha);
                    t.setAttribute("lineDistance", new Qi(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                const e = t.vertices,
                    n = t.lineDistances;
                n[0] = 0;
                for (let t = 1, i = e.length; t < i; t++) n[t] = n[t - 1], n[t] += e[t - 1].distanceTo(e[t])
            }
            return this
        },
        raycast: function(t, e) {
            const n = this.geometry,
                i = this.matrixWorld,
                r = t.params.Line.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), Wa.copy(n.boundingSphere), Wa.applyMatrix4(i), Wa.radius += r, !1 === t.ray.intersectsSphere(Wa)) return;
            Ga.getInverse(i), Va.copy(t.ray).applyMatrix4(Ga);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                s = o * o,
                a = new yn,
                c = new yn,
                l = new yn,
                u = new yn,
                h = this && this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
                const i = n.index,
                    r = n.attributes.position.array;
                if (null !== i) {
                    const n = i.array;
                    for (let i = 0, o = n.length - 1; i < o; i += h) {
                        const o = n[i],
                            h = n[i + 1];
                        a.fromArray(r, 3 * o), c.fromArray(r, 3 * h);
                        if (Va.distanceSqToSegment(a, c, u, l) > s) continue;
                        u.applyMatrix4(this.matrixWorld);
                        const p = t.ray.origin.distanceTo(u);
                        p < t.near || p > t.far || e.push({
                            distance: p,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else
                    for (let n = 0, i = r.length / 3 - 1; n < i; n += h) {
                        a.fromArray(r, 3 * n), c.fromArray(r, 3 * n + 3);
                        if (Va.distanceSqToSegment(a, c, u, l) > s) continue;
                        u.applyMatrix4(this.matrixWorld);
                        const i = t.ray.origin.distanceTo(u);
                        i < t.near || i > t.far || e.push({
                            distance: i,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
            } else if (n.isGeometry) {
                const i = n.vertices,
                    r = i.length;
                for (let n = 0; n < r - 1; n += h) {
                    if (Va.distanceSqToSegment(i[n], i[n + 1], u, l) > s) continue;
                    u.applyMatrix4(this.matrixWorld);
                    const r = t.ray.origin.distanceTo(u);
                    r < t.near || r > t.far || e.push({
                        distance: r,
                        point: l.clone().applyMatrix4(this.matrixWorld),
                        index: n,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            }
        },
        updateMorphTargets: function() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes,
                    n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    });
    const Xa = new yn,
        Za = new yn;

    function Ya(t, e) {
        qa.call(this, t, e), this.type = "LineSegments"
    }

    function $a(t, e) {
        qa.call(this, t, e), this.type = "LineLoop"
    }

    function Ja(t) {
        ji.call(this), this.type = "PointsMaterial", this.color = new Ni(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
    }
    Ya.prototype = Object.assign(Object.create(qa.prototype), {
        constructor: Ya,
        isLineSegments: !0,
        computeLineDistances: function() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [];
                    for (let t = 0, i = e.count; t < i; t += 2) Xa.fromBufferAttribute(e, t), Za.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Xa.distanceTo(Za);
                    t.setAttribute("lineDistance", new Qi(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                const e = t.vertices,
                    n = t.lineDistances;
                for (let t = 0, i = e.length; t < i; t += 2) Xa.copy(e[t]), Za.copy(e[t + 1]), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Xa.distanceTo(Za)
            }
            return this
        }
    }), $a.prototype = Object.assign(Object.create(qa.prototype), {
        constructor: $a,
        isLineLoop: !0
    }), Ja.prototype = Object.create(ji.prototype), Ja.prototype.constructor = Ja, Ja.prototype.isPointsMaterial = !0, Ja.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
    };
    const Ka = new En,
        Qa = new gi,
        tc = new ci,
        ec = new yn;

    function nc(t, e) {
        Vn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new ur, this.material = void 0 !== e ? e : new Ja, this.updateMorphTargets()
    }

    function ic(t, e, n, i, r, o, s) {
        const a = Qa.distanceSqToPoint(t);
        if (a < n) {
            const n = new yn;
            Qa.closestPointToPoint(t, n), n.applyMatrix4(i);
            const c = r.ray.origin.distanceTo(n);
            if (c < r.near || c > r.far) return;
            o.push({
                distance: c,
                distanceToRay: Math.sqrt(a),
                point: n,
                index: e,
                face: null,
                object: s
            })
        }
    }

    function rc(t, e, n, i, r, o, s, a, c) {
        hn.call(this, t, e, n, i, r, o, s, a, c), this.format = void 0 !== s ? s : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
    }

    function oc(t, e, n, i, r, o, s, a, c, l, u, h) {
        hn.call(this, null, o, s, a, c, l, i, r, u, h), this.image = {
            width: e,
            height: n
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }

    function sc(t, e, n, i, r, o, s, a, c) {
        hn.call(this, t, e, n, i, r, o, s, a, c), this.needsUpdate = !0
    }

    function ac(t, e, n, i, r, o, s, a, c, l) {
        if (1026 !== (l = void 0 !== l ? l : 1026) && 1027 !== l) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && 1026 === l && (n = 1012), void 0 === n && 1027 === l && (n = 1020), hn.call(this, null, i, r, o, s, a, l, n, c), this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== a ? a : 1003, this.flipY = !1, this.generateMipmaps = !1
    }

    function cc(t) {
        ur.call(this), this.type = "WireframeGeometry";
        const e = [],
            n = [0, 0],
            i = {},
            r = ["a", "b", "c"];
        if (t && t.isGeometry) {
            const o = t.faces;
            for (let t = 0, e = o.length; t < e; t++) {
                const e = o[t];
                for (let t = 0; t < 3; t++) {
                    const o = e[r[t]],
                        s = e[r[(t + 1) % 3]];
                    n[0] = Math.min(o, s), n[1] = Math.max(o, s);
                    const a = n[0] + "," + n[1];
                    void 0 === i[a] && (i[a] = {
                        index1: n[0],
                        index2: n[1]
                    })
                }
            }
            for (const n in i) {
                const r = i[n];
                let o = t.vertices[r.index1];
                e.push(o.x, o.y, o.z), o = t.vertices[r.index2], e.push(o.x, o.y, o.z)
            }
        } else if (t && t.isBufferGeometry) {
            let r = new yn;
            if (null !== t.index) {
                const o = t.attributes.position,
                    s = t.index;
                let a = t.groups;
                0 === a.length && (a = [{
                    start: 0,
                    count: s.count,
                    materialIndex: 0
                }]);
                for (let t = 0, e = a.length; t < e; ++t) {
                    const e = a[t],
                        r = e.start;
                    for (let t = r, o = r + e.count; t < o; t += 3)
                        for (let e = 0; e < 3; e++) {
                            const r = s.getX(t + e),
                                o = s.getX(t + (e + 1) % 3);
                            n[0] = Math.min(r, o), n[1] = Math.max(r, o);
                            const a = n[0] + "," + n[1];
                            void 0 === i[a] && (i[a] = {
                                index1: n[0],
                                index2: n[1]
                            })
                        }
                }
                for (const t in i) {
                    const n = i[t];
                    r.fromBufferAttribute(o, n.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(o, n.index2), e.push(r.x, r.y, r.z)
                }
            } else {
                const n = t.attributes.position;
                for (let t = 0, i = n.count / 3; t < i; t++)
                    for (let i = 0; i < 3; i++) {
                        const o = 3 * t + i;
                        r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z);
                        const s = 3 * t + (i + 1) % 3;
                        r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z)
                    }
            }
        }
        this.setAttribute("position", new Qi(e, 3))
    }

    function lc(t, e, n) {
        Nr.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: n
        }, this.fromBufferGeometry(new uc(t, e, n)), this.mergeVertices()
    }

    function uc(t, e, n) {
        ur.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        const i = [],
            r = [],
            o = [],
            s = [],
            a = 1e-5,
            c = new yn,
            l = new yn,
            u = new yn,
            h = new yn,
            p = new yn;
        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        const f = e + 1;
        for (let i = 0; i <= n; i++) {
            const f = i / n;
            for (let n = 0; n <= e; n++) {
                const i = n / e;
                t(i, f, l), r.push(l.x, l.y, l.z), i - a >= 0 ? (t(i - a, f, u), h.subVectors(l, u)) : (t(i + a, f, u), h.subVectors(u, l)), f - a >= 0 ? (t(i, f - a, u), p.subVectors(l, u)) : (t(i, f + a, u), p.subVectors(u, l)), c.crossVectors(h, p).normalize(), o.push(c.x, c.y, c.z), s.push(i, f)
            }
        }
        for (let t = 0; t < n; t++)
            for (let n = 0; n < e; n++) {
                const e = t * f + n,
                    r = t * f + n + 1,
                    o = (t + 1) * f + n + 1,
                    s = (t + 1) * f + n;
                i.push(e, r, s), i.push(r, o, s)
            }
        this.setIndex(i), this.setAttribute("position", new Qi(r, 3)), this.setAttribute("normal", new Qi(o, 3)), this.setAttribute("uv", new Qi(s, 2))
    }

    function hc(t, e, n, i) {
        Nr.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        }, this.fromBufferGeometry(new pc(t, e, n, i)), this.mergeVertices()
    }

    function pc(t, e, n, i) {
        ur.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        }, n = n || 1;
        const r = [],
            o = [];

        function s(t, e, n, i) {
            const r = Math.pow(2, i),
                o = [];
            for (let i = 0; i <= r; i++) {
                o[i] = [];
                const s = t.clone().lerp(n, i / r),
                    a = e.clone().lerp(n, i / r),
                    c = r - i;
                for (let t = 0; t <= c; t++) o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / c)
            }
            for (let t = 0; t < r; t++)
                for (let e = 0; e < 2 * (r - t) - 1; e++) {
                    const n = Math.floor(e / 2);
                    e % 2 == 0 ? (a(o[t][n + 1]), a(o[t + 1][n]), a(o[t][n])) : (a(o[t][n + 1]), a(o[t + 1][n + 1]), a(o[t + 1][n]))
                }
        }

        function a(t) {
            r.push(t.x, t.y, t.z)
        }

        function c(e, n) {
            const i = 3 * e;
            n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
        }

        function l(t, e, n, i) {
            i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5)
        }

        function u(t) {
            return Math.atan2(t.z, -t.x)
        }! function(t) {
            const n = new yn,
                i = new yn,
                r = new yn;
            for (let o = 0; o < e.length; o += 3) c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), s(n, i, r, t)
        }(i = i || 0),
        function(t) {
            const e = new yn;
            for (let n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
        }(n),
        function() {
            const t = new yn;
            for (let n = 0; n < r.length; n += 3) {
                t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2];
                const i = u(t) / 2 / Math.PI + .5,
                    s = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                o.push(i, 1 - s)
            }
            var e;
            (function() {
                const t = new yn,
                    e = new yn,
                    n = new yn,
                    i = new yn,
                    s = new sn,
                    a = new sn,
                    c = new sn;
                for (let h = 0, p = 0; h < r.length; h += 9, p += 6) {
                    t.set(r[h + 0], r[h + 1], r[h + 2]), e.set(r[h + 3], r[h + 4], r[h + 5]), n.set(r[h + 6], r[h + 7], r[h + 8]), s.set(o[p + 0], o[p + 1]), a.set(o[p + 2], o[p + 3]), c.set(o[p + 4], o[p + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                    const f = u(i);
                    l(s, p + 0, t, f), l(a, p + 2, e, f), l(c, p + 4, n, f)
                }
            })(),
            function() {
                for (let t = 0; t < o.length; t += 6) {
                    const e = o[t + 0],
                        n = o[t + 2],
                        i = o[t + 4],
                        r = Math.max(e, n, i),
                        s = Math.min(e, n, i);
                    r > .9 && s < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1))
                }
            }()
        }(), this.setAttribute("position", new Qi(r, 3)), this.setAttribute("normal", new Qi(r.slice(), 3)), this.setAttribute("uv", new Qi(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function fc(t, e) {
        Nr.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new dc(t, e)), this.mergeVertices()
    }

    function dc(t, e) {
        pc.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function mc(t, e) {
        Nr.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new gc(t, e)), this.mergeVertices()
    }

    function gc(t, e) {
        pc.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function vc(t, e) {
        Nr.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new yc(t, e)), this.mergeVertices()
    }

    function yc(t, e) {
        const n = (1 + Math.sqrt(5)) / 2,
            i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
        pc.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function bc(t, e) {
        Nr.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new xc(t, e)), this.mergeVertices()
    }

    function xc(t, e) {
        const n = (1 + Math.sqrt(5)) / 2,
            i = 1 / n,
            r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
        pc.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function wc(t, e, n, i, r, o) {
        Nr.call(this), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        const s = new _c(t, e, n, i, r);
        this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices()
    }

    function _c(t, e, n, i, r) {
        ur.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r
        }, e = e || 64, n = n || 1, i = i || 8, r = r || !1;
        const o = t.computeFrenetFrames(e, r);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        const s = new yn,
            a = new yn,
            c = new sn;
        let l = new yn;
        const u = [],
            h = [],
            p = [],
            f = [];

        function d(r) {
            l = t.getPointAt(r / e, l);
            const c = o.normals[r],
                p = o.binormals[r];
            for (let t = 0; t <= i; t++) {
                const e = t / i * Math.PI * 2,
                    r = Math.sin(e),
                    o = -Math.cos(e);
                a.x = o * c.x + r * p.x, a.y = o * c.y + r * p.y, a.z = o * c.z + r * p.z, a.normalize(), h.push(a.x, a.y, a.z), s.x = l.x + n * a.x, s.y = l.y + n * a.y, s.z = l.z + n * a.z, u.push(s.x, s.y, s.z)
            }
        }! function() {
            for (let t = 0; t < e; t++) d(t);
            d(!1 === r ? e : 0),
                function() {
                    for (let t = 0; t <= e; t++)
                        for (let n = 0; n <= i; n++) c.x = t / e, c.y = n / i, p.push(c.x, c.y)
                }(),
                function() {
                    for (let t = 1; t <= e; t++)
                        for (let e = 1; e <= i; e++) {
                            const n = (i + 1) * (t - 1) + (e - 1),
                                r = (i + 1) * t + (e - 1),
                                o = (i + 1) * t + e,
                                s = (i + 1) * (t - 1) + e;
                            f.push(n, r, s), f.push(r, o, s)
                        }
                }()
        }(), this.setIndex(f), this.setAttribute("position", new Qi(u, 3)), this.setAttribute("normal", new Qi(h, 3)), this.setAttribute("uv", new Qi(p, 2))
    }

    function Mc(t, e, n, i, r, o, s) {
        Nr.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Sc(t, e, n, i, r, o)), this.mergeVertices()
    }

    function Sc(t, e, n, i, r, o) {
        ur.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
        const s = [],
            a = [],
            c = [],
            l = [],
            u = new yn,
            h = new yn,
            p = new yn,
            f = new yn,
            d = new yn,
            m = new yn,
            g = new yn;
        for (let s = 0; s <= n; ++s) {
            const y = s / n * r * Math.PI * 2;
            v(y, r, o, t, p), v(y + .01, r, o, t, f), m.subVectors(f, p), g.addVectors(f, p), d.crossVectors(m, g), g.crossVectors(d, m), d.normalize(), g.normalize();
            for (let t = 0; t <= i; ++t) {
                const r = t / i * Math.PI * 2,
                    o = -e * Math.cos(r),
                    f = e * Math.sin(r);
                u.x = p.x + (o * g.x + f * d.x), u.y = p.y + (o * g.y + f * d.y), u.z = p.z + (o * g.z + f * d.z), a.push(u.x, u.y, u.z), h.subVectors(u, p).normalize(), c.push(h.x, h.y, h.z), l.push(s / n), l.push(t / i)
            }
        }
        for (let t = 1; t <= n; t++)
            for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                    r = (i + 1) * t + (e - 1),
                    o = (i + 1) * t + e,
                    a = (i + 1) * (t - 1) + e;
                s.push(n, r, a), s.push(r, o, a)
            }

        function v(t, e, n, i, r) {
            const o = Math.cos(t),
                s = Math.sin(t),
                a = n / e * t,
                c = Math.cos(a);
            r.x = i * (2 + c) * .5 * o, r.y = i * (2 + c) * s * .5, r.z = i * Math.sin(a) * .5
        }
        this.setIndex(s), this.setAttribute("position", new Qi(a, 3)), this.setAttribute("normal", new Qi(c, 3)), this.setAttribute("uv", new Qi(l, 2))
    }

    function Tc(t, e, n, i, r) {
        Nr.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        }, this.fromBufferGeometry(new Ec(t, e, n, i, r)), this.mergeVertices()
    }

    function Ec(t, e, n, i, r) {
        ur.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
        const o = [],
            s = [],
            a = [],
            c = [],
            l = new yn,
            u = new yn,
            h = new yn;
        for (let o = 0; o <= n; o++)
            for (let p = 0; p <= i; p++) {
                const f = p / i * r,
                    d = o / n * Math.PI * 2;
                u.x = (t + e * Math.cos(d)) * Math.cos(f), u.y = (t + e * Math.cos(d)) * Math.sin(f), u.z = e * Math.sin(d), s.push(u.x, u.y, u.z), l.x = t * Math.cos(f), l.y = t * Math.sin(f), h.subVectors(u, l).normalize(), a.push(h.x, h.y, h.z), c.push(p / i), c.push(o / n)
            }
        for (let t = 1; t <= n; t++)
            for (let e = 1; e <= i; e++) {
                const n = (i + 1) * t + e - 1,
                    r = (i + 1) * (t - 1) + e - 1,
                    s = (i + 1) * (t - 1) + e,
                    a = (i + 1) * t + e;
                o.push(n, r, a), o.push(r, s, a)
            }
        this.setIndex(o), this.setAttribute("position", new Qi(s, 3)), this.setAttribute("normal", new Qi(a, 3)), this.setAttribute("uv", new Qi(c, 2))
    }
    nc.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: nc,
        isPoints: !0,
        copy: function(t) {
            return Vn.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
        },
        raycast: function(t, e) {
            const n = this.geometry,
                i = this.matrixWorld,
                r = t.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), tc.copy(n.boundingSphere), tc.applyMatrix4(i), tc.radius += r, !1 === t.ray.intersectsSphere(tc)) return;
            Ka.getInverse(i), Qa.copy(t.ray).applyMatrix4(Ka);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                s = o * o;
            if (n.isBufferGeometry) {
                const r = n.index,
                    o = n.attributes.position.array;
                if (null !== r) {
                    const n = r.array;
                    for (let r = 0, a = n.length; r < a; r++) {
                        const a = n[r];
                        ec.fromArray(o, 3 * a), ic(ec, a, s, i, t, e, this)
                    }
                } else
                    for (let n = 0, r = o.length / 3; n < r; n++) ec.fromArray(o, 3 * n), ic(ec, n, s, i, t, e, this)
            } else {
                const r = n.vertices;
                for (let n = 0, o = r.length; n < o; n++) ic(r[n], n, s, i, t, e, this)
            }
        },
        updateMorphTargets: function() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes,
                    n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }), rc.prototype = Object.assign(Object.create(hn.prototype), {
        constructor: rc,
        isVideoTexture: !0,
        update: function() {
            const t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), oc.prototype = Object.create(hn.prototype), oc.prototype.constructor = oc, oc.prototype.isCompressedTexture = !0, sc.prototype = Object.create(hn.prototype), sc.prototype.constructor = sc, sc.prototype.isCanvasTexture = !0, ac.prototype = Object.create(hn.prototype), ac.prototype.constructor = ac, ac.prototype.isDepthTexture = !0, cc.prototype = Object.create(ur.prototype), cc.prototype.constructor = cc, lc.prototype = Object.create(Nr.prototype), lc.prototype.constructor = lc, uc.prototype = Object.create(ur.prototype), uc.prototype.constructor = uc, hc.prototype = Object.create(Nr.prototype), hc.prototype.constructor = hc, pc.prototype = Object.create(ur.prototype), pc.prototype.constructor = pc, fc.prototype = Object.create(Nr.prototype), fc.prototype.constructor = fc, dc.prototype = Object.create(pc.prototype), dc.prototype.constructor = dc, mc.prototype = Object.create(Nr.prototype), mc.prototype.constructor = mc, gc.prototype = Object.create(pc.prototype), gc.prototype.constructor = gc, vc.prototype = Object.create(Nr.prototype), vc.prototype.constructor = vc, yc.prototype = Object.create(pc.prototype), yc.prototype.constructor = yc, bc.prototype = Object.create(Nr.prototype), bc.prototype.constructor = bc, xc.prototype = Object.create(pc.prototype), xc.prototype.constructor = xc, wc.prototype = Object.create(Nr.prototype), wc.prototype.constructor = wc, _c.prototype = Object.create(ur.prototype), _c.prototype.constructor = _c, _c.prototype.toJSON = function() {
        const t = ur.prototype.toJSON.call(this);
        return t.path = this.parameters.path.toJSON(), t
    }, Mc.prototype = Object.create(Nr.prototype), Mc.prototype.constructor = Mc, Sc.prototype = Object.create(ur.prototype), Sc.prototype.constructor = Sc, Tc.prototype = Object.create(Nr.prototype), Tc.prototype.constructor = Tc, Ec.prototype = Object.create(ur.prototype), Ec.prototype.constructor = Ec;
    const Cc = function(t, e, n) {
        n = n || 2;
        let i, r, o, s, a, c, l, u = e && e.length,
            h = u ? e[0] * n : t.length,
            p = Ac(t, 0, h, n, !0),
            f = [];
        if (!p || p.next === p.prev) return f;
        if (u && (p = function(t, e, n, i) {
                let r, o, s, a, c, l = [];
                for (r = 0, o = e.length; r < o; r++) s = e[r] * i, a = r < o - 1 ? e[r + 1] * i : t.length, c = Ac(t, s, a, i, !1), c === c.next && (c.steiner = !0), l.push(zc(c));
                for (l.sort(Nc), r = 0; r < l.length; r++) kc(l[r], n), n = Lc(n, n.next);
                return n
            }(t, e, p, n)), t.length > 80 * n) {
            i = o = t[0], r = s = t[1];
            for (let e = n; e < h; e += n) a = t[e], c = t[e + 1], a < i && (i = a), c < r && (r = c), a > o && (o = a), c > s && (s = c);
            l = Math.max(o - i, s - r), l = 0 !== l ? 1 / l : 0
        }
        return Pc(p, f, n, i, r, l), f
    };

    function Ac(t, e, n, i, r) {
        let o, s;
        if (r === function(t, e, n, i) {
                let r = 0;
                for (let o = e, s = n - i; o < n; o += i) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
                return r
            }(t, e, n, i) > 0)
            for (o = e; o < n; o += i) s = Yc(o, t[o], t[o + 1], s);
        else
            for (o = n - i; o >= e; o -= i) s = Yc(o, t[o], t[o + 1], s);
        return s && Gc(s, s.next) && ($c(s), s = s.next), s
    }

    function Lc(t, e) {
        if (!t) return t;
        e || (e = t);
        let n, i = t;
        do {
            if (n = !1, i.steiner || !Gc(i, i.next) && 0 !== Hc(i.prev, i, i.next)) i = i.next;
            else {
                if ($c(i), i = e = i.prev, i === i.next) break;
                n = !0
            }
        } while (n || i !== e);
        return e
    }

    function Pc(t, e, n, i, r, o, s) {
        if (!t) return;
        !s && o && function(t, e, n, i) {
            let r = t;
            do {
                null === r.z && (r.z = Bc(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
            } while (r !== t);
            r.prevZ.nextZ = null, r.prevZ = null,
                function(t) {
                    let e, n, i, r, o, s, a, c, l = 1;
                    do {
                        for (n = t, t = null, o = null, s = 0; n;) {
                            for (s++, i = n, a = 0, e = 0; e < l && (a++, i = i.nextZ, i); e++);
                            for (c = l; a > 0 || c > 0 && i;) 0 !== a && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                            n = i
                        }
                        o.nextZ = null, l *= 2
                    } while (s > 1)
                }(r)
        }(t, i, r, o);
        let a, c, l = t;
        for (; t.prev !== t.next;)
            if (a = t.prev, c = t.next, o ? Rc(t, i, r, o) : Oc(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), $c(t), t = c.next, l = c.next;
            else if ((t = c) === l) {
            s ? 1 === s ? Pc(t = Ic(Lc(t), e, n), e, n, i, r, o, 2) : 2 === s && Dc(t, e, n, i, r, o) : Pc(Lc(t), e, n, i, r, o, 1);
            break
        }
    }

    function Oc(t) {
        let e = t.prev,
            n = t,
            i = t.next;
        if (Hc(e, n, i) >= 0) return !1;
        let r = t.next.next;
        for (; r !== t.prev;) {
            if (Fc(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Hc(r.prev, r, r.next) >= 0) return !1;
            r = r.next
        }
        return !0
    }

    function Rc(t, e, n, i) {
        let r = t.prev,
            o = t,
            s = t.next;
        if (Hc(r, o, s) >= 0) return !1;
        let a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x,
            c = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y,
            l = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x,
            u = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y,
            h = Bc(a, c, e, n, i),
            p = Bc(l, u, e, n, i),
            f = t.prevZ,
            d = t.nextZ;
        for (; f && f.z >= h && d && d.z <= p;) {
            if (f !== t.prev && f !== t.next && Fc(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && Hc(f.prev, f, f.next) >= 0) return !1;
            if (f = f.prevZ, d !== t.prev && d !== t.next && Fc(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) && Hc(d.prev, d, d.next) >= 0) return !1;
            d = d.nextZ
        }
        for (; f && f.z >= h;) {
            if (f !== t.prev && f !== t.next && Fc(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && Hc(f.prev, f, f.next) >= 0) return !1;
            f = f.prevZ
        }
        for (; d && d.z <= p;) {
            if (d !== t.prev && d !== t.next && Fc(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) && Hc(d.prev, d, d.next) >= 0) return !1;
            d = d.nextZ
        }
        return !0
    }

    function Ic(t, e, n) {
        let i = t;
        do {
            let r = i.prev,
                o = i.next.next;
            !Gc(r, o) && Vc(r, i, i.next, o) && Xc(r, o) && Xc(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), $c(i), $c(i.next), i = t = o), i = i.next
        } while (i !== t);
        return Lc(i)
    }

    function Dc(t, e, n, i, r, o) {
        let s = t;
        do {
            let t = s.next.next;
            for (; t !== s.prev;) {
                if (s.i !== t.i && jc(s, t)) {
                    let a = Zc(s, t);
                    return s = Lc(s, s.next), a = Lc(a, a.next), Pc(s, e, n, i, r, o), void Pc(a, e, n, i, r, o)
                }
                t = t.next
            }
            s = s.next
        } while (s !== t)
    }

    function Nc(t, e) {
        return t.x - e.x
    }

    function kc(t, e) {
        if (e = function(t, e) {
                let n, i = e,
                    r = t.x,
                    o = t.y,
                    s = -1 / 0;
                do {
                    if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                        let t = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (t <= r && t > s) {
                            if (s = t, t === r) {
                                if (o === i.y) return i;
                                if (o === i.next.y) return i.next
                            }
                            n = i.x < i.next.x ? i : i.next
                        }
                    }
                    i = i.next
                } while (i !== e);
                if (!n) return null;
                if (r === s) return n;
                let a, c = n,
                    l = n.x,
                    u = n.y,
                    h = 1 / 0;
                i = n;
                do {
                    r >= i.x && i.x >= l && r !== i.x && Fc(o < u ? r : s, o, l, u, o < u ? s : r, o, i.x, i.y) && (a = Math.abs(o - i.y) / (r - i.x), Xc(i, t) && (a < h || a === h && (i.x > n.x || i.x === n.x && Uc(n, i))) && (n = i, h = a)), i = i.next
                } while (i !== c);
                return n
            }(t, e)) {
            const n = Zc(e, t);
            Lc(e, e.next), Lc(n, n.next)
        }
    }

    function Uc(t, e) {
        return Hc(t.prev, t, e.prev) < 0 && Hc(e.next, t, t.next) < 0
    }

    function Bc(t, e, n, i, r) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }

    function zc(t) {
        let e = t,
            n = t;
        do {
            (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
        } while (e !== t);
        return n
    }

    function Fc(t, e, n, i, r, o, s, a) {
        return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0
    }

    function jc(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
            let n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Vc(n, n.next, t, e)) return !0;
                n = n.next
            } while (n !== t);
            return !1
        }(t, e) && (Xc(t, e) && Xc(e, t) && function(t, e) {
            let n = t,
                i = !1,
                r = (t.x + e.x) / 2,
                o = (t.y + e.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
            } while (n !== t);
            return i
        }(t, e) && (Hc(t.prev, t, e.prev) || Hc(t, e.prev, e)) || Gc(t, e) && Hc(t.prev, t, t.next) > 0 && Hc(e.prev, e, e.next) > 0)
    }

    function Hc(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }

    function Gc(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function Vc(t, e, n, i) {
        const r = qc(Hc(t, e, n)),
            o = qc(Hc(t, e, i)),
            s = qc(Hc(n, i, t)),
            a = qc(Hc(n, i, e));
        return r !== o && s !== a || (!(0 !== r || !Wc(t, n, e)) || (!(0 !== o || !Wc(t, i, e)) || (!(0 !== s || !Wc(n, t, i)) || !(0 !== a || !Wc(n, e, i)))))
    }

    function Wc(t, e, n) {
        return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
    }

    function qc(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
    }

    function Xc(t, e) {
        return Hc(t.prev, t, t.next) < 0 ? Hc(t, e, t.next) >= 0 && Hc(t, t.prev, e) >= 0 : Hc(t, e, t.prev) < 0 || Hc(t, t.next, e) < 0
    }

    function Zc(t, e) {
        let n = new Jc(t.i, t.x, t.y),
            i = new Jc(e.i, e.x, e.y),
            r = t.next,
            o = e.prev;
        return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
    }

    function Yc(t, e, n, i) {
        const r = new Jc(t, e, n);
        return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
    }

    function $c(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function Jc(t, e, n) {
        this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    const Kc = {
        area: function(t) {
            const e = t.length;
            let n = 0;
            for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
            return .5 * n
        },
        isClockWise: function(t) {
            return Kc.area(t) < 0
        },
        triangulateShape: function(t, e) {
            const n = [],
                i = [],
                r = [];
            Qc(t), tl(n, t);
            let o = t.length;
            e.forEach(Qc);
            for (let t = 0; t < e.length; t++) i.push(o), o += e[t].length, tl(n, e[t]);
            const s = Cc(n, i);
            for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
            return r
        }
    };

    function Qc(t) {
        const e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }

    function tl(t, e) {
        for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
    }

    function el(t, e) {
        Nr.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, this.fromBufferGeometry(new nl(t, e)), this.mergeVertices()
    }

    function nl(t, e) {
        ur.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: t,
            options: e
        }, t = Array.isArray(t) ? t : [t];
        const n = this,
            i = [],
            r = [];
        for (let e = 0, n = t.length; e < n; e++) {
            o(t[e])
        }

        function o(t) {
            const o = [],
                s = void 0 !== e.curveSegments ? e.curveSegments : 12,
                a = void 0 !== e.steps ? e.steps : 1;
            let c = void 0 !== e.depth ? e.depth : 100,
                l = void 0 === e.bevelEnabled || e.bevelEnabled,
                u = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                h = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
                p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                f = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
            const d = e.extrudePath,
                m = void 0 !== e.UVGenerator ? e.UVGenerator : il;
            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
            let g, v, y, b, x, w = !1;
            d && (g = d.getSpacedPoints(a), w = !0, l = !1, v = d.computeFrenetFrames(a, !1), y = new yn, b = new yn, x = new yn), l || (f = 0, u = 0, h = 0, p = 0);
            const _ = t.extractPoints(s);
            let M = _.shape;
            const S = _.holes;
            if (!Kc.isClockWise(M)) {
                M = M.reverse();
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    Kc.isClockWise(e) && (S[t] = e.reverse())
                }
            }
            const T = Kc.triangulateShape(M, S),
                E = M;
            for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                M = M.concat(e)
            }

            function C(t, e, n) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
            }
            const A = M.length,
                L = T.length;

            function P(t, e, n) {
                let i, r, o;
                const s = t.x - e.x,
                    a = t.y - e.y,
                    c = n.x - t.x,
                    l = n.y - t.y,
                    u = s * s + a * a,
                    h = s * l - a * c;
                if (Math.abs(h) > Number.EPSILON) {
                    const h = Math.sqrt(u),
                        p = Math.sqrt(c * c + l * l),
                        f = e.x - a / h,
                        d = e.y + s / h,
                        m = ((n.x - l / p - f) * l - (n.y + c / p - d) * c) / (s * l - a * c);
                    i = f + s * m - t.x, r = d + a * m - t.y;
                    const g = i * i + r * r;
                    if (g <= 2) return new sn(i, r);
                    o = Math.sqrt(g / 2)
                } else {
                    let t = !1;
                    s > Number.EPSILON ? c > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(l) && (t = !0), t ? (i = -a, r = s, o = Math.sqrt(u)) : (i = s, r = a, o = Math.sqrt(u / 2))
                }
                return new sn(i / o, r / o)
            }
            const O = [];
            for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), O[t] = P(E[t], E[n], E[i]);
            const R = [];
            let I, D = O.concat();
            for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                I = [];
                for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), I[t] = P(e[t], e[i], e[r]);
                R.push(I), D = D.concat(I)
            }
            for (let t = 0; t < f; t++) {
                const e = t / f,
                    n = u * Math.cos(e * Math.PI / 2),
                    i = h * Math.sin(e * Math.PI / 2) + p;
                for (let t = 0, e = E.length; t < e; t++) {
                    const e = C(E[t], O[t], i);
                    U(e.x, e.y, -n)
                }
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    I = R[t];
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = C(e[t], I[t], i);
                        U(r.x, r.y, -n)
                    }
                }
            }
            const N = h + p;
            for (let t = 0; t < A; t++) {
                const e = l ? C(M[t], D[t], N) : M[t];
                w ? (b.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), x.copy(g[0]).add(b).add(y), U(x.x, x.y, x.z)) : U(e.x, e.y, 0)
            }
            for (let t = 1; t <= a; t++)
                for (let e = 0; e < A; e++) {
                    const n = l ? C(M[e], D[e], N) : M[e];
                    w ? (b.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), x.copy(g[t]).add(b).add(y), U(x.x, x.y, x.z)) : U(n.x, n.y, c / a * t)
                }
            for (let t = f - 1; t >= 0; t--) {
                const e = t / f,
                    n = u * Math.cos(e * Math.PI / 2),
                    i = h * Math.sin(e * Math.PI / 2) + p;
                for (let t = 0, e = E.length; t < e; t++) {
                    const e = C(E[t], O[t], i);
                    U(e.x, e.y, c + n)
                }
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    I = R[t];
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = C(e[t], I[t], i);
                        w ? U(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : U(r.x, r.y, c + n)
                    }
                }
            }

            function k(t, e) {
                let n = t.length;
                for (; --n >= 0;) {
                    const i = n;
                    let r = n - 1;
                    r < 0 && (r = t.length - 1);
                    for (let t = 0, n = a + 2 * f; t < n; t++) {
                        const n = A * t,
                            o = A * (t + 1);
                        z(e + i + n, e + r + n, e + r + o, e + i + o)
                    }
                }
            }

            function U(t, e, n) {
                o.push(t), o.push(e), o.push(n)
            }

            function B(t, e, r) {
                F(t), F(e), F(r);
                const o = i.length / 3,
                    s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                j(s[0]), j(s[1]), j(s[2])
            }

            function z(t, e, r, o) {
                F(t), F(e), F(o), F(e), F(r), F(o);
                const s = i.length / 3,
                    a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
                j(a[0]), j(a[1]), j(a[3]), j(a[1]), j(a[2]), j(a[3])
            }

            function F(t) {
                i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2])
            }

            function j(t) {
                r.push(t.x), r.push(t.y)
            }! function() {
                const t = i.length / 3;
                if (l) {
                    let t = 0,
                        e = A * t;
                    for (let t = 0; t < L; t++) {
                        const n = T[t];
                        B(n[2] + e, n[1] + e, n[0] + e)
                    }
                    t = a + 2 * f, e = A * t;
                    for (let t = 0; t < L; t++) {
                        const n = T[t];
                        B(n[0] + e, n[1] + e, n[2] + e)
                    }
                } else {
                    for (let t = 0; t < L; t++) {
                        const e = T[t];
                        B(e[2], e[1], e[0])
                    }
                    for (let t = 0; t < L; t++) {
                        const e = T[t];
                        B(e[0] + A * a, e[1] + A * a, e[2] + A * a)
                    }
                }
                n.addGroup(t, i.length / 3 - t, 0)
            }(),
            function() {
                const t = i.length / 3;
                let e = 0;
                k(E, e), e += E.length;
                for (let t = 0, n = S.length; t < n; t++) {
                    const n = S[t];
                    k(n, e), e += n.length
                }
                n.addGroup(t, i.length / 3 - t, 1)
            }()
        }
        this.setAttribute("position", new Qi(i, 3)), this.setAttribute("uv", new Qi(r, 2)), this.computeVertexNormals()
    }
    el.prototype = Object.create(Nr.prototype), el.prototype.constructor = el, el.prototype.toJSON = function() {
        const t = Nr.prototype.toJSON.call(this);
        return rl(this.parameters.shapes, this.parameters.options, t)
    }, nl.prototype = Object.create(ur.prototype), nl.prototype.constructor = nl, nl.prototype.toJSON = function() {
        const t = ur.prototype.toJSON.call(this);
        return rl(this.parameters.shapes, this.parameters.options, t)
    };
    const il = {
        generateTopUV: function(t, e, n, i, r) {
            const o = e[3 * n],
                s = e[3 * n + 1],
                a = e[3 * i],
                c = e[3 * i + 1],
                l = e[3 * r],
                u = e[3 * r + 1];
            return [new sn(o, s), new sn(a, c), new sn(l, u)]
        },
        generateSideWallUV: function(t, e, n, i, r, o) {
            const s = e[3 * n],
                a = e[3 * n + 1],
                c = e[3 * n + 2],
                l = e[3 * i],
                u = e[3 * i + 1],
                h = e[3 * i + 2],
                p = e[3 * r],
                f = e[3 * r + 1],
                d = e[3 * r + 2],
                m = e[3 * o],
                g = e[3 * o + 1],
                v = e[3 * o + 2];
            return Math.abs(a - u) < .01 ? [new sn(s, 1 - c), new sn(l, 1 - h), new sn(p, 1 - d), new sn(m, 1 - v)] : [new sn(a, 1 - c), new sn(u, 1 - h), new sn(f, 1 - d), new sn(g, 1 - v)]
        }
    };

    function rl(t, e, n) {
        if (n.shapes = [], Array.isArray(t))
            for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                n.shapes.push(i.uuid)
            } else n.shapes.push(t.uuid);
        return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
    }

    function ol(t, e) {
        Nr.call(this), this.type = "TextGeometry", this.parameters = {
            text: t,
            parameters: e
        }, this.fromBufferGeometry(new sl(t, e)), this.mergeVertices()
    }

    function sl(t, e) {
        const n = (e = e || {}).font;
        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Nr;
        const i = n.generateShapes(t, e.size);
        e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), nl.call(this, i, e), this.type = "TextBufferGeometry"
    }

    function al(t, e, n, i, r, o, s) {
        Nr.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: s
        }, this.fromBufferGeometry(new cl(t, e, n, i, r, o, s)), this.mergeVertices()
    }

    function cl(t, e, n, i, r, o, s) {
        ur.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: s
        }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI;
        const a = Math.min(o + s, Math.PI);
        let c = 0;
        const l = [],
            u = new yn,
            h = new yn,
            p = [],
            f = [],
            d = [],
            m = [];
        for (let p = 0; p <= n; p++) {
            const g = [],
                v = p / n;
            let y = 0;
            0 == p && 0 == o ? y = .5 / e : p == n && a == Math.PI && (y = -.5 / e);
            for (let n = 0; n <= e; n++) {
                const a = n / e;
                u.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s), u.y = t * Math.cos(o + v * s), u.z = t * Math.sin(i + a * r) * Math.sin(o + v * s), f.push(u.x, u.y, u.z), h.copy(u).normalize(), d.push(h.x, h.y, h.z), m.push(a + y, 1 - v), g.push(c++)
            }
            l.push(g)
        }
        for (let t = 0; t < n; t++)
            for (let i = 0; i < e; i++) {
                const e = l[t][i + 1],
                    r = l[t][i],
                    s = l[t + 1][i],
                    c = l[t + 1][i + 1];
                (0 !== t || o > 0) && p.push(e, r, c), (t !== n - 1 || a < Math.PI) && p.push(r, s, c)
            }
        this.setIndex(p), this.setAttribute("position", new Qi(f, 3)), this.setAttribute("normal", new Qi(d, 3)), this.setAttribute("uv", new Qi(m, 2))
    }

    function ll(t, e, n, i, r, o) {
        Nr.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        }, this.fromBufferGeometry(new ul(t, e, n, i, r, o)), this.mergeVertices()
    }

    function ul(t, e, n, i, r, o) {
        ur.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        const s = [],
            a = [],
            c = [],
            l = [];
        let u = t;
        const h = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
            p = new yn,
            f = new sn;
        for (let t = 0; t <= i; t++) {
            for (let t = 0; t <= n; t++) {
                const i = r + t / n * o;
                p.x = u * Math.cos(i), p.y = u * Math.sin(i), a.push(p.x, p.y, p.z), c.push(0, 0, 1), f.x = (p.x / e + 1) / 2, f.y = (p.y / e + 1) / 2, l.push(f.x, f.y)
            }
            u += h
        }
        for (let t = 0; t < i; t++) {
            const e = t * (n + 1);
            for (let t = 0; t < n; t++) {
                const i = t + e,
                    r = i,
                    o = i + n + 1,
                    a = i + n + 2,
                    c = i + 1;
                s.push(r, o, c), s.push(o, a, c)
            }
        }
        this.setIndex(s), this.setAttribute("position", new Qi(a, 3)), this.setAttribute("normal", new Qi(c, 3)), this.setAttribute("uv", new Qi(l, 2))
    }

    function hl(t, e, n, i) {
        Nr.call(this), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        }, this.fromBufferGeometry(new pl(t, e, n, i)), this.mergeVertices()
    }

    function pl(t, e, n, i) {
        ur.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = on.clamp(i, 0, 2 * Math.PI);
        const r = [],
            o = [],
            s = [],
            a = 1 / e,
            c = new yn,
            l = new sn;
        for (let r = 0; r <= e; r++) {
            const u = n + r * a * i,
                h = Math.sin(u),
                p = Math.cos(u);
            for (let n = 0; n <= t.length - 1; n++) c.x = t[n].x * h, c.y = t[n].y, c.z = t[n].x * p, o.push(c.x, c.y, c.z), l.x = r / e, l.y = n / (t.length - 1), s.push(l.x, l.y)
        }
        for (let n = 0; n < e; n++)
            for (let e = 0; e < t.length - 1; e++) {
                const i = e + n * t.length,
                    o = i,
                    s = i + t.length,
                    a = i + t.length + 1,
                    c = i + 1;
                r.push(o, s, c), r.push(s, a, c)
            }
        if (this.setIndex(r), this.setAttribute("position", new Qi(o, 3)), this.setAttribute("uv", new Qi(s, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
            const n = this.attributes.normal.array,
                i = new yn,
                r = new yn,
                o = new yn,
                s = e * t.length * 3;
            for (let e = 0, a = 0; e < t.length; e++, a += 3) i.x = n[a + 0], i.y = n[a + 1], i.z = n[a + 2], r.x = n[s + a + 0], r.y = n[s + a + 1], r.z = n[s + a + 2], o.addVectors(i, r).normalize(), n[a + 0] = n[s + a + 0] = o.x, n[a + 1] = n[s + a + 1] = o.y, n[a + 2] = n[s + a + 2] = o.z
        }
    }

    function fl(t, e) {
        Nr.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
            shapes: t,
            curveSegments: e
        }, this.fromBufferGeometry(new dl(t, e)), this.mergeVertices()
    }

    function dl(t, e) {
        ur.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: t,
            curveSegments: e
        }, e = e || 12;
        const n = [],
            i = [],
            r = [],
            o = [];
        let s = 0,
            a = 0;
        if (!1 === Array.isArray(t)) c(t);
        else
            for (let e = 0; e < t.length; e++) c(t[e]), this.addGroup(s, a, e), s += a, a = 0;

        function c(t) {
            const s = i.length / 3,
                c = t.extractPoints(e);
            let l = c.shape;
            const u = c.holes;
            !1 === Kc.isClockWise(l) && (l = l.reverse());
            for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t];
                !0 === Kc.isClockWise(e) && (u[t] = e.reverse())
            }
            const h = Kc.triangulateShape(l, u);
            for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t];
                l = l.concat(e)
            }
            for (let t = 0, e = l.length; t < e; t++) {
                const e = l[t];
                i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y)
            }
            for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t],
                    i = e[0] + s,
                    r = e[1] + s,
                    o = e[2] + s;
                n.push(i, r, o), a += 3
            }
        }
        this.setIndex(n), this.setAttribute("position", new Qi(i, 3)), this.setAttribute("normal", new Qi(r, 3)), this.setAttribute("uv", new Qi(o, 2))
    }

    function ml(t, e) {
        if (e.shapes = [], Array.isArray(t))
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.shapes.push(i.uuid)
            } else e.shapes.push(t.uuid);
        return e
    }

    function gl(t, e) {
        ur.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: e
        }, e = void 0 !== e ? e : 1;
        const n = [],
            i = Math.cos(on.DEG2RAD * e),
            r = [0, 0],
            o = {};
        let s, a, c;
        const l = ["a", "b", "c"];
        let u;
        t.isBufferGeometry ? (u = new Nr, u.fromBufferGeometry(t)) : u = t.clone(), u.mergeVertices(), u.computeFaceNormals();
        const h = u.vertices,
            p = u.faces;
        for (let t = 0, e = p.length; t < e; t++) {
            const e = p[t];
            for (let n = 0; n < 3; n++) s = e[l[n]], a = e[l[(n + 1) % 3]], r[0] = Math.min(s, a), r[1] = Math.max(s, a), c = r[0] + "," + r[1], void 0 === o[c] ? o[c] = {
                index1: r[0],
                index2: r[1],
                face1: t,
                face2: void 0
            } : o[c].face2 = t
        }
        for (c in o) {
            const t = o[c];
            if (void 0 === t.face2 || p[t.face1].normal.dot(p[t.face2].normal) <= i) {
                let e = h[t.index1];
                n.push(e.x, e.y, e.z), e = h[t.index2], n.push(e.x, e.y, e.z)
            }
        }
        this.setAttribute("position", new Qi(n, 3))
    }

    function vl(t, e, n, i, r, o, s, a) {
        Nr.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: o,
            thetaStart: s,
            thetaLength: a
        }, this.fromBufferGeometry(new yl(t, e, n, i, r, o, s, a)), this.mergeVertices()
    }

    function yl(t, e, n, i, r, o, s, a) {
        ur.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: o,
            thetaStart: s,
            thetaLength: a
        };
        const c = this;
        t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : 2 * Math.PI;
        const l = [],
            u = [],
            h = [],
            p = [];
        let f = 0;
        const d = [],
            m = n / 2;
        let g = 0;

        function v(n) {
            let r, o;
            const d = new sn,
                v = new yn;
            let y = 0;
            const b = !0 === n ? t : e,
                x = !0 === n ? 1 : -1;
            r = f;
            for (let t = 1; t <= i; t++) u.push(0, m * x, 0), h.push(0, x, 0), p.push(.5, .5), f++;
            o = f;
            for (let t = 0; t <= i; t++) {
                const e = t / i * a + s,
                    n = Math.cos(e),
                    r = Math.sin(e);
                v.x = b * r, v.y = m * x, v.z = b * n, u.push(v.x, v.y, v.z), h.push(0, x, 0), d.x = .5 * n + .5, d.y = .5 * r * x + .5, p.push(d.x, d.y), f++
            }
            for (let t = 0; t < i; t++) {
                const e = r + t,
                    i = o + t;
                !0 === n ? l.push(i, i + 1, e) : l.push(i + 1, i, e), y += 3
            }
            c.addGroup(g, y, !0 === n ? 1 : 2), g += y
        }! function() {
            const o = new yn,
                v = new yn;
            let y = 0;
            const b = (e - t) / n;
            for (let c = 0; c <= r; c++) {
                const l = [],
                    g = c / r,
                    y = g * (e - t) + t;
                for (let t = 0; t <= i; t++) {
                    const e = t / i,
                        r = e * a + s,
                        c = Math.sin(r),
                        d = Math.cos(r);
                    v.x = y * c, v.y = -g * n + m, v.z = y * d, u.push(v.x, v.y, v.z), o.set(c, b, d).normalize(), h.push(o.x, o.y, o.z), p.push(e, 1 - g), l.push(f++)
                }
                d.push(l)
            }
            for (let t = 0; t < i; t++)
                for (let e = 0; e < r; e++) {
                    const n = d[e][t],
                        i = d[e + 1][t],
                        r = d[e + 1][t + 1],
                        o = d[e][t + 1];
                    l.push(n, i, o), l.push(i, r, o), y += 6
                }
            c.addGroup(g, y, 0), g += y
        }(), !1 === o && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(l), this.setAttribute("position", new Qi(u, 3)), this.setAttribute("normal", new Qi(h, 3)), this.setAttribute("uv", new Qi(p, 2))
    }

    function bl(t, e, n, i, r, o, s) {
        vl.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: s
        }
    }

    function xl(t, e, n, i, r, o, s) {
        yl.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeBufferGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: s
        }
    }

    function wl(t, e, n, i) {
        Nr.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        }, this.fromBufferGeometry(new _l(t, e, n, i)), this.mergeVertices()
    }

    function _l(t, e, n, i) {
        ur.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
        const r = [],
            o = [],
            s = [],
            a = [],
            c = new yn,
            l = new sn;
        o.push(0, 0, 0), s.push(0, 0, 1), a.push(.5, .5);
        for (let r = 0, u = 3; r <= e; r++, u += 3) {
            const h = n + r / e * i;
            c.x = t * Math.cos(h), c.y = t * Math.sin(h), o.push(c.x, c.y, c.z), s.push(0, 0, 1), l.x = (o[u] / t + 1) / 2, l.y = (o[u + 1] / t + 1) / 2, a.push(l.x, l.y)
        }
        for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
        this.setIndex(r), this.setAttribute("position", new Qi(o, 3)), this.setAttribute("normal", new Qi(s, 3)), this.setAttribute("uv", new Qi(a, 2))
    }
    ol.prototype = Object.create(Nr.prototype), ol.prototype.constructor = ol, sl.prototype = Object.create(nl.prototype), sl.prototype.constructor = sl, al.prototype = Object.create(Nr.prototype), al.prototype.constructor = al, cl.prototype = Object.create(ur.prototype), cl.prototype.constructor = cl, ll.prototype = Object.create(Nr.prototype), ll.prototype.constructor = ll, ul.prototype = Object.create(ur.prototype), ul.prototype.constructor = ul, hl.prototype = Object.create(Nr.prototype), hl.prototype.constructor = hl, pl.prototype = Object.create(ur.prototype), pl.prototype.constructor = pl, fl.prototype = Object.create(Nr.prototype), fl.prototype.constructor = fl, fl.prototype.toJSON = function() {
        const t = Nr.prototype.toJSON.call(this);
        return ml(this.parameters.shapes, t)
    }, dl.prototype = Object.create(ur.prototype), dl.prototype.constructor = dl, dl.prototype.toJSON = function() {
        const t = ur.prototype.toJSON.call(this);
        return ml(this.parameters.shapes, t)
    }, gl.prototype = Object.create(ur.prototype), gl.prototype.constructor = gl, vl.prototype = Object.create(Nr.prototype), vl.prototype.constructor = vl, yl.prototype = Object.create(ur.prototype), yl.prototype.constructor = yl, bl.prototype = Object.create(vl.prototype), bl.prototype.constructor = bl, xl.prototype = Object.create(yl.prototype), xl.prototype.constructor = xl, wl.prototype = Object.create(Nr.prototype), wl.prototype.constructor = wl, _l.prototype = Object.create(ur.prototype), _l.prototype.constructor = _l;
    var Ml = Object.freeze({
        __proto__: null,
        WireframeGeometry: cc,
        ParametricGeometry: lc,
        ParametricBufferGeometry: uc,
        TetrahedronGeometry: fc,
        TetrahedronBufferGeometry: dc,
        OctahedronGeometry: mc,
        OctahedronBufferGeometry: gc,
        IcosahedronGeometry: vc,
        IcosahedronBufferGeometry: yc,
        DodecahedronGeometry: bc,
        DodecahedronBufferGeometry: xc,
        PolyhedronGeometry: hc,
        PolyhedronBufferGeometry: pc,
        TubeGeometry: wc,
        TubeBufferGeometry: _c,
        TorusKnotGeometry: Mc,
        TorusKnotBufferGeometry: Sc,
        TorusGeometry: Tc,
        TorusBufferGeometry: Ec,
        TextGeometry: ol,
        TextBufferGeometry: sl,
        SphereGeometry: al,
        SphereBufferGeometry: cl,
        RingGeometry: ll,
        RingBufferGeometry: ul,
        PlaneGeometry: Qr,
        PlaneBufferGeometry: to,
        LatheGeometry: hl,
        LatheBufferGeometry: pl,
        ShapeGeometry: fl,
        ShapeBufferGeometry: dl,
        ExtrudeGeometry: el,
        ExtrudeBufferGeometry: nl,
        EdgesGeometry: gl,
        ConeGeometry: bl,
        ConeBufferGeometry: xl,
        CylinderGeometry: vl,
        CylinderBufferGeometry: yl,
        CircleGeometry: wl,
        CircleBufferGeometry: _l,
        BoxGeometry: kr,
        BoxBufferGeometry: Ur
    });

    function Sl(t) {
        ji.call(this), this.type = "ShadowMaterial", this.color = new Ni(0), this.transparent = !0, this.setValues(t)
    }

    function Tl(t) {
        jr.call(this, t), this.type = "RawShaderMaterial"
    }

    function El(t) {
        ji.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Ni(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ni(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t)
    }

    function Cl(t) {
        El.call(this), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new sn(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transparency = 0, this.setValues(t)
    }

    function Al(t) {
        ji.call(this), this.type = "MeshPhongMaterial", this.color = new Ni(16777215), this.specular = new Ni(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ni(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Ll(t) {
        ji.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new Ni(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ni(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Pl(t) {
        ji.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Ol(t) {
        ji.call(this), this.type = "MeshLambertMaterial", this.color = new Ni(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ni(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Rl(t) {
        ji.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Ni(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new sn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Il(t) {
        Fa.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }
    Sl.prototype = Object.create(ji.prototype), Sl.prototype.constructor = Sl, Sl.prototype.isShadowMaterial = !0, Sl.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this
    }, Tl.prototype = Object.create(jr.prototype), Tl.prototype.constructor = Tl, Tl.prototype.isRawShaderMaterial = !0, El.prototype = Object.create(ji.prototype), El.prototype.constructor = El, El.prototype.isMeshStandardMaterial = !0, El.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this
    }, Cl.prototype = Object.create(El.prototype), Cl.prototype.constructor = Cl, Cl.prototype.isMeshPhysicalMaterial = !0, Cl.prototype.copy = function(t) {
        return El.prototype.copy.call(this, t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Ni).copy(t.sheen) : this.sheen = null, this.transparency = t.transparency, this
    }, Al.prototype = Object.create(ji.prototype), Al.prototype.constructor = Al, Al.prototype.isMeshPhongMaterial = !0, Al.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Ll.prototype = Object.create(ji.prototype), Ll.prototype.constructor = Ll, Ll.prototype.isMeshToonMaterial = !0, Ll.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Pl.prototype = Object.create(ji.prototype), Pl.prototype.constructor = Pl, Pl.prototype.isMeshNormalMaterial = !0, Pl.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Ol.prototype = Object.create(ji.prototype), Ol.prototype.constructor = Ol, Ol.prototype.isMeshLambertMaterial = !0, Ol.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Rl.prototype = Object.create(ji.prototype), Rl.prototype.constructor = Rl, Rl.prototype.isMeshMatcapMaterial = !0, Rl.prototype.copy = function(t) {
        return ji.prototype.copy.call(this, t), this.defines = {
            MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Il.prototype = Object.create(Fa.prototype), Il.prototype.constructor = Il, Il.prototype.isLineDashedMaterial = !0, Il.prototype.copy = function(t) {
        return Fa.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    };
    var Dl = Object.freeze({
        __proto__: null,
        ShadowMaterial: Sl,
        SpriteMaterial: ha,
        RawShaderMaterial: Tl,
        ShaderMaterial: jr,
        PointsMaterial: Ja,
        MeshPhysicalMaterial: Cl,
        MeshStandardMaterial: El,
        MeshPhongMaterial: Al,
        MeshToonMaterial: Ll,
        MeshNormalMaterial: Pl,
        MeshLambertMaterial: Ol,
        MeshDepthMaterial: Xs,
        MeshDistanceMaterial: Zs,
        MeshBasicMaterial: Hi,
        MeshMatcapMaterial: Rl,
        LineDashedMaterial: Il,
        LineBasicMaterial: Fa,
        Material: ji
    });
    const Nl = {
        arraySlice: function(t, e, n) {
            return Nl.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        },
        convertArray: function(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            const e = t.length,
                n = new Array(e);
            for (let t = 0; t !== e; ++t) n[t] = t;
            return n.sort((function(e, n) {
                return t[e] - t[n]
            })), n
        },
        sortedArray: function(t, e, n) {
            const i = t.length,
                r = new t.constructor(i);
            for (let o = 0, s = 0; s !== i; ++o) {
                const i = n[o] * e;
                for (let n = 0; n !== e; ++n) r[s++] = t[i + n]
            }
            return r
        },
        flattenJSON: function(t, e, n, i) {
            let r = 1,
                o = t[0];
            for (; void 0 !== o && void 0 === o[i];) o = t[r++];
            if (void 0 === o) return;
            let s = o[i];
            if (void 0 !== s)
                if (Array.isArray(s))
                    do {
                        s = o[i], void 0 !== s && (e.push(o.time), n.push.apply(n, s)), o = t[r++]
                    } while (void 0 !== o);
                else if (void 0 !== s.toArray)
                do {
                    s = o[i], void 0 !== s && (e.push(o.time), s.toArray(n, n.length)), o = t[r++]
                } while (void 0 !== o);
            else
                do {
                    s = o[i], void 0 !== s && (e.push(o.time), n.push(s)), o = t[r++]
                } while (void 0 !== o)
        },
        subclip: function(t, e, n, i, r) {
            r = r || 30;
            const o = t.clone();
            o.name = e;
            const s = [];
            for (let t = 0; t < o.tracks.length; ++t) {
                const e = o.tracks[t],
                    a = e.getValueSize(),
                    c = [],
                    l = [];
                for (let t = 0; t < e.times.length; ++t) {
                    const o = e.times[t] * r;
                    if (!(o < n || o >= i)) {
                        c.push(e.times[t]);
                        for (let n = 0; n < a; ++n) l.push(e.values[t * a + n])
                    }
                }
                0 !== c.length && (e.times = Nl.convertArray(c, e.times.constructor), e.values = Nl.convertArray(l, e.values.constructor), s.push(e))
            }
            o.tracks = s;
            let a = 1 / 0;
            for (let t = 0; t < o.tracks.length; ++t) a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
            for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
            return o.resetDuration(), o
        },
        makeClipAdditive: function(t, e, n, i) {
            void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === i || i <= 0) && (i = 30);
            const r = t.tracks.length,
                o = e / i;
            for (let e = 0; e < r; ++e) {
                const i = n.tracks[e],
                    r = i.ValueTypeName;
                if ("bool" === r || "string" === r) continue;
                const s = t.tracks.find((function(t) {
                    return t.name === i.name && t.ValueTypeName === r
                }));
                if (void 0 === s) continue;
                const a = i.getValueSize(),
                    c = i.times.length - 1;
                let l;
                if (o <= i.times[0]) l = Nl.arraySlice(i.values, 0, i.valueSize);
                else if (o >= i.times[c]) {
                    const t = c * a;
                    l = Nl.arraySlice(i.values, t)
                } else {
                    const t = i.createInterpolant();
                    t.evaluate(o), l = t.resultBuffer
                }
                if ("quaternion" === r) {
                    new mn(l[0], l[1], l[2], l[3]).normalize().conjugate().toArray(l)
                }
                const u = s.times.length;
                for (let t = 0; t < u; ++t) {
                    const e = t * a;
                    if ("quaternion" === r) mn.multiplyQuaternionsFlat(s.values, e, l, 0, s.values, e);
                    else
                        for (let t = 0; t < a; ++t) s.values[e + t] -= l[t]
                }
            }
            return t.blendMode = 2501, t
        }
    };

    function kl(t, e, n, i) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
    }

    function Ul(t, e, n, i) {
        kl.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function Bl(t, e, n, i) {
        kl.call(this, t, e, n, i)
    }

    function zl(t, e, n, i) {
        kl.call(this, t, e, n, i)
    }

    function Fl(t, e, n, i) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = Nl.convertArray(e, this.TimeBufferType), this.values = Nl.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
    }

    function jl(t, e, n) {
        Fl.call(this, t, e, n)
    }

    function Hl(t, e, n, i) {
        Fl.call(this, t, e, n, i)
    }

    function Gl(t, e, n, i) {
        Fl.call(this, t, e, n, i)
    }

    function Vl(t, e, n, i) {
        kl.call(this, t, e, n, i)
    }

    function Wl(t, e, n, i) {
        Fl.call(this, t, e, n, i)
    }

    function ql(t, e, n, i) {
        Fl.call(this, t, e, n, i)
    }

    function Xl(t, e, n, i) {
        Fl.call(this, t, e, n, i)
    }

    function Zl(t, e, n, i) {
        this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== i ? i : 2500, this.uuid = on.generateUUID(), this.duration < 0 && this.resetDuration()
    }

    function Yl(t) {
        if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = function(t) {
            switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Gl;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Xl;
                case "color":
                    return Hl;
                case "quaternion":
                    return Wl;
                case "bool":
                case "boolean":
                    return jl;
                case "string":
                    return ql
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        if (void 0 === t.times) {
            const e = [],
                n = [];
            Nl.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
    }
    Object.assign(kl.prototype, {
        evaluate: function(t) {
            let e = this.parameterPositions,
                n = this._cachedIndex,
                i = e[n],
                r = e[n - 1];
            t: {
                e: {
                    let o;n: {
                        i: if (!(t < i)) {
                            for (let o = n + 2;;) {
                                if (void 0 === i) {
                                    if (t < r) break i;
                                    return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                }
                                if (n === o) break;
                                if (r = i, i = e[++n], t < i) break e
                            }
                            o = e.length;
                            break n
                        }if (t >= r) break t; {
                            const s = e[1];
                            t < s && (n = 2, r = s);
                            for (let o = n - 2;;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                if (n === o) break;
                                if (i = r, r = e[--n - 1], t >= r) break e
                            }
                            o = n, n = 0
                        }
                    }
                    for (; n < o;) {
                        const i = n + o >>> 1;
                        t < e[i] ? o = i : n = i + 1
                    }
                    if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                    if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            const e = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                r = t * i;
            for (let t = 0; t !== i; ++t) e[t] = n[r + t];
            return e
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }), Object.assign(kl.prototype, {
        beforeStart_: kl.prototype.copySampleValue_,
        afterEnd_: kl.prototype.copySampleValue_
    }), Ul.prototype = Object.assign(Object.create(kl.prototype), {
        constructor: Ul,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(t, e, n) {
            let i = this.parameterPositions,
                r = t - 2,
                o = t + 1,
                s = i[r],
                a = i[o];
            if (void 0 === s) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = t, s = 2 * e - n;
                    break;
                case 2402:
                    r = i.length - 2, s = e + i[r] - i[r + 1];
                    break;
                default:
                    r = t, s = n
            }
            if (void 0 === a) switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = t, a = 2 * n - e;
                    break;
                case 2402:
                    o = 1, a = n + i[1] - i[0];
                    break;
                default:
                    o = t - 1, a = e
            }
            const c = .5 * (n - e),
                l = this.valueSize;
            this._weightPrev = c / (e - s), this._weightNext = c / (a - n), this._offsetPrev = r * l, this._offsetNext = o * l
        },
        interpolate_: function(t, e, n, i) {
            const r = this.resultBuffer,
                o = this.sampleValues,
                s = this.valueSize,
                a = t * s,
                c = a - s,
                l = this._offsetPrev,
                u = this._offsetNext,
                h = this._weightPrev,
                p = this._weightNext,
                f = (n - e) / (i - e),
                d = f * f,
                m = d * f,
                g = -h * m + 2 * h * d - h * f,
                v = (1 + h) * m + (-1.5 - 2 * h) * d + (-.5 + h) * f + 1,
                y = (-1 - p) * m + (1.5 + p) * d + .5 * f,
                b = p * m - p * d;
            for (let t = 0; t !== s; ++t) r[t] = g * o[l + t] + v * o[c + t] + y * o[a + t] + b * o[u + t];
            return r
        }
    }), Bl.prototype = Object.assign(Object.create(kl.prototype), {
        constructor: Bl,
        interpolate_: function(t, e, n, i) {
            const r = this.resultBuffer,
                o = this.sampleValues,
                s = this.valueSize,
                a = t * s,
                c = a - s,
                l = (n - e) / (i - e),
                u = 1 - l;
            for (let t = 0; t !== s; ++t) r[t] = o[c + t] * u + o[a + t] * l;
            return r
        }
    }), zl.prototype = Object.assign(Object.create(kl.prototype), {
        constructor: zl,
        interpolate_: function(t) {
            return this.copySampleValue_(t - 1)
        }
    }), Object.assign(Fl, {
        toJSON: function(t) {
            const e = t.constructor;
            let n;
            if (void 0 !== e.toJSON) n = e.toJSON(t);
            else {
                n = {
                    name: t.name,
                    times: Nl.convertArray(t.times, Array),
                    values: Nl.convertArray(t.values, Array)
                };
                const e = t.getInterpolation();
                e !== t.DefaultInterpolation && (n.interpolation = e)
            }
            return n.type = t.ValueTypeName, n
        }
    }), Object.assign(Fl.prototype, {
        constructor: Fl,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new zl(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new Bl(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new Ul(this.times, this.values, this.getValueSize(), t)
        },
        setInterpolation: function(t) {
            let e;
            switch (t) {
                case 2300:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw new Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", e), this
            }
            return this.createInterpolant = e, this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
            }
            return this
        },
        scale: function(t) {
            if (1 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
            }
            return this
        },
        trim: function(t, e) {
            const n = this.times,
                i = n.length;
            let r = 0,
                o = i - 1;
            for (; r !== i && n[r] < t;) ++r;
            for (; - 1 !== o && n[o] > e;) --o;
            if (++o, 0 !== r || o !== i) {
                r >= o && (o = Math.max(o, 1), r = o - 1);
                const t = this.getValueSize();
                this.times = Nl.arraySlice(n, r, o), this.values = Nl.arraySlice(this.values, r * t, o * t)
            }
            return this
        },
        validate: function() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
            const n = this.times,
                i = this.values,
                r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
            let o = null;
            for (let e = 0; e !== r; e++) {
                const i = n[e];
                if ("number" == typeof i && isNaN(i)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
                    break
                }
                if (null !== o && o > i) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, o), t = !1;
                    break
                }
                o = i
            }
            if (void 0 !== i && Nl.isTypedArray(i))
                for (let e = 0, n = i.length; e !== n; ++e) {
                    const n = i[e];
                    if (isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                        break
                    }
                }
            return t
        },
        optimize: function() {
            const t = Nl.arraySlice(this.times),
                e = Nl.arraySlice(this.values),
                n = this.getValueSize(),
                i = 2302 === this.getInterpolation(),
                r = t.length - 1;
            let o = 1;
            for (let s = 1; s < r; ++s) {
                let r = !1;
                const a = t[s];
                if (a !== t[s + 1] && (1 !== s || a !== a[0]))
                    if (i) r = !0;
                    else {
                        const t = s * n,
                            i = t - n,
                            o = t + n;
                        for (let s = 0; s !== n; ++s) {
                            const n = e[t + s];
                            if (n !== e[i + s] || n !== e[o + s]) {
                                r = !0;
                                break
                            }
                        }
                    }
                if (r) {
                    if (s !== o) {
                        t[o] = t[s];
                        const i = s * n,
                            r = o * n;
                        for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                    }++o
                }
            }
            if (r > 0) {
                t[o] = t[r];
                for (let t = r * n, i = o * n, s = 0; s !== n; ++s) e[i + s] = e[t + s];
                ++o
            }
            return o !== t.length ? (this.times = Nl.arraySlice(t, 0, o), this.values = Nl.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this
        },
        clone: function() {
            const t = Nl.arraySlice(this.times, 0),
                e = Nl.arraySlice(this.values, 0),
                n = new(0, this.constructor)(this.name, t, e);
            return n.createInterpolant = this.createInterpolant, n
        }
    }), jl.prototype = Object.assign(Object.create(Fl.prototype), {
        constructor: jl,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Hl.prototype = Object.assign(Object.create(Fl.prototype), {
        constructor: Hl,
        ValueTypeName: "color"
    }), Gl.prototype = Object.assign(Object.create(Fl.prototype), {
        constructor: Gl,
        ValueTypeName: "number"
    }), Vl.prototype = Object.assign(Object.create(kl.prototype), {
        constructor: Vl,
        interpolate_: function(t, e, n, i) {
            const r = this.resultBuffer,
                o = this.sampleValues,
                s = this.valueSize,
                a = (n - e) / (i - e);
            let c = t * s;
            for (let t = c + s; c !== t; c += 4) mn.slerpFlat(r, 0, o, c - s, o, c, a);
            return r
        }
    }), Wl.prototype = Object.assign(Object.create(Fl.prototype), {
        constructor: Wl,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(t) {
            return new Vl(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), ql.prototype = Object.assign(Object.create(Fl.prototype), {
        constructor: ql,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Xl.prototype = Object.assign(Object.create(Fl.prototype), {
        constructor: Xl,
        ValueTypeName: "vector"
    }), Object.assign(Zl, {
        parse: function(t) {
            const e = [],
                n = t.tracks,
                i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t) e.push(Yl(n[t]).scale(i));
            return new Zl(t.name, t.duration, e, t.blendMode)
        },
        toJSON: function(t) {
            const e = [],
                n = t.tracks,
                i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                };
            for (let t = 0, i = n.length; t !== i; ++t) e.push(Fl.toJSON(n[t]));
            return i
        },
        CreateFromMorphTargetSequence: function(t, e, n, i) {
            const r = e.length,
                o = [];
            for (let t = 0; t < r; t++) {
                let s = [],
                    a = [];
                s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                const c = Nl.getKeyframeOrder(s);
                s = Nl.sortedArray(s, 1, c), a = Nl.sortedArray(a, 1, c), i || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new Gl(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / n))
            }
            return new Zl(t, -1, o)
        },
        findByName: function(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
                const e = t;
                n = e.geometry && e.geometry.animations || e.animations
            }
            for (let t = 0; t < n.length; t++)
                if (n[t].name === e) return n[t];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, n) {
            const i = {},
                r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e],
                    o = n.name.match(r);
                if (o && o.length > 1) {
                    const t = o[1];
                    let e = i[t];
                    e || (i[t] = e = []), e.push(n)
                }
            }
            const o = [];
            for (const t in i) o.push(Zl.CreateFromMorphTargetSequence(t, i[t], e, n));
            return o
        },
        parseAnimation: function(t, e) {
            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function(t, e, n, i, r) {
                    if (0 !== n.length) {
                        const o = [],
                            s = [];
                        Nl.flattenJSON(n, o, s, i), 0 !== o.length && r.push(new t(e, o, s))
                    }
                },
                i = [],
                r = t.name || "default",
                o = t.fps || 30,
                s = t.blendMode;
            let a = t.length || -1;
            const c = t.hierarchy || [];
            for (let t = 0; t < c.length; t++) {
                const r = c[t].keys;
                if (r && 0 !== r.length)
                    if (r[0].morphTargets) {
                        const t = {};
                        let e;
                        for (e = 0; e < r.length; e++)
                            if (r[e].morphTargets)
                                for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                        for (const n in t) {
                            const t = [],
                                o = [];
                            for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                const i = r[e];
                                t.push(i.time), o.push(i.morphTarget === n ? 1 : 0)
                            }
                            i.push(new Gl(".morphTargetInfluence[" + n + "]", t, o))
                        }
                        a = t.length * (o || 1)
                    } else {
                        const o = ".bones[" + e[t].name + "]";
                        n(Xl, o + ".position", r, "pos", i), n(Wl, o + ".quaternion", r, "rot", i), n(Xl, o + ".scale", r, "scl", i)
                    }
            }
            if (0 === i.length) return null;
            return new Zl(r, a, i, s)
        }
    }), Object.assign(Zl.prototype, {
        resetDuration: function() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                const n = this.tracks[e];
                t = Math.max(t, n.times[n.times.length - 1])
            }
            return this.duration = t, this
        },
        trim: function() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this
        },
        validate: function() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
            return t
        },
        optimize: function() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this
        },
        clone: function() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
            return new Zl(this.name, this.duration, t, this.blendMode)
        }
    });
    const $l = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled) return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    };

    function Jl(t, e, n) {
        const i = this;
        let r = !1,
            o = 0,
            s = 0,
            a = void 0;
        const c = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
            s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), r = !0
        }, this.itemEnd = function(t) {
            o++, void 0 !== i.onProgress && i.onProgress(t, o, s), o === s && (r = !1, void 0 !== i.onLoad && i.onLoad())
        }, this.itemError = function(t) {
            void 0 !== i.onError && i.onError(t)
        }, this.resolveURL = function(t) {
            return a ? a(t) : t
        }, this.setURLModifier = function(t) {
            return a = t, this
        }, this.addHandler = function(t, e) {
            return c.push(t, e), this
        }, this.removeHandler = function(t) {
            const e = c.indexOf(t);
            return -1 !== e && c.splice(e, 2), this
        }, this.getHandler = function(t) {
            for (let e = 0, n = c.length; e < n; e += 2) {
                const n = c[e],
                    i = c[e + 1];
                if (n.global && (n.lastIndex = 0), n.test(t)) return i
            }
            return null
        }
    }
    const Kl = new Jl;

    function Ql(t) {
        this.manager = void 0 !== t ? t : Kl, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    Object.assign(Ql.prototype, {
        load: function() {},
        loadAsync: function(t, e) {
            const n = this;
            return new Promise((function(i, r) {
                n.load(t, i, e, r)
            }))
        },
        parse: function() {},
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        },
        setResourcePath: function(t) {
            return this.resourcePath = t, this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t, this
        }
    });
    const tu = {};

    function eu(t) {
        Ql.call(this, t)
    }

    function nu(t) {
        Ql.call(this, t)
    }

    function iu(t) {
        Ql.call(this, t)
    }

    function ru(t) {
        Ql.call(this, t)
    }

    function ou(t) {
        Ql.call(this, t)
    }

    function su(t) {
        Ql.call(this, t)
    }

    function au(t) {
        Ql.call(this, t)
    }

    function cu() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function lu(t, e, n, i, r, o, s, a) {
        cu.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0
    }

    function uu(t, e, n, i, r, o) {
        lu.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve"
    }

    function hu() {
        let t = 0,
            e = 0,
            n = 0,
            i = 0;

        function r(r, o, s, a) {
            t = r, e = s, n = -3 * r + 3 * o - 2 * s - a, i = 2 * r - 2 * o + s + a
        }
        return {
            initCatmullRom: function(t, e, n, i, o) {
                r(e, n, o * (n - t), o * (i - e))
            },
            initNonuniformCatmullRom: function(t, e, n, i, o, s, a) {
                let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
                    l = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
                c *= s, l *= s, r(e, n, c, l)
            },
            calc: function(r) {
                const o = r * r;
                return t + e * r + n * o + i * (o * r)
            }
        }
    }
    eu.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: eu,
        load: function(t, e, n, i) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = this,
                o = $l.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function() {
                e && e(o), r.manager.itemEnd(t)
            }), 0), o;
            if (void 0 !== tu[t]) return void tu[t].push({
                onLoad: e,
                onProgress: n,
                onError: i
            });
            const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
            let a;
            if (s) {
                const n = s[1],
                    o = !!s[2];
                let a = s[3];
                a = decodeURIComponent(a), o && (a = atob(a));
                try {
                    let i;
                    const o = (this.responseType || "").toLowerCase();
                    switch (o) {
                        case "arraybuffer":
                        case "blob":
                            const t = new Uint8Array(a.length);
                            for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                            i = "blob" === o ? new Blob([t.buffer], {
                                type: n
                            }) : t.buffer;
                            break;
                        case "document":
                            const e = new DOMParser;
                            i = e.parseFromString(a, n);
                            break;
                        case "json":
                            i = JSON.parse(a);
                            break;
                        default:
                            i = a
                    }
                    setTimeout((function() {
                        e && e(i), r.manager.itemEnd(t)
                    }), 0)
                } catch (e) {
                    setTimeout((function() {
                        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }), 0)
                }
            } else {
                tu[t] = [], tu[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function(e) {
                    const n = this.response,
                        i = tu[t];
                    if (delete tu[t], 200 === this.status || 0 === this.status) {
                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), $l.add(t, n);
                        for (let t = 0, e = i.length; t < e; t++) {
                            const e = i[t];
                            e.onLoad && e.onLoad(n)
                        }
                        r.manager.itemEnd(t)
                    } else {
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            n.onError && n.onError(e)
                        }
                        r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                }), !1), a.addEventListener("progress", (function(e) {
                    const n = tu[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onProgress && i.onProgress(e)
                    }
                }), !1), a.addEventListener("error", (function(e) {
                    const n = tu[t];
                    delete tu[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t)
                }), !1), a.addEventListener("abort", (function(e) {
                    const n = tu[t];
                    delete tu[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t)
                }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
                a.send(null)
            }
            return r.manager.itemStart(t), a
        },
        setResponseType: function(t) {
            return this.responseType = t, this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t, this
        },
        setMimeType: function(t) {
            return this.mimeType = t, this
        }
    }), nu.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: nu,
        load: function(t, e, n, i) {
            const r = this,
                o = new eu(r.manager);
            o.setPath(r.path), o.load(t, (function(n) {
                try {
                    e(r.parse(JSON.parse(n)))
                } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                }
            }), n, i)
        },
        parse: function(t) {
            const e = [];
            for (let n = 0; n < t.length; n++) {
                const i = Zl.parse(t[n]);
                e.push(i)
            }
            return e
        }
    }), iu.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: iu,
        load: function(t, e, n, i) {
            const r = this,
                o = [],
                s = new oc;
            s.image = o;
            const a = new eu(this.manager);
            a.setPath(this.path), a.setResponseType("arraybuffer");
            let c = 0;

            function l(l) {
                a.load(t[l], (function(t) {
                    const n = r.parse(t, !0);
                    o[l] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    }, c += 1, 6 === c && (1 === n.mipmapCount && (s.minFilter = 1006), s.format = n.format, s.needsUpdate = !0, e && e(s))
                }), n, i)
            }
            if (Array.isArray(t))
                for (let e = 0, n = t.length; e < n; ++e) l(e);
            else a.load(t, (function(t) {
                const n = r.parse(t, !0);
                if (n.isCubemap) {
                    const t = n.mipmaps.length / n.mipmapCount;
                    for (let e = 0; e < t; e++) {
                        o[e] = {
                            mipmaps: []
                        };
                        for (let t = 0; t < n.mipmapCount; t++) o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height
                    }
                } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;
                1 === n.mipmapCount && (s.minFilter = 1006), s.format = n.format, s.needsUpdate = !0, e && e(s)
            }), n, i);
            return s
        }
    }), ru.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: ru,
        load: function(t, e, n, i) {
            const r = this,
                o = new qr,
                s = new eu(this.manager);
            return s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(t, (function(t) {
                const n = r.parse(t);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001, o.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001, o.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006, o.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = 1008), 1 === n.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, e && e(o, n))
            }), n, i), o
        }
    }), ou.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: ou,
        load: function(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = this,
                o = $l.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function() {
                e && e(o), r.manager.itemEnd(t)
            }), 0), o;
            const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function a() {
                s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), $l.add(t, this), e && e(this), r.manager.itemEnd(t)
            }

            function c(e) {
                s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
            }
            return s.addEventListener("load", a, !1), s.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s
        }
    }), su.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: su,
        load: function(t, e, n, i) {
            const r = new vo,
                o = new ou(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            let s = 0;

            function a(n) {
                o.load(t[n], (function(t) {
                    r.images[n] = t, s++, 6 === s && (r.needsUpdate = !0, e && e(r))
                }), void 0, i)
            }
            for (let e = 0; e < t.length; ++e) a(e);
            return r
        }
    }), au.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: au,
        load: function(t, e, n, i) {
            const r = new hn,
                o = new ou(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function(n) {
                r.image = n;
                const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== e && e(r)
            }), n, i), r
        }
    }), Object.assign(cu.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e
        },
        getLength: function() {
            const t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n, i = this.getPoint(0),
                r = 0;
            e.push(0);
            for (let o = 1; o <= t; o++) n = this.getPoint(o / t), r += n.distanceTo(i), e.push(r), i = n;
            return this.cacheArcLengths = e, e
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            const n = this.getLengths();
            let i, r = 0,
                o = n.length;
            i = e || t * n[o - 1];
            let s, a = 0,
                c = o - 1;
            for (; a <= c;)
                if (r = Math.floor(a + (c - a) / 2), s = n[r] - i, s < 0) a = r + 1;
                else {
                    if (!(s > 0)) {
                        c = r;
                        break
                    }
                    c = r - 1
                }
            if (r = c, n[r] === i) return r / (o - 1);
            const l = n[r];
            return (r + (i - l) / (n[r + 1] - l)) / (o - 1)
        },
        getTangent: function(t, e) {
            let n = t - 1e-4,
                i = t + 1e-4;
            n < 0 && (n = 0), i > 1 && (i = 1);
            const r = this.getPoint(n),
                o = this.getPoint(i),
                s = e || (r.isVector2 ? new sn : new yn);
            return s.copy(o).sub(r).normalize(), s
        },
        getTangentAt: function(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e)
        },
        computeFrenetFrames: function(t, e) {
            const n = new yn,
                i = [],
                r = [],
                o = [],
                s = new yn,
                a = new En;
            for (let e = 0; e <= t; e++) {
                const n = e / t;
                i[e] = this.getTangentAt(n, new yn), i[e].normalize()
            }
            r[0] = new yn, o[0] = new yn;
            let c = Number.MAX_VALUE;
            const l = Math.abs(i[0].x),
                u = Math.abs(i[0].y),
                h = Math.abs(i[0].z);
            l <= c && (c = l, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), o[0].crossVectors(i[0], r[0]);
            for (let e = 1; e <= t; e++) {
                if (r[e] = r[e - 1].clone(), o[e] = o[e - 1].clone(), s.crossVectors(i[e - 1], i[e]), s.length() > Number.EPSILON) {
                    s.normalize();
                    const t = Math.acos(on.clamp(i[e - 1].dot(i[e]), -1, 1));
                    r[e].applyMatrix4(a.makeRotationAxis(s, t))
                }
                o[e].crossVectors(i[e], r[e])
            }
            if (!0 === e) {
                let e = Math.acos(on.clamp(r[0].dot(r[t]), -1, 1));
                e /= t, i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
                for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), o[n].crossVectors(i[n], r[n])
            }
            return {
                tangents: i,
                normals: r,
                binormals: o
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        },
        toJSON: function() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
    }), lu.prototype = Object.create(cu.prototype), lu.prototype.constructor = lu, lu.prototype.isEllipseCurve = !0, lu.prototype.getPoint = function(t, e) {
        const n = e || new sn,
            i = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0;) r += i;
        for (; r > i;) r -= i;
        r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
        const s = this.aStartAngle + t * r;
        let a = this.aX + this.xRadius * Math.cos(s),
            c = this.aY + this.yRadius * Math.sin(s);
        if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = a - this.aX,
                i = c - this.aY;
            a = n * t - i * e + this.aX, c = n * e + i * t + this.aY
        }
        return n.set(a, c)
    }, lu.prototype.copy = function(t) {
        return cu.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, lu.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }, lu.prototype.fromJSON = function(t) {
        return cu.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, uu.prototype = Object.create(lu.prototype), uu.prototype.constructor = uu, uu.prototype.isArcCurve = !0;
    const pu = new yn,
        fu = new hu,
        du = new hu,
        mu = new hu;

    function gu(t, e, n, i) {
        cu.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5
    }

    function vu(t, e, n, i, r) {
        const o = .5 * (i - e),
            s = .5 * (r - n),
            a = t * t;
        return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n
    }

    function yu(t, e, n, i) {
        return function(t, e) {
            const n = 1 - t;
            return n * n * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * e
        }(t, n) + function(t, e) {
            return t * t * e
        }(t, i)
    }

    function bu(t, e, n, i, r) {
        return function(t, e) {
            const n = 1 - t;
            return n * n * n * e
        }(t, e) + function(t, e) {
            const n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function(t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, i) + function(t, e) {
            return t * t * t * e
        }(t, r)
    }

    function xu(t, e, n, i) {
        cu.call(this), this.type = "CubicBezierCurve", this.v0 = t || new sn, this.v1 = e || new sn, this.v2 = n || new sn, this.v3 = i || new sn
    }

    function wu(t, e, n, i) {
        cu.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new yn, this.v1 = e || new yn, this.v2 = n || new yn, this.v3 = i || new yn
    }

    function _u(t, e) {
        cu.call(this), this.type = "LineCurve", this.v1 = t || new sn, this.v2 = e || new sn
    }

    function Mu(t, e) {
        cu.call(this), this.type = "LineCurve3", this.v1 = t || new yn, this.v2 = e || new yn
    }

    function Su(t, e, n) {
        cu.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new sn, this.v1 = e || new sn, this.v2 = n || new sn
    }

    function Tu(t, e, n) {
        cu.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new yn, this.v1 = e || new yn, this.v2 = n || new yn
    }

    function Eu(t) {
        cu.call(this), this.type = "SplineCurve", this.points = t || []
    }
    gu.prototype = Object.create(cu.prototype), gu.prototype.constructor = gu, gu.prototype.isCatmullRomCurve3 = !0, gu.prototype.getPoint = function(t, e) {
        const n = e || new yn,
            i = this.points,
            r = i.length,
            o = (r - (this.closed ? 0 : 1)) * t;
        let s, a, c, l, u = Math.floor(o),
            h = o - u;
        if (this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / r) + 1) * r : 0 === h && u === r - 1 && (u = r - 2, h = 1), this.closed || u > 0 ? s = i[(u - 1) % r] : (pu.subVectors(i[0], i[1]).add(i[0]), s = pu), a = i[u % r], c = i[(u + 1) % r], this.closed || u + 2 < r ? l = i[(u + 2) % r] : (pu.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), l = pu), "centripetal" === this.curveType || "chordal" === this.curveType) {
            const t = "chordal" === this.curveType ? .5 : .25;
            let e = Math.pow(s.distanceToSquared(a), t),
                n = Math.pow(a.distanceToSquared(c), t),
                i = Math.pow(c.distanceToSquared(l), t);
            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), fu.initNonuniformCatmullRom(s.x, a.x, c.x, l.x, e, n, i), du.initNonuniformCatmullRom(s.y, a.y, c.y, l.y, e, n, i), mu.initNonuniformCatmullRom(s.z, a.z, c.z, l.z, e, n, i)
        } else "catmullrom" === this.curveType && (fu.initCatmullRom(s.x, a.x, c.x, l.x, this.tension), du.initCatmullRom(s.y, a.y, c.y, l.y, this.tension), mu.initCatmullRom(s.z, a.z, c.z, l.z, this.tension));
        return n.set(fu.calc(h), du.calc(h), mu.calc(h)), n
    }, gu.prototype.copy = function(t) {
        cu.prototype.copy.call(this, t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, gu.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }, gu.prototype.fromJSON = function(t) {
        cu.prototype.fromJSON.call(this, t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push((new yn).fromArray(n))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, xu.prototype = Object.create(cu.prototype), xu.prototype.constructor = xu, xu.prototype.isCubicBezierCurve = !0, xu.prototype.getPoint = function(t, e) {
        const n = e || new sn,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            s = this.v3;
        return n.set(bu(t, i.x, r.x, o.x, s.x), bu(t, i.y, r.y, o.y, s.y)), n
    }, xu.prototype.copy = function(t) {
        return cu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, xu.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, xu.prototype.fromJSON = function(t) {
        return cu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, wu.prototype = Object.create(cu.prototype), wu.prototype.constructor = wu, wu.prototype.isCubicBezierCurve3 = !0, wu.prototype.getPoint = function(t, e) {
        const n = e || new yn,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            s = this.v3;
        return n.set(bu(t, i.x, r.x, o.x, s.x), bu(t, i.y, r.y, o.y, s.y), bu(t, i.z, r.z, o.z, s.z)), n
    }, wu.prototype.copy = function(t) {
        return cu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, wu.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, wu.prototype.fromJSON = function(t) {
        return cu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, _u.prototype = Object.create(cu.prototype), _u.prototype.constructor = _u, _u.prototype.isLineCurve = !0, _u.prototype.getPoint = function(t, e) {
        const n = e || new sn;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }, _u.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }, _u.prototype.getTangent = function(t, e) {
        const n = e || new sn;
        return n.copy(this.v2).sub(this.v1).normalize(), n
    }, _u.prototype.copy = function(t) {
        return cu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, _u.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, _u.prototype.fromJSON = function(t) {
        return cu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Mu.prototype = Object.create(cu.prototype), Mu.prototype.constructor = Mu, Mu.prototype.isLineCurve3 = !0, Mu.prototype.getPoint = function(t, e) {
        const n = e || new yn;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }, Mu.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }, Mu.prototype.copy = function(t) {
        return cu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Mu.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Mu.prototype.fromJSON = function(t) {
        return cu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Su.prototype = Object.create(cu.prototype), Su.prototype.constructor = Su, Su.prototype.isQuadraticBezierCurve = !0, Su.prototype.getPoint = function(t, e) {
        const n = e || new sn,
            i = this.v0,
            r = this.v1,
            o = this.v2;
        return n.set(yu(t, i.x, r.x, o.x), yu(t, i.y, r.y, o.y)), n
    }, Su.prototype.copy = function(t) {
        return cu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Su.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Su.prototype.fromJSON = function(t) {
        return cu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Tu.prototype = Object.create(cu.prototype), Tu.prototype.constructor = Tu, Tu.prototype.isQuadraticBezierCurve3 = !0, Tu.prototype.getPoint = function(t, e) {
        const n = e || new yn,
            i = this.v0,
            r = this.v1,
            o = this.v2;
        return n.set(yu(t, i.x, r.x, o.x), yu(t, i.y, r.y, o.y), yu(t, i.z, r.z, o.z)), n
    }, Tu.prototype.copy = function(t) {
        return cu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Tu.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Tu.prototype.fromJSON = function(t) {
        return cu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Eu.prototype = Object.create(cu.prototype), Eu.prototype.constructor = Eu, Eu.prototype.isSplineCurve = !0, Eu.prototype.getPoint = function(t, e) {
        const n = e || new sn,
            i = this.points,
            r = (i.length - 1) * t,
            o = Math.floor(r),
            s = r - o,
            a = i[0 === o ? o : o - 1],
            c = i[o],
            l = i[o > i.length - 2 ? i.length - 1 : o + 1],
            u = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(vu(s, a.x, c.x, l.x, u.x), vu(s, a.y, c.y, l.y, u.y)), n
    }, Eu.prototype.copy = function(t) {
        cu.prototype.copy.call(this, t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone())
        }
        return this
    }, Eu.prototype.toJSON = function() {
        const t = cu.prototype.toJSON.call(this);
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray())
        }
        return t
    }, Eu.prototype.fromJSON = function(t) {
        cu.prototype.fromJSON.call(this, t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push((new sn).fromArray(n))
        }
        return this
    };
    var Cu = Object.freeze({
        __proto__: null,
        ArcCurve: uu,
        CatmullRomCurve3: gu,
        CubicBezierCurve: xu,
        CubicBezierCurve3: wu,
        EllipseCurve: lu,
        LineCurve: _u,
        LineCurve3: Mu,
        QuadraticBezierCurve: Su,
        QuadraticBezierCurve3: Tu,
        SplineCurve: Eu
    });

    function Au() {
        cu.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function Lu(t) {
        Au.call(this), this.type = "Path", this.currentPoint = new sn, t && this.setFromPoints(t)
    }

    function Pu(t) {
        Lu.call(this, t), this.uuid = on.generateUUID(), this.type = "Shape", this.holes = []
    }

    function Ou(t, e) {
        Vn.call(this), this.type = "Light", this.color = new Ni(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
    }

    function Ru(t, e, n) {
        Ou.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Vn.DefaultUp), this.updateMatrix(), this.groundColor = new Ni(e)
    }

    function Iu(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new sn(512, 512), this.map = null, this.mapPass = null, this.matrix = new En, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Yr, this._frameExtents = new sn(1, 1), this._viewportCount = 1, this._viewports = [new pn(0, 0, 1, 1)]
    }

    function Du() {
        Iu.call(this, new Gr(50, 1, .5, 500))
    }

    function Nu(t, e, n, i, r, o) {
        Ou.call(this, t, e), this.type = "SpotLight", this.position.copy(Vn.DefaultUp), this.updateMatrix(), this.target = new Vn, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Du
    }

    function ku() {
        Iu.call(this, new Gr(90, 1, .5, 500)), this._frameExtents = new sn(4, 2), this._viewportCount = 6, this._viewports = [new pn(2, 1, 1, 1), new pn(0, 1, 1, 1), new pn(3, 1, 1, 1), new pn(1, 1, 1, 1), new pn(3, 0, 1, 1), new pn(1, 0, 1, 1)], this._cubeDirections = [new yn(1, 0, 0), new yn(-1, 0, 0), new yn(0, 0, 1), new yn(0, 0, -1), new yn(0, 1, 0), new yn(0, -1, 0)], this._cubeUps = [new yn(0, 1, 0), new yn(0, 1, 0), new yn(0, 1, 0), new yn(0, 1, 0), new yn(0, 0, 1), new yn(0, 0, -1)]
    }

    function Uu(t, e, n, i) {
        Ou.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new ku
    }

    function Bu(t, e, n, i, r, o) {
        Hr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function zu() {
        Iu.call(this, new Bu(-5, 5, 5, -5, .5, 500))
    }

    function Fu(t, e) {
        Ou.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Vn.DefaultUp), this.updateMatrix(), this.target = new Vn, this.shadow = new zu
    }

    function ju(t, e) {
        Ou.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
    }

    function Hu(t, e, n, i) {
        Ou.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
    }

    function Gu() {
        this.coefficients = [];
        for (let t = 0; t < 9; t++) this.coefficients.push(new yn)
    }

    function Vu(t, e) {
        Ou.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new Gu
    }

    function Wu(t) {
        Ql.call(this, t), this.textures = {}
    }
    Au.prototype = Object.assign(Object.create(cu.prototype), {
        constructor: Au,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            const t = this.curves[0].getPoint(0),
                e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new _u(e, t))
        },
        getPoint: function(t) {
            const e = t * this.getLength(),
                n = this.getCurveLengths();
            let i = 0;
            for (; i < n.length;) {
                if (n[i] >= e) {
                    const t = n[i] - e,
                        r = this.curves[i],
                        o = r.getLength(),
                        s = 0 === o ? 0 : 1 - t / o;
                    return r.getPointAt(s)
                }
                i++
            }
            return null
        },
        getLength: function() {
            const t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
            return this.cacheLengths = t, t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e
        },
        getPoints: function(t) {
            t = t || 12;
            const e = [];
            let n;
            for (let i = 0, r = this.curves; i < r.length; i++) {
                const o = r[i],
                    s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
                    a = o.getPoints(s);
                for (let t = 0; t < a.length; t++) {
                    const i = a[t];
                    n && n.equals(i) || (e.push(i), n = i)
                }
            }
            return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
        },
        copy: function(t) {
            cu.prototype.copy.call(this, t), this.curves = [];
            for (let e = 0, n = t.curves.length; e < n; e++) {
                const n = t.curves[e];
                this.curves.push(n.clone())
            }
            return this.autoClose = t.autoClose, this
        },
        toJSON: function() {
            const t = cu.prototype.toJSON.call(this);
            t.autoClose = this.autoClose, t.curves = [];
            for (let e = 0, n = this.curves.length; e < n; e++) {
                const n = this.curves[e];
                t.curves.push(n.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            cu.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
            for (let e = 0, n = t.curves.length; e < n; e++) {
                const n = t.curves[e];
                this.curves.push((new Cu[n.type]).fromJSON(n))
            }
            return this
        }
    }), Lu.prototype = Object.assign(Object.create(Au.prototype), {
        constructor: Lu,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
            return this
        },
        moveTo: function(t, e) {
            return this.currentPoint.set(t, e), this
        },
        lineTo: function(t, e) {
            const n = new _u(this.currentPoint.clone(), new sn(t, e));
            return this.curves.push(n), this.currentPoint.set(t, e), this
        },
        quadraticCurveTo: function(t, e, n, i) {
            const r = new Su(this.currentPoint.clone(), new sn(t, e), new sn(n, i));
            return this.curves.push(r), this.currentPoint.set(n, i), this
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            const s = new xu(this.currentPoint.clone(), new sn(t, e), new sn(n, i), new sn(r, o));
            return this.curves.push(s), this.currentPoint.set(r, o), this
        },
        splineThru: function(t) {
            const e = new Eu([this.currentPoint.clone()].concat(t));
            return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
        },
        arc: function(t, e, n, i, r, o) {
            const s = this.currentPoint.x,
                a = this.currentPoint.y;
            return this.absarc(t + s, e + a, n, i, r, o), this
        },
        absarc: function(t, e, n, i, r, o) {
            return this.absellipse(t, e, n, n, i, r, o), this
        },
        ellipse: function(t, e, n, i, r, o, s, a) {
            const c = this.currentPoint.x,
                l = this.currentPoint.y;
            return this.absellipse(t + c, e + l, n, i, r, o, s, a), this
        },
        absellipse: function(t, e, n, i, r, o, s, a) {
            const c = new lu(t, e, n, i, r, o, s, a);
            if (this.curves.length > 0) {
                const t = c.getPoint(0);
                t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
            }
            this.curves.push(c);
            const l = c.getPoint(1);
            return this.currentPoint.copy(l), this
        },
        copy: function(t) {
            return Au.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
        },
        toJSON: function() {
            const t = Au.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(), t
        },
        fromJSON: function(t) {
            return Au.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
        }
    }), Pu.prototype = Object.assign(Object.create(Lu.prototype), {
        constructor: Pu,
        getPointsHoles: function(t) {
            const e = [];
            for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            Lu.prototype.copy.call(this, t), this.holes = [];
            for (let e = 0, n = t.holes.length; e < n; e++) {
                const n = t.holes[e];
                this.holes.push(n.clone())
            }
            return this
        },
        toJSON: function() {
            const t = Lu.prototype.toJSON.call(this);
            t.uuid = this.uuid, t.holes = [];
            for (let e = 0, n = this.holes.length; e < n; e++) {
                const n = this.holes[e];
                t.holes.push(n.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Lu.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
            for (let e = 0, n = t.holes.length; e < n; e++) {
                const n = t.holes[e];
                this.holes.push((new Lu).fromJSON(n))
            }
            return this
        }
    }), Ou.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: Ou,
        isLight: !0,
        copy: function(t) {
            return Vn.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
        },
        toJSON: function(t) {
            const e = Vn.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Ru.prototype = Object.assign(Object.create(Ou.prototype), {
        constructor: Ru,
        isHemisphereLight: !0,
        copy: function(t) {
            return Ou.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
        }
    }), Object.assign(Iu.prototype, {
        _projScreenMatrix: new En,
        _lightPositionWorld: new yn,
        _lookTarget: new yn,
        getViewportCount: function() {
            return this._viewportCount
        },
        getFrustum: function() {
            return this._frustum
        },
        updateMatrices: function(t) {
            const e = this.camera,
                n = this.matrix,
                i = this._projScreenMatrix,
                r = this._lookTarget,
                o = this._lightPositionWorld;
            o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
        },
        getViewport: function(t) {
            return this._viewports[t]
        },
        getFrameExtents: function() {
            return this._frameExtents
        },
        copy: function(t) {
            return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            const t = {};
            return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
        }
    }), Du.prototype = Object.assign(Object.create(Iu.prototype), {
        constructor: Du,
        isSpotLightShadow: !0,
        updateMatrices: function(t) {
            const e = this.camera,
                n = 2 * on.RAD2DEG * t.angle,
                i = this.mapSize.width / this.mapSize.height,
                r = t.distance || e.far;
            n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), Iu.prototype.updateMatrices.call(this, t)
        }
    }), Nu.prototype = Object.assign(Object.create(Ou.prototype), {
        constructor: Nu,
        isSpotLight: !0,
        copy: function(t) {
            return Ou.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), ku.prototype = Object.assign(Object.create(Iu.prototype), {
        constructor: ku,
        isPointLightShadow: !0,
        updateMatrices: function(t, e) {
            void 0 === e && (e = 0);
            const n = this.camera,
                i = this.matrix,
                r = this._lightPositionWorld,
                o = this._lookTarget,
                s = this._projScreenMatrix;
            r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s)
        }
    }), Uu.prototype = Object.assign(Object.create(Ou.prototype), {
        constructor: Uu,
        isPointLight: !0,
        copy: function(t) {
            return Ou.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
        }
    }), Bu.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: Bu,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return Hr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        },
        setViewOffset: function(t, e, n, i, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            const t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2;
            let r = n - t,
                o = n + t,
                s = i + e,
                a = i - e;
            if (null !== this.view && this.view.enabled) {
                const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += t * this.view.offsetX, o = r + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            const e = Vn.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), zu.prototype = Object.assign(Object.create(Iu.prototype), {
        constructor: zu,
        isDirectionalLightShadow: !0,
        updateMatrices: function(t) {
            Iu.prototype.updateMatrices.call(this, t)
        }
    }), Fu.prototype = Object.assign(Object.create(Ou.prototype), {
        constructor: Fu,
        isDirectionalLight: !0,
        copy: function(t) {
            return Ou.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), ju.prototype = Object.assign(Object.create(Ou.prototype), {
        constructor: ju,
        isAmbientLight: !0
    }), Hu.prototype = Object.assign(Object.create(Ou.prototype), {
        constructor: Hu,
        isRectAreaLight: !0,
        copy: function(t) {
            return Ou.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
        },
        toJSON: function(t) {
            const e = Ou.prototype.toJSON.call(this, t);
            return e.object.width = this.width, e.object.height = this.height, e
        }
    }), Object.assign(Gu.prototype, {
        isSphericalHarmonics3: !0,
        set: function(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
            return this
        },
        zero: function() {
            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
            return this
        },
        getAt: function(t, e) {
            const n = t.x,
                i = t.y,
                r = t.z,
                o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e
        },
        getIrradianceAt: function(t, e) {
            const n = t.x,
                i = t.y,
                r = t.z,
                o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e
        },
        add: function(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
            return this
        },
        addScaledSH: function(t, e) {
            for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this
        },
        scale: function(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
            return this
        },
        lerp: function(t, e) {
            for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
            return this
        },
        equals: function(t) {
            for (let e = 0; e < 9; e++)
                if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
            return !0
        },
        copy: function(t) {
            return this.set(t.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
            return t
        }
    }), Object.assign(Gu, {
        getBasisAt: function(t, e) {
            const n = t.x,
                i = t.y,
                r = t.z;
            e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
        }
    }), Vu.prototype = Object.assign(Object.create(Ou.prototype), {
        constructor: Vu,
        isLightProbe: !0,
        copy: function(t) {
            return Ou.prototype.copy.call(this, t), this.sh.copy(t.sh), this
        },
        fromJSON: function(t) {
            return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
        },
        toJSON: function(t) {
            const e = Ou.prototype.toJSON.call(this, t);
            return e.object.sh = this.sh.toArray(), e
        }
    }), Wu.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: Wu,
        load: function(t, e, n, i) {
            const r = this,
                o = new eu(r.manager);
            o.setPath(r.path), o.load(t, (function(n) {
                try {
                    e(r.parse(JSON.parse(n)))
                } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                }
            }), n, i)
        },
        parse: function(t) {
            const e = this.textures;

            function n(t) {
                return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
            }
            const i = new Dl[t.type];
            if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new Ni).setHex(t.sheen)), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                for (const e in t.uniforms) {
                    const r = t.uniforms[e];
                    switch (i.uniforms[e] = {}, r.type) {
                        case "t":
                            i.uniforms[e].value = n(r.value);
                            break;
                        case "c":
                            i.uniforms[e].value = (new Ni).setHex(r.value);
                            break;
                        case "v2":
                            i.uniforms[e].value = (new sn).fromArray(r.value);
                            break;
                        case "v3":
                            i.uniforms[e].value = (new yn).fromArray(r.value);
                            break;
                        case "v4":
                            i.uniforms[e].value = (new pn).fromArray(r.value);
                            break;
                        case "m3":
                            i.uniforms[e].value = (new an).fromArray(r.value);
                        case "m4":
                            i.uniforms[e].value = (new En).fromArray(r.value);
                            break;
                        default:
                            i.uniforms[e].value = r.value
                    }
                }
            if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                for (const e in t.extensions) i.extensions[e] = t.extensions[e];
            if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                let e = t.normalScale;
                !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new sn).fromArray(e)
            }
            return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new sn).fromArray(t.clearcoatNormalScale)), i
        },
        setTextures: function(t) {
            return this.textures = t, this
        }
    });
    const qu = function(t) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
            let e = "";
            for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
            try {
                return decodeURIComponent(escape(e))
            } catch (t) {
                return e
            }
        },
        Xu = function(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        };

    function Zu() {
        ur.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }

    function Yu(t, e, n, i) {
        "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Wi.call(this, t, e, n), this.meshPerAttribute = i || 1
    }

    function $u(t) {
        Ql.call(this, t)
    }
    Zu.prototype = Object.assign(Object.create(ur.prototype), {
        constructor: Zu,
        isInstancedBufferGeometry: !0,
        copy: function(t) {
            return ur.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            const t = ur.prototype.toJSON.call(this);
            return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
        }
    }), Yu.prototype = Object.assign(Object.create(Wi.prototype), {
        constructor: Yu,
        isInstancedBufferAttribute: !0,
        copy: function(t) {
            return Wi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        },
        toJSON: function() {
            const t = Wi.prototype.toJSON.call(this);
            return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
        }
    }), $u.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: $u,
        load: function(t, e, n, i) {
            const r = this,
                o = new eu(r.manager);
            o.setPath(r.path), o.load(t, (function(n) {
                try {
                    e(r.parse(JSON.parse(n)))
                } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                }
            }), n, i)
        },
        parse: function(t) {
            const e = {},
                n = {};

            function i(t, i) {
                if (void 0 !== e[i]) return e[i];
                const r = t.interleavedBuffers[i],
                    o = function(t, e) {
                        if (void 0 !== n[e]) return n[e];
                        const i = t.arrayBuffers[e],
                            r = new Uint32Array(i).buffer;
                        return n[e] = r, r
                    }(t, r.buffer),
                    s = new ca(new Ju[r.type](o), r.stride);
                return s.uuid = r.uuid, e[i] = s, s
            }
            const r = t.isInstancedBufferGeometry ? new Zu : new ur,
                o = t.data.index;
            if (void 0 !== o) {
                const t = new Ju[o.type](o.array);
                r.setIndex(new Wi(t, 1))
            }
            const s = t.data.attributes;
            for (const e in s) {
                const n = s[e];
                let o;
                if (n.isInterleavedBufferAttribute) {
                    o = new ua(i(t.data, n.data), n.itemSize, n.offset, n.normalized)
                } else {
                    const t = new Ju[n.type](n.array);
                    o = new(n.isInstancedBufferAttribute ? Yu : Wi)(t, n.itemSize, n.normalized)
                }
                void 0 !== n.name && (o.name = n.name), r.setAttribute(e, o)
            }
            const a = t.data.morphAttributes;
            if (a)
                for (const e in a) {
                    const n = a[e],
                        o = [];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        let s;
                        if (r.isInterleavedBufferAttribute) {
                            s = new ua(i(t.data, r.data), r.itemSize, r.offset, r.normalized)
                        } else {
                            s = new Wi(new Ju[r.type](r.array), r.itemSize, r.normalized)
                        }
                        void 0 !== r.name && (s.name = r.name), o.push(s)
                    }
                    r.morphAttributes[e] = o
                }
            t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
            const c = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== c)
                for (let t = 0, e = c.length; t !== e; ++t) {
                    const e = c[t];
                    r.addGroup(e.start, e.count, e.materialIndex)
                }
            const l = t.data.boundingSphere;
            if (void 0 !== l) {
                const t = new yn;
                void 0 !== l.center && t.fromArray(l.center), r.boundingSphere = new ci(t, l.radius)
            }
            return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
        }
    });
    const Ju = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function Ku(t) {
        Ql.call(this, t)
    }
    Ku.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: Ku,
        load: function(t, e, n, i) {
            const r = this,
                o = "" === this.path ? Xu(t) : this.path;
            this.resourcePath = this.resourcePath || o;
            const s = new eu(r.manager);
            s.setPath(this.path), s.load(t, (function(n) {
                let o = null;
                try {
                    o = JSON.parse(n)
                } catch (e) {
                    return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                }
                const s = o.metadata;
                void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
            }), n, i)
        },
        parse: function(t, e) {
            const n = this.parseShape(t.shapes),
                i = this.parseGeometries(t.geometries, n),
                r = this.parseImages(t.images, (function() {
                    void 0 !== e && e(a)
                })),
                o = this.parseTextures(t.textures, r),
                s = this.parseMaterials(t.materials, o),
                a = this.parseObject(t.object, i, s);
            return t.animations && (a.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a), a
        },
        parseShape: function(t) {
            const e = {};
            if (void 0 !== t)
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = (new Pu).fromJSON(t[n]);
                    e[i.uuid] = i
                }
            return e
        },
        parseGeometries: function(t, e) {
            const n = {};
            let i;
            if (void 0 !== t) {
                const r = new $u;
                for (let o = 0, s = t.length; o < s; o++) {
                    let s;
                    const a = t[o];
                    switch (a.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            s = new Ml[a.type](a.width, a.height, a.widthSegments, a.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            s = new Ml[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            s = new Ml[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            s = new Ml[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            s = new Ml[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            s = new Ml[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            s = new Ml[a.type](a.radius, a.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            s = new Ml[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            s = new Ml[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            s = new Ml[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            s = new Ml[a.type]((new Cu[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            s = new Ml[a.type](a.points, a.segments, a.phiStart, a.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            s = new Ml[a.type](a.vertices, a.indices, a.radius, a.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            i = [];
                            for (let t = 0, n = a.shapes.length; t < n; t++) {
                                const n = e[a.shapes[t]];
                                i.push(n)
                            }
                            s = new Ml[a.type](i, a.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            i = [];
                            for (let t = 0, n = a.shapes.length; t < n; t++) {
                                const n = e[a.shapes[t]];
                                i.push(n)
                            }
                            const t = a.options.extrudePath;
                            void 0 !== t && (a.options.extrudePath = (new Cu[t.type]).fromJSON(t)), s = new Ml[a.type](i, a.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            s = r.parse(a);
                            break;
                        case "Geometry":
                            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"');
                            continue
                    }
                    s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s
                }
            }
            return n
        },
        parseMaterials: function(t, e) {
            const n = {},
                i = {};
            if (void 0 !== t) {
                const r = new Wu;
                r.setTextures(e);
                for (let e = 0, o = t.length; e < o; e++) {
                    const o = t[e];
                    if ("MultiMaterial" === o.type) {
                        const t = [];
                        for (let e = 0; e < o.materials.length; e++) {
                            const i = o.materials[e];
                            void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid])
                        }
                        i[o.uuid] = t
                    } else void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)), i[o.uuid] = n[o.uuid]
                }
            }
            return i
        },
        parseAnimations: function(t) {
            const e = [];
            for (let n = 0; n < t.length; n++) {
                const i = t[n],
                    r = Zl.parse(i);
                void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r)
            }
            return e
        },
        parseImages: function(t, e) {
            const n = this,
                i = {};
            let r;

            function o(t) {
                return n.manager.itemStart(t), r.load(t, (function() {
                    n.manager.itemEnd(t)
                }), void 0, (function() {
                    n.manager.itemError(t), n.manager.itemEnd(t)
                }))
            }
            if (void 0 !== t && t.length > 0) {
                const s = new Jl(e);
                r = new ou(s), r.setCrossOrigin(this.crossOrigin);
                for (let e = 0, r = t.length; e < r; e++) {
                    const r = t[e],
                        s = r.url;
                    if (Array.isArray(s)) {
                        i[r.uuid] = [];
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t],
                                a = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e;
                            i[r.uuid].push(o(a))
                        }
                    } else {
                        const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url) ? r.url : n.resourcePath + r.url;
                        i[r.uuid] = o(t)
                    }
                }
            }
            return i
        },
        parseTextures: function(t, e) {
            function n(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
            }
            const i = {};
            if (void 0 !== t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const o = t[r];
                    let s;
                    void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image), s = Array.isArray(e[o.image]) ? new vo(e[o.image]) : new hn(e[o.image]), s.needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, Qu)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], th), s.wrapT = n(o.wrap[1], th)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, eh)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, eh)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), i[o.uuid] = s
                }
            return i
        },
        parseObject: function(t, e, n) {
            let i, r, o;

            function s(t) {
                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
            }

            function a(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        const e = [];
                        for (let i = 0, r = t.length; i < r; i++) {
                            const r = t[i];
                            void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(n[r])
                        }
                        return e
                    }
                    return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                }
            }
            switch (t.type) {
                case "Scene":
                    i = new Wn, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new Ni(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new aa(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new sa(t.fog.color, t.fog.density)));
                    break;
                case "PerspectiveCamera":
                    i = new Gr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                    break;
                case "OrthographicCamera":
                    i = new Bu(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                    break;
                case "AmbientLight":
                    i = new ju(t.color, t.intensity);
                    break;
                case "DirectionalLight":
                    i = new Fu(t.color, t.intensity);
                    break;
                case "PointLight":
                    i = new Uu(t.color, t.intensity, t.distance, t.decay);
                    break;
                case "RectAreaLight":
                    i = new Hu(t.color, t.intensity, t.width, t.height);
                    break;
                case "SpotLight":
                    i = new Nu(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                    break;
                case "HemisphereLight":
                    i = new Ru(t.color, t.groundColor, t.intensity);
                    break;
                case "LightProbe":
                    i = (new Vu).fromJSON(t);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    r = s(t.geometry), o = a(t.material), i = new Ar(r, o);
                    break;
                case "InstancedMesh":
                    r = s(t.geometry), o = a(t.material);
                    const e = t.count,
                        n = t.instanceMatrix;
                    i = new za(r, o, e), i.instanceMatrix = new Wi(new Float32Array(n.array), 16);
                    break;
                case "LOD":
                    i = new La;
                    break;
                case "Line":
                    i = new qa(s(t.geometry), a(t.material), t.mode);
                    break;
                case "LineLoop":
                    i = new $a(s(t.geometry), a(t.material));
                    break;
                case "LineSegments":
                    i = new Ya(s(t.geometry), a(t.material));
                    break;
                case "PointCloud":
                case "Points":
                    i = new nc(s(t.geometry), a(t.material));
                    break;
                case "Sprite":
                    i = new Ta(a(t.material));
                    break;
                case "Group":
                    i = new ta;
                    break;
                default:
                    i = new Vn
            }
            if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (i.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children) {
                const r = t.children;
                for (let t = 0; t < r.length; t++) i.add(this.parseObject(r[t], e, n))
            }
            if ("LOD" === t.type) {
                void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
                const e = t.levels;
                for (let t = 0; t < e.length; t++) {
                    const n = e[t],
                        r = i.getObjectByProperty("uuid", n.object);
                    void 0 !== r && i.addLevel(r, n.distance)
                }
            }
            return i
        }
    });
    const Qu = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        },
        th = {
            RepeatWrapping: 1e3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
        },
        eh = {
            NearestFilter: 1003,
            NearestMipmapNearestFilter: 1004,
            NearestMipmapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipmapNearestFilter: 1007,
            LinearMipmapLinearFilter: 1008
        };

    function nh(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Ql.call(this, t), this.options = {
            premultiplyAlpha: "none"
        }
    }

    function ih() {
        this.type = "ShapePath", this.color = new Ni, this.subPaths = [], this.currentPath = null
    }

    function rh(t) {
        this.type = "Font", this.data = t
    }

    function oh(t, e, n, i, r) {
        const o = r.glyphs[t] || r.glyphs["?"];
        if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
        const s = new ih;
        let a, c, l, u, h, p, f, d;
        if (o.o) {
            const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
            for (let r = 0, o = t.length; r < o;) {
                switch (t[r++]) {
                    case "m":
                        a = t[r++] * e + n, c = t[r++] * e + i, s.moveTo(a, c);
                        break;
                    case "l":
                        a = t[r++] * e + n, c = t[r++] * e + i, s.lineTo(a, c);
                        break;
                    case "q":
                        l = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, p = t[r++] * e + i, s.quadraticCurveTo(h, p, l, u);
                        break;
                    case "b":
                        l = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, p = t[r++] * e + i, f = t[r++] * e + n, d = t[r++] * e + i, s.bezierCurveTo(h, p, f, d, l, u)
                }
            }
        }
        return {
            offsetX: o.ha * e,
            path: s
        }
    }

    function sh(t) {
        Ql.call(this, t)
    }
    let ah;
    nh.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: nh,
        isImageBitmapLoader: !0,
        setOptions: function(t) {
            return this.options = t, this
        },
        load: function(t, e, n, i) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = this,
                o = $l.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function() {
                e && e(o), r.manager.itemEnd(t)
            }), 0), o;
            fetch(t).then((function(t) {
                return t.blob()
            })).then((function(t) {
                return createImageBitmap(t, r.options)
            })).then((function(n) {
                $l.add(t, n), e && e(n), r.manager.itemEnd(t)
            })).catch((function(e) {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
            })), r.manager.itemStart(t)
        }
    }), Object.assign(ih.prototype, {
        moveTo: function(t, e) {
            return this.currentPath = new Lu, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
        },
        lineTo: function(t, e) {
            return this.currentPath.lineTo(t, e), this
        },
        quadraticCurveTo: function(t, e, n, i) {
            return this.currentPath.quadraticCurveTo(t, e, n, i), this
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this
        },
        splineThru: function(t) {
            return this.currentPath.splineThru(t), this
        },
        toShapes: function(t, e) {
            function n(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n],
                        r = new Pu;
                    r.curves = i.curves, e.push(r)
                }
                return e
            }

            function i(t, e) {
                const n = e.length;
                let i = !1;
                for (let r = n - 1, o = 0; o < n; r = o++) {
                    let n = e[r],
                        s = e[o],
                        a = s.x - n.x,
                        c = s.y - n.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (c < 0 && (n = e[o], a = -a, s = e[r], c = -c), t.y < n.y || t.y > s.y) continue;
                        if (t.y === n.y) {
                            if (t.x === n.x) return !0
                        } else {
                            const e = c * (t.x - n.x) - a * (t.y - n.y);
                            if (0 === e) return !0;
                            if (e < 0) continue;
                            i = !i
                        }
                    } else {
                        if (t.y !== n.y) continue;
                        if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x) return !0
                    }
                }
                return i
            }
            const r = Kc.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === e) return n(o);
            let s, a, c, l = [];
            if (1 === o.length) return a = o[0], c = new Pu, c.curves = a.curves, l.push(c), l;
            let u = !r(o[0].getPoints());
            u = t ? !u : u;
            const h = [],
                p = [];
            let f, d, m = [],
                g = 0;
            p[g] = void 0, m[g] = [];
            for (let e = 0, n = o.length; e < n; e++) a = o[e], f = a.getPoints(), s = r(f), s = t ? !s : s, s ? (!u && p[g] && g++, p[g] = {
                s: new Pu,
                p: f
            }, p[g].s.curves = a.curves, u && g++, m[g] = []) : m[g].push({
                h: a,
                p: f[0]
            });
            if (!p[0]) return n(o);
            if (p.length > 1) {
                let t = !1;
                const e = [];
                for (let t = 0, e = p.length; t < e; t++) h[t] = [];
                for (let n = 0, r = p.length; n < r; n++) {
                    const r = m[n];
                    for (let o = 0; o < r.length; o++) {
                        const s = r[o];
                        let a = !0;
                        for (let r = 0; r < p.length; r++) i(s.p, p[r].p) && (n !== r && e.push({
                            froms: n,
                            tos: r,
                            hole: o
                        }), a ? (a = !1, h[r].push(s)) : t = !0);
                        a && h[n].push(s)
                    }
                }
                e.length > 0 && (t || (m = h))
            }
            for (let t = 0, e = p.length; t < e; t++) {
                c = p[t].s, l.push(c), d = m[t];
                for (let t = 0, e = d.length; t < e; t++) c.holes.push(d[t].h)
            }
            return l
        }
    }), Object.assign(rh.prototype, {
        isFont: !0,
        generateShapes: function(t, e) {
            void 0 === e && (e = 100);
            const n = [],
                i = function(t, e, n) {
                    const i = Array.from ? Array.from(t) : String(t).split(""),
                        r = e / n.resolution,
                        o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                        s = [];
                    let a = 0,
                        c = 0;
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        if ("\n" === e) a = 0, c -= o;
                        else {
                            const t = oh(e, r, a, c, n);
                            a += t.offsetX, s.push(t.path)
                        }
                    }
                    return s
                }(t, e, this.data);
            for (let t = 0, e = i.length; t < e; t++) Array.prototype.push.apply(n, i[t].toShapes());
            return n
        }
    }), sh.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: sh,
        load: function(t, e, n, i) {
            const r = this,
                o = new eu(this.manager);
            o.setPath(this.path), o.load(t, (function(t) {
                let n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                }
                const i = r.parse(n);
                e && e(i)
            }), n, i)
        },
        parse: function(t) {
            return new rh(t)
        }
    });
    const ch = function() {
        return void 0 === ah && (ah = new(window.AudioContext || window.webkitAudioContext)), ah
    };

    function lh(t) {
        Ql.call(this, t)
    }

    function uh(t, e, n) {
        Vu.call(this, void 0, n);
        const i = (new Ni).set(t),
            r = (new Ni).set(e),
            o = new yn(i.r, i.g, i.b),
            s = new yn(r.r, r.g, r.b),
            a = Math.sqrt(Math.PI),
            c = a * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c)
    }

    function hh(t, e) {
        Vu.call(this, void 0, e);
        const n = (new Ni).set(t);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    lh.prototype = Object.assign(Object.create(Ql.prototype), {
        constructor: lh,
        load: function(t, e, n, i) {
            const r = this,
                o = new eu(r.manager);
            o.setResponseType("arraybuffer"), o.setPath(r.path), o.load(t, (function(n) {
                try {
                    const t = n.slice(0);
                    ch().decodeAudioData(t, (function(t) {
                        e(t)
                    }))
                } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                }
            }), n, i)
        }
    }), uh.prototype = Object.assign(Object.create(Vu.prototype), {
        constructor: uh,
        isHemisphereLightProbe: !0,
        copy: function(t) {
            return Vu.prototype.copy.call(this, t), this
        },
        toJSON: function(t) {
            return Vu.prototype.toJSON.call(this, t)
        }
    }), hh.prototype = Object.assign(Object.create(Vu.prototype), {
        constructor: hh,
        isAmbientLightProbe: !0,
        copy: function(t) {
            return Vu.prototype.copy.call(this, t), this
        },
        toJSON: function(t) {
            return Vu.prototype.toJSON.call(this, t)
        }
    });
    const ph = new En,
        fh = new En;

    function dh(t) {
        this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    Object.assign(function() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Gr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Gr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }.prototype, {
        update: function(t) {
            const e = this._cache;
            if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                const n = t.projectionMatrix.clone(),
                    i = e.eyeSep / 2,
                    r = i * e.near / e.focus,
                    o = e.near * Math.tan(on.DEG2RAD * e.fov * .5) / e.zoom;
                let s, a;
                fh.elements[12] = -i, ph.elements[12] = i, s = -o * e.aspect + r, a = o * e.aspect + r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(n), s = -o * e.aspect - r, a = o * e.aspect - r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(n)
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(fh), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(ph)
        }
    }), Object.assign(dh.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                const e = ("undefined" == typeof performance ? Date : performance).now();
                t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
            }
            return t
        }
    });
    const mh = new yn,
        gh = new mn,
        vh = new yn,
        yh = new yn;

    function bh() {
        Vn.call(this), this.type = "AudioListener", this.context = ch(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new dh
    }

    function xh(t) {
        Vn.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this.filters = []
    }
    bh.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: bh,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function(t) {
            Vn.prototype.updateMatrixWorld.call(this, t);
            const e = this.context.listener,
                n = this.up;
            if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(mh, gh, vh), yh.set(0, 0, -1).applyQuaternion(gh), e.positionX) {
                const t = this.context.currentTime + this.timeDelta;
                e.positionX.linearRampToValueAtTime(mh.x, t), e.positionY.linearRampToValueAtTime(mh.y, t), e.positionZ.linearRampToValueAtTime(mh.z, t), e.forwardX.linearRampToValueAtTime(yh.x, t), e.forwardY.linearRampToValueAtTime(yh.y, t), e.forwardZ.linearRampToValueAtTime(yh.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
            } else e.setPosition(mh.x, mh.y, mh.z), e.setOrientation(yh.x, yh.y, yh.z, n.x, n.y, n.z)
        }
    }), xh.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: xh,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(t) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
        },
        setMediaElementSource: function(t) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
        },
        setMediaStreamSource: function(t) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
        },
        setBuffer: function(t) {
            return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function(t) {
            if (void 0 === t && (t = 0), !0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(t) {
            return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
        },
        setDetune: function(t) {
            if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function(t) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function(t) {
            if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        setLoopStart: function(t) {
            return this.loopStart = t, this
        },
        setLoopEnd: function(t) {
            return this.loopEnd = t, this
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        }
    });
    const wh = new yn,
        _h = new mn,
        Mh = new yn,
        Sh = new yn;

    function Th(t) {
        xh.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    function Eh(t, e) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
    }

    function Ch(t, e, n) {
        let i, r, o;
        switch (this.binding = t, this.valueSize = n, e) {
            case "quaternion":
                i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                break;
            default:
                i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    Th.prototype = Object.assign(Object.create(xh.prototype), {
        constructor: Th,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(t) {
            return this.panner.refDistance = t, this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(t) {
            return this.panner.rolloffFactor = t, this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(t) {
            return this.panner.distanceModel = t, this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(t) {
            return this.panner.maxDistance = t, this
        },
        setDirectionalCone: function(t, e, n) {
            return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
        },
        updateMatrixWorld: function(t) {
            if (Vn.prototype.updateMatrixWorld.call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
            this.matrixWorld.decompose(wh, _h, Mh), Sh.set(0, 0, 1).applyQuaternion(_h);
            const e = this.panner;
            if (e.positionX) {
                const t = this.context.currentTime + this.listener.timeDelta;
                e.positionX.linearRampToValueAtTime(wh.x, t), e.positionY.linearRampToValueAtTime(wh.y, t), e.positionZ.linearRampToValueAtTime(wh.z, t), e.orientationX.linearRampToValueAtTime(Sh.x, t), e.orientationY.linearRampToValueAtTime(Sh.y, t), e.orientationZ.linearRampToValueAtTime(Sh.z, t)
            } else e.setPosition(wh.x, wh.y, wh.z), e.setOrientation(Sh.x, Sh.y, Sh.z)
        }
    }), Object.assign(Eh.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function() {
            let t = 0;
            const e = this.getFrequencyData();
            for (let n = 0; n < e.length; n++) t += e[n];
            return t / e.length
        }
    }), Object.assign(Ch.prototype, {
        accumulate: function(t, e) {
            const n = this.buffer,
                i = this.valueSize,
                r = t * i + i;
            let o = this.cumulativeWeight;
            if (0 === o) {
                for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                o = e
            } else {
                o += e;
                const t = e / o;
                this._mixBufferRegion(n, r, 0, t, i)
            }
            this.cumulativeWeight = o
        },
        accumulateAdditive: function(t) {
            const e = this.buffer,
                n = this.valueSize,
                i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
        },
        apply: function(t) {
            const e = this.valueSize,
                n = this.buffer,
                i = t * e + e,
                r = this.cumulativeWeight,
                o = this.cumulativeWeightAdditive,
                s = this.binding;
            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                const t = e * this._origIndex;
                this._mixBufferRegion(n, i, t, 1 - r, e)
            }
            o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
                if (n[t] !== n[t + e]) {
                    s.setValue(n, i);
                    break
                }
        },
        saveOriginalState: function() {
            const t = this.binding,
                e = this.buffer,
                n = this.valueSize,
                i = n * this._origIndex;
            t.getValue(e, i);
            for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
        },
        restoreOriginalState: function() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _setAdditiveIdentityNumeric: function() {
            const t = this._addIndex * this.valueSize,
                e = t + this.valueSize;
            for (let n = t; n < e; n++) this.buffer[n] = 0
        },
        _setAdditiveIdentityQuaternion: function() {
            this._setAdditiveIdentityNumeric(), this.buffer[4 * this._addIndex + 3] = 1
        },
        _setAdditiveIdentityOther: function() {
            const t = this._origIndex * this.valueSize,
                e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
        },
        _select: function(t, e, n, i, r) {
            if (i >= .5)
                for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
        },
        _slerp: function(t, e, n, i) {
            mn.slerpFlat(t, e, t, e, t, n, i)
        },
        _slerpAdditive: function(t, e, n, i, r) {
            const o = this._workIndex * r;
            mn.multiplyQuaternionsFlat(t, o, t, e, t, n), mn.slerpFlat(t, e, t, e, t, o, i)
        },
        _lerp: function(t, e, n, i, r) {
            const o = 1 - i;
            for (let s = 0; s !== r; ++s) {
                const r = e + s;
                t[r] = t[r] * o + t[n + s] * i
            }
        },
        _lerpAdditive: function(t, e, n, i, r) {
            for (let o = 0; o !== r; ++o) {
                const r = e + o;
                t[r] = t[r] + t[n + o] * i
            }
        }
    });
    const Ah = new RegExp("[\\[\\]\\.:\\/]", "g"),
        Lh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        Ph = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Oh = /(WCOD+)?/.source.replace("WCOD", Lh),
        Rh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Ih = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Dh = new RegExp("^" + Ph + Oh + Rh + Ih + "$"),
        Nh = ["material", "materials", "bones"];

    function kh(t, e, n) {
        const i = n || Uh.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, i)
    }

    function Uh(t, e, n) {
        this.path = e, this.parsedPath = n || Uh.parseTrackName(e), this.node = Uh.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
    }

    function Bh(t, e, n, i) {
        this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = i || e.blendMode;
        const r = e.tracks,
            o = r.length,
            s = new Array(o),
            a = {
                endingStart: 2400,
                endingEnd: 2400
            };
        for (let t = 0; t !== o; ++t) {
            const e = r[t].createInterpolant(null);
            s[t] = e, e.settings = a
        }
        this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function zh(t) {
        this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function Fh(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
    }

    function jh(t, e, n) {
        ca.call(this, t, e), this.meshPerAttribute = n || 1
    }

    function Hh(t, e, n, i) {
        this.ray = new gi(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new Pn, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Gh(t, e) {
        return t.distance - e.distance
    }

    function Vh(t, e, n, i) {
        if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++) Vh(i[t], e, n, !0)
        }
    }

    function Wh(t, e, n) {
        return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
    }
    Object.assign(kh.prototype, {
        getValue: function(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            void 0 !== i && i.getValue(t, e)
        },
        setValue: function(t, e) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
        },
        bind: function() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
        },
        unbind: function() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
        }
    }), Object.assign(Uh, {
        Composite: kh,
        create: function(t, e, n) {
            return t && t.isAnimationObjectGroup ? new Uh.Composite(t, e, n) : new Uh(t, e, n)
        },
        sanitizeNodeName: function(t) {
            return t.replace(/\s/g, "_").replace(Ah, "")
        },
        parseTrackName: function(t) {
            const e = Dh.exec(t);
            if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                const t = n.nodeName.substring(i + 1); - 1 !== Nh.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
            }
            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n
        },
        findNode: function(t, e) {
            if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
            if (t.skeleton) {
                const n = t.skeleton.getBoneByName(e);
                if (void 0 !== n) return n
            }
            if (t.children) {
                const n = function(t) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            if (r.name === e || r.uuid === e) return r;
                            const o = n(r.children);
                            if (o) return o
                        }
                        return null
                    },
                    i = n(t.children);
                if (i) return i
            }
            return null
        }
    }), Object.assign(Uh.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(t, e) {
            t[e] = this.node[this.propertyName]
        }, function(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
        }, function(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }, function(t, e) {
            this.resolvedProperty.toArray(t, e)
        }],
        SetterByBindingTypeAndVersioning: [
            [function(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }, function(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }, function(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }, function(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }, function(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }, function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }, function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }, function(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }, function(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function(t, e) {
            this.bind(), this.getValue(t, e)
        },
        setValue: function(t, e) {
            this.bind(), this.setValue(t, e)
        },
        bind: function() {
            let t = this.node,
                e = this.parsedPath,
                n = e.objectName,
                i = e.propertyName,
                r = e.propertyIndex;
            if (t || (t = Uh.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (n) {
                let i = e.objectIndex;
                switch (n) {
                    case "materials":
                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === i) {
                                i = e;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                }
                if (void 0 !== i) {
                    if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    t = t[i]
                }
            }
            const o = t[i];
            if (void 0 === o) {
                const n = e.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
            }
            let s = this.Versioning.None;
            this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
            let a = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                    if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                }
                a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
            } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Uh.prototype, {
        _getValue_unbound: Uh.prototype.getValue,
        _setValue_unbound: Uh.prototype.setValue
    }), Object.assign(function() {
        this.uuid = on.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const t = {};
        this._indicesByUUID = t;
        for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const e = this;
        this.stats = {
            objects: {
                get total() {
                    return e._objects.length
                },
                get inUse() {
                    return this.total - e.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return e._bindings.length
            }
        }
    }.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            const t = this._objects,
                e = this._indicesByUUID,
                n = this._paths,
                i = this._parsedPaths,
                r = this._bindings,
                o = r.length;
            let s = void 0,
                a = t.length,
                c = this.nCachedObjects_;
            for (let l = 0, u = arguments.length; l !== u; ++l) {
                const u = arguments[l],
                    h = u.uuid;
                let p = e[h];
                if (void 0 === p) {
                    p = a++, e[h] = p, t.push(u);
                    for (let t = 0, e = o; t !== e; ++t) r[t].push(new Uh(u, n[t], i[t]))
                } else if (p < c) {
                    s = t[p];
                    const a = --c,
                        l = t[a];
                    e[l.uuid] = p, t[p] = l, e[h] = a, t[a] = u;
                    for (let t = 0, e = o; t !== e; ++t) {
                        const e = r[t],
                            o = e[a];
                        let s = e[p];
                        e[p] = o, void 0 === s && (s = new Uh(u, n[t], i[t])), e[a] = s
                    }
                } else t[p] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = c
        },
        remove: function() {
            const t = this._objects,
                e = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
            let r = this.nCachedObjects_;
            for (let o = 0, s = arguments.length; o !== s; ++o) {
                const s = arguments[o],
                    a = s.uuid,
                    c = e[a];
                if (void 0 !== c && c >= r) {
                    const o = r++,
                        l = t[o];
                    e[l.uuid] = c, t[c] = l, e[a] = o, t[o] = s;
                    for (let t = 0, e = i; t !== e; ++t) {
                        const e = n[t],
                            i = e[o],
                            r = e[c];
                        e[c] = i, e[o] = r
                    }
                }
            }
            this.nCachedObjects_ = r
        },
        uncache: function() {
            const t = this._objects,
                e = this._indicesByUUID,
                n = this._bindings,
                i = n.length;
            let r = this.nCachedObjects_,
                o = t.length;
            for (let s = 0, a = arguments.length; s !== a; ++s) {
                const a = arguments[s].uuid,
                    c = e[a];
                if (void 0 !== c)
                    if (delete e[a], c < r) {
                        const s = --r,
                            a = t[s],
                            l = --o,
                            u = t[l];
                        e[a.uuid] = c, t[c] = a, e[u.uuid] = s, t[s] = u, t.pop();
                        for (let t = 0, e = i; t !== e; ++t) {
                            const e = n[t],
                                i = e[s],
                                r = e[l];
                            e[c] = i, e[s] = r, e.pop()
                        }
                    } else {
                        const r = --o,
                            s = t[r];
                        e[s.uuid] = c, t[c] = s, t.pop();
                        for (let t = 0, e = i; t !== e; ++t) {
                            const e = n[t];
                            e[c] = e[r], e.pop()
                        }
                    }
            }
            this.nCachedObjects_ = r
        },
        subscribe_: function(t, e) {
            let n = this._bindingsIndicesByPath,
                i = n[t],
                r = this._bindings;
            if (void 0 !== i) return r[i];
            const o = this._paths,
                s = this._parsedPaths,
                a = this._objects,
                c = a.length,
                l = this.nCachedObjects_,
                u = new Array(c);
            i = r.length, n[t] = i, o.push(t), s.push(e), r.push(u);
            for (let n = l, i = a.length; n !== i; ++n) {
                const i = a[n];
                u[n] = new Uh(i, t, e)
            }
            return u
        },
        unsubscribe_: function(t) {
            const e = this._bindingsIndicesByPath,
                n = e[t];
            if (void 0 !== n) {
                const i = this._paths,
                    r = this._parsedPaths,
                    o = this._bindings,
                    s = o.length - 1,
                    a = o[s];
                e[t[s]] = n, o[n] = a, o.pop(), r[n] = r[s], r.pop(), i[n] = i[s], i.pop()
            }
        }
    }), Object.assign(Bh.prototype, {
        play: function() {
            return this._mixer._activateAction(this), this
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(t) {
            return this._startTime = t, this
        },
        setLoop: function(t, e) {
            return this.loop = t, this.repetitions = e, this
        },
        setEffectiveWeight: function(t) {
            return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function(t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function(t, e, n) {
            if (t.fadeOut(e), this.fadeIn(e), n) {
                const n = this._clip.duration,
                    i = t._clip.duration,
                    r = i / n,
                    o = n / i;
                t.warp(1, r, e), this.warp(o, 1, e)
            }
            return this
        },
        crossFadeTo: function(t, e, n) {
            return t.crossFadeFrom(this, e, n)
        },
        stopFading: function() {
            let t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        },
        setEffectiveTimeScale: function(t) {
            return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(t) {
            return this.timeScale = this._clip.duration / t, this.stopWarping()
        },
        syncWith: function(t) {
            return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
        },
        halt: function(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function(t, e, n) {
            const i = this._mixer,
                r = i.time,
                o = this.timeScale;
            let s = this._timeScaleInterpolant;
            null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
            const a = s.parameterPositions,
                c = s.sampleValues;
            return a[0] = r, a[1] = r + n, c[0] = t / o, c[1] = e / o, this
        },
        stopWarping: function() {
            let t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(t, e, n, i) {
            if (!this.enabled) return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
                const i = (t - r) * n;
                if (i < 0 || 0 === n) return;
                this._startTime = null, e = n * i
            }
            e *= this._updateTimeScale(t);
            const o = this._updateTime(e),
                s = this._updateWeight(t);
            if (s > 0) {
                const t = this._interpolants,
                    e = this._propertyBindings;
                switch (this.blendMode) {
                    case 2501:
                        for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(o), e[n].accumulateAdditive(s);
                        break;
                    case 2500:
                    default:
                        for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulate(i, s)
                }
            }
        },
        _updateWeight: function(t) {
            let e = 0;
            if (this.enabled) {
                e = this.weight;
                const n = this._weightInterpolant;
                if (null !== n) {
                    const i = n.evaluate(t)[0];
                    e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e, e
        },
        _updateTimeScale: function(t) {
            let e = 0;
            if (!this.paused) {
                e = this.timeScale;
                const n = this._timeScaleInterpolant;
                if (null !== n) {
                    e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                }
            }
            return this._effectiveTimeScale = e, e
        },
        _updateTime: function(t) {
            const e = this._clip.duration,
                n = this.loop;
            let i = this.time + t,
                r = this._loopCount;
            const o = 2202 === n;
            if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
            if (2200 === n) {
                -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                t: {
                    if (i >= e) i = e;
                    else {
                        if (!(i < 0)) {
                            this.time = i;
                            break t
                        }
                        i = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= e || i < 0) {
                    const n = Math.floor(i / e);
                    i -= e * n, r += Math.abs(n);
                    const s = this.repetitions - r;
                    if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t > 0 ? 1 : -1
                    });
                    else {
                        if (1 === s) {
                            const e = t < 0;
                            this._setEndings(e, !e, o)
                        } else this._setEndings(!1, !1, o);
                        this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: n
                        })
                    }
                } else this.time = i;
                if (o && 1 == (1 & r)) return e - i
            }
            return i
        },
        _setEndings: function(t, e, n) {
            const i = this._interpolantSettings;
            n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(t, e, n) {
            const i = this._mixer,
                r = i.time;
            let o = this._weightInterpolant;
            null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
            const s = o.parameterPositions,
                a = o.sampleValues;
            return s[0] = r, a[0] = e, s[1] = r + t, a[1] = n, this
        }
    }), zh.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: zh,
        _bindAction: function(t, e) {
            const n = t._localRoot || this._root,
                i = t._clip.tracks,
                r = i.length,
                o = t._propertyBindings,
                s = t._interpolants,
                a = n.uuid,
                c = this._bindingsByRootAndName;
            let l = c[a];
            void 0 === l && (l = {}, c[a] = l);
            for (let t = 0; t !== r; ++t) {
                const r = i[t],
                    c = r.name;
                let u = l[c];
                if (void 0 !== u) o[t] = u;
                else {
                    if (u = o[t], void 0 !== u) {
                        null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, c));
                        continue
                    }
                    const i = e && e._propertyBindings[t].binding.parsedPath;
                    u = new Ch(Uh.create(n, c, i), r.ValueTypeName, r.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, c), o[t] = u
                }
                s[t].resultBuffer = u.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    const e = (t._localRoot || this._root).uuid,
                        n = t._clip.uuid,
                        i = this._actionsByClip[n];
                    this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                }
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            const t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function(t, e, n) {
            const i = this._actions,
                r = this._actionsByClip;
            let o = r[e];
            if (void 0 === o) o = {
                knownActions: [t],
                actionByRoot: {}
            }, t._byClipCacheIndex = 0, r[e] = o;
            else {
                const e = o.knownActions;
                t._byClipCacheIndex = e.length, e.push(t)
            }
            t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t
        },
        _removeInactiveAction: function(t) {
            const e = this._actions,
                n = e[e.length - 1],
                i = t._cacheIndex;
            n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
            const r = t._clip.uuid,
                o = this._actionsByClip,
                s = o[r],
                a = s.knownActions,
                c = a[a.length - 1],
                l = t._byClipCacheIndex;
            c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null;
            delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function(t) {
            const e = this._actions,
                n = t._cacheIndex,
                i = this._nActiveActions++,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _takeBackAction: function(t) {
            const e = this._actions,
                n = t._cacheIndex,
                i = --this._nActiveActions,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _addInactiveBinding: function(t, e, n) {
            const i = this._bindingsByRootAndName,
                r = this._bindings;
            let o = i[e];
            void 0 === o && (o = {}, i[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t)
        },
        _removeInactiveBinding: function(t) {
            const e = this._bindings,
                n = t.binding,
                i = n.rootNode.uuid,
                r = n.path,
                o = this._bindingsByRootAndName,
                s = o[i],
                a = e[e.length - 1],
                c = t._cacheIndex;
            a._cacheIndex = c, e[c] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i]
        },
        _lendBinding: function(t) {
            const e = this._bindings,
                n = t._cacheIndex,
                i = this._nActiveBindings++,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _takeBackBinding: function(t) {
            const e = this._bindings,
                n = t._cacheIndex,
                i = --this._nActiveBindings,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _lendControlInterpolant: function() {
            const t = this._controlInterpolants,
                e = this._nActiveControlInterpolants++;
            let n = t[e];
            return void 0 === n && (n = new Bl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
        },
        _takeBackControlInterpolant: function(t) {
            const e = this._controlInterpolants,
                n = t.__cacheIndex,
                i = --this._nActiveControlInterpolants,
                r = e[i];
            t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e, n) {
            const i = e || this._root,
                r = i.uuid;
            let o = "string" == typeof t ? Zl.findByName(i, t) : t;
            const s = null !== o ? o.uuid : t;
            let a = this._actionsByClip[s],
                c = null;
            if (void 0 === n && (n = null !== o ? o.blendMode : 2500), void 0 !== a) {
                const t = a.actionByRoot[r];
                if (void 0 !== t && t.blendMode === n) return t;
                c = a.knownActions[0], null === o && (o = c._clip)
            }
            if (null === o) return null;
            const l = new Bh(this, o, e, n);
            return this._bindAction(l, c), this._addInactiveAction(l, s, r), l
        },
        existingAction: function(t, e) {
            const n = e || this._root,
                i = n.uuid,
                r = "string" == typeof t ? Zl.findByName(n, t) : t,
                o = r ? r.uuid : t,
                s = this._actionsByClip[o];
            return void 0 !== s && s.actionByRoot[i] || null
        },
        stopAllAction: function() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            const e = this._actions,
                n = this._nActiveActions,
                i = this.time += t,
                r = Math.sign(t),
                o = this._accuIndex ^= 1;
            for (let s = 0; s !== n; ++s) {
                e[s]._update(i, t, r, o)
            }
            const s = this._bindings,
                a = this._nActiveBindings;
            for (let t = 0; t !== a; ++t) s[t].apply(o);
            return this
        },
        setTime: function(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
            return this.update(t)
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            const e = this._actions,
                n = t.uuid,
                i = this._actionsByClip,
                r = i[n];
            if (void 0 !== r) {
                const t = r.knownActions;
                for (let n = 0, i = t.length; n !== i; ++n) {
                    const i = t[n];
                    this._deactivateAction(i);
                    const r = i._cacheIndex,
                        o = e[e.length - 1];
                    i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(i)
                }
                delete i[n]
            }
        },
        uncacheRoot: function(t) {
            const e = t.uuid,
                n = this._actionsByClip;
            for (const t in n) {
                const i = n[t].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            const i = this._bindingsByRootAndName[e];
            if (void 0 !== i)
                for (const t in i) {
                    const e = i[t];
                    e.restoreOriginalState(), this._removeInactiveBinding(e)
                }
        },
        uncacheAction: function(t, e) {
            const n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
        }
    }), Fh.prototype.clone = function() {
        return new Fh(void 0 === this.value.clone ? this.value : this.value.clone())
    }, jh.prototype = Object.assign(Object.create(ca.prototype), {
        constructor: jh,
        isInstancedInterleavedBuffer: !0,
        copy: function(t) {
            return ca.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        },
        clone: function(t) {
            const e = ca.prototype.clone.call(this, t);
            return e.meshPerAttribute = this.meshPerAttribute, e
        },
        toJSON: function(t) {
            const e = ca.prototype.toJSON.call(this, t);
            return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
        }
    }), Object.assign(Hh.prototype, {
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(t, e, n) {
            const i = n || [];
            return Vh(t, this, i, e), i.sort(Gh), i
        },
        intersectObjects: function(t, e, n) {
            const i = n || [];
            if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
            for (let n = 0, r = t.length; n < r; n++) Vh(t[n], this, i, e);
            return i.sort(Gh), i
        }
    }), Object.assign(Wh.prototype, {
        set: function(t, e, n) {
            return this.radius = t, this.phi = e, this.theta = n, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function(t, e, n) {
            return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(on.clamp(e / this.radius, -1, 1))), this
        }
    }), Object.assign(function(t, e, n) {
        return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
    }.prototype, {
        set: function(t, e, n) {
            return this.radius = t, this.theta = e, this.y = n, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
        },
        setFromVector3: function(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function(t, e, n) {
            return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
        }
    });
    const qh = new sn;

    function Xh(t, e) {
        this.min = void 0 !== t ? t : new sn(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new sn(-1 / 0, -1 / 0)
    }
    Object.assign(Xh.prototype, {
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function(t, e) {
            const n = qh.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new sn), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new sn), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new sn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new sn), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function(t) {
            return qh.copy(t).clamp(this.min, this.max).sub(t).length()
        },
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    });
    const Zh = new yn,
        Yh = new yn;

    function $h(t, e) {
        this.start = void 0 !== t ? t : new yn, this.end = void 0 !== e ? e : new yn
    }

    function Jh(t) {
        Vn.call(this), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
    }
    Object.assign($h.prototype, {
        set: function(t, e) {
            return this.start.copy(t), this.end.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new yn), t.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new yn), t.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new yn), this.delta(e).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function(t, e) {
            Zh.subVectors(t, this.start), Yh.subVectors(this.end, this.start);
            const n = Yh.dot(Yh);
            let i = Yh.dot(Zh) / n;
            return e && (i = on.clamp(i, 0, 1)), i
        },
        closestPointToPoint: function(t, e, n) {
            const i = this.closestPointToPointParameter(t, e);
            return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new yn), this.delta(n).multiplyScalar(i).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }), Jh.prototype = Object.create(Vn.prototype), Jh.prototype.constructor = Jh, Jh.prototype.isImmediateRenderObject = !0;
    const Kh = new yn;

    function Qh(t, e) {
        Vn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        const n = new ur,
            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
            const r = t / n * Math.PI * 2,
                o = e / n * Math.PI * 2;
            i.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
        }
        n.setAttribute("position", new Qi(i, 3));
        const r = new Fa({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Ya(n, r), this.add(this.cone), this.update()
    }
    Qh.prototype = Object.create(Vn.prototype), Qh.prototype.constructor = Qh, Qh.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Qh.prototype.update = function() {
        this.light.updateMatrixWorld();
        const t = this.light.distance ? this.light.distance : 1e3,
            e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t), Kh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Kh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    };
    const tp = new yn,
        ep = new En,
        np = new En;

    function ip(t) {
        const e = function t(e) {
                const n = [];
                e && e.isBone && n.push(e);
                for (let i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                return n
            }(t),
            n = new ur,
            i = [],
            r = [],
            o = new Ni(0, 0, 1),
            s = new Ni(0, 1, 0);
        for (let t = 0; t < e.length; t++) {
            const n = e[t];
            n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b))
        }
        n.setAttribute("position", new Qi(i, 3)), n.setAttribute("color", new Qi(r, 3));
        const a = new Fa({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        Ya.call(this, n, a), this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }

    function rp(t, e, n) {
        this.light = t, this.light.updateMatrixWorld(), this.color = n;
        const i = new cl(e, 4, 2),
            r = new Hi({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            });
        Ar.call(this, i, r), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }
    ip.prototype = Object.create(Ya.prototype), ip.prototype.constructor = ip, ip.prototype.isSkeletonHelper = !0, ip.prototype.updateMatrixWorld = function(t) {
        const e = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
        np.getInverse(this.root.matrixWorld);
        for (let t = 0, n = 0; t < e.length; t++) {
            const r = e[t];
            r.parent && r.parent.isBone && (ep.multiplyMatrices(np, r.matrixWorld), tp.setFromMatrixPosition(ep), i.setXYZ(n, tp.x, tp.y, tp.z), ep.multiplyMatrices(np, r.parent.matrixWorld), tp.setFromMatrixPosition(ep), i.setXYZ(n + 1, tp.x, tp.y, tp.z), n += 2)
        }
        n.getAttribute("position").needsUpdate = !0, Vn.prototype.updateMatrixWorld.call(this, t)
    }, rp.prototype = Object.create(Ar.prototype), rp.prototype.constructor = rp, rp.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, rp.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    };
    const op = new yn,
        sp = new Ni,
        ap = new Ni;

    function cp(t, e, n) {
        Vn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
        const i = new gc(e);
        i.rotateY(.5 * Math.PI), this.material = new Hi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }), void 0 === this.color && (this.material.vertexColors = !0);
        const r = i.getAttribute("position"),
            o = new Float32Array(3 * r.count);
        i.setAttribute("color", new Wi(o, 3)), this.add(new Ar(i, this.material)), this.update()
    }

    function lp(t, e, n, i) {
        t = t || 10, e = e || 10, n = new Ni(void 0 !== n ? n : 4473924), i = new Ni(void 0 !== i ? i : 8947848);
        const r = e / 2,
            o = t / e,
            s = t / 2,
            a = [],
            c = [];
        for (let t = 0, l = 0, u = -s; t <= e; t++, u += o) {
            a.push(-s, 0, u, s, 0, u), a.push(u, 0, -s, u, 0, s);
            const e = t === r ? n : i;
            e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3
        }
        const l = new ur;
        l.setAttribute("position", new Qi(a, 3)), l.setAttribute("color", new Qi(c, 3));
        const u = new Fa({
            vertexColors: !0,
            toneMapped: !1
        });
        Ya.call(this, l, u), this.type = "GridHelper"
    }

    function up(t, e, n, i, r, o) {
        t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new Ni(void 0 !== r ? r : 4473924), o = new Ni(void 0 !== o ? o : 8947848);
        const s = [],
            a = [];
        for (let n = 0; n <= e; n++) {
            const i = n / e * (2 * Math.PI),
                c = Math.sin(i) * t,
                l = Math.cos(i) * t;
            s.push(0, 0, 0), s.push(c, 0, l);
            const u = 1 & n ? r : o;
            a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b)
        }
        for (let e = 0; e <= n; e++) {
            const c = 1 & e ? r : o,
                l = t - t / n * e;
            for (let t = 0; t < i; t++) {
                let e = t / i * (2 * Math.PI),
                    n = Math.sin(e) * l,
                    r = Math.cos(e) * l;
                s.push(n, 0, r), a.push(c.r, c.g, c.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * l, r = Math.cos(e) * l, s.push(n, 0, r), a.push(c.r, c.g, c.b)
            }
        }
        const c = new ur;
        c.setAttribute("position", new Qi(s, 3)), c.setAttribute("color", new Qi(a, 3));
        const l = new Fa({
            vertexColors: !0,
            toneMapped: !1
        });
        Ya.call(this, c, l), this.type = "PolarGridHelper"
    }
    cp.prototype = Object.create(Vn.prototype), cp.prototype.constructor = cp, cp.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, cp.prototype.update = function() {
        const t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
            const e = t.geometry.getAttribute("color");
            sp.copy(this.light.color), ap.copy(this.light.groundColor);
            for (let t = 0, n = e.count; t < n; t++) {
                const i = t < n / 2 ? sp : ap;
                e.setXYZ(t, i.r, i.g, i.b)
            }
            e.needsUpdate = !0
        }
        t.lookAt(op.setFromMatrixPosition(this.light.matrixWorld).negate())
    }, lp.prototype = Object.assign(Object.create(Ya.prototype), {
        constructor: lp,
        copy: function(t) {
            return Ya.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), up.prototype = Object.create(Ya.prototype), up.prototype.constructor = up;
    const hp = new yn,
        pp = new yn,
        fp = new yn;

    function dp(t, e, n) {
        Vn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
        let i = new ur;
        i.setAttribute("position", new Qi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        const r = new Fa({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new qa(i, r), this.add(this.lightPlane), i = new ur, i.setAttribute("position", new Qi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new qa(i, r), this.add(this.targetLine), this.update()
    }
    dp.prototype = Object.create(Vn.prototype), dp.prototype.constructor = dp, dp.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, dp.prototype.update = function() {
        hp.setFromMatrixPosition(this.light.matrixWorld), pp.setFromMatrixPosition(this.light.target.matrixWorld), fp.subVectors(pp, hp), this.lightPlane.lookAt(pp), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(pp), this.targetLine.scale.z = fp.length()
    };
    const mp = new yn,
        gp = new Hr;

    function vp(t) {
        const e = new ur,
            n = new Fa({
                color: 16777215,
                vertexColors: !0,
                toneMapped: !1
            }),
            i = [],
            r = [],
            o = {},
            s = new Ni(16755200),
            a = new Ni(16711680),
            c = new Ni(43775),
            l = new Ni(16777215),
            u = new Ni(3355443);

        function h(t, e, n) {
            p(t, n), p(e, n)
        }

        function p(t, e) {
            i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1)
        }
        h("n1", "n2", s), h("n2", "n4", s), h("n4", "n3", s), h("n3", "n1", s), h("f1", "f2", s), h("f2", "f4", s), h("f4", "f3", s), h("f3", "f1", s), h("n1", "f1", s), h("n2", "f2", s), h("n3", "f3", s), h("n4", "f4", s), h("p", "n1", a), h("p", "n2", a), h("p", "n3", a), h("p", "n4", a), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", l), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), e.setAttribute("position", new Qi(i, 3)), e.setAttribute("color", new Qi(r, 3)), Ya.call(this, e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }

    function yp(t, e, n, i, r, o, s) {
        mp.set(r, o, s).unproject(i);
        const a = e[t];
        if (void 0 !== a) {
            const t = n.getAttribute("position");
            for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], mp.x, mp.y, mp.z)
        }
    }
    vp.prototype = Object.create(Ya.prototype), vp.prototype.constructor = vp, vp.prototype.update = function() {
        const t = this.geometry,
            e = this.pointMap;
        gp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), yp("c", e, t, gp, 0, 0, -1), yp("t", e, t, gp, 0, 0, 1), yp("n1", e, t, gp, -1, -1, -1), yp("n2", e, t, gp, 1, -1, -1), yp("n3", e, t, gp, -1, 1, -1), yp("n4", e, t, gp, 1, 1, -1), yp("f1", e, t, gp, -1, -1, 1), yp("f2", e, t, gp, 1, -1, 1), yp("f3", e, t, gp, -1, 1, 1), yp("f4", e, t, gp, 1, 1, 1), yp("u1", e, t, gp, .7, 1.1, -1), yp("u2", e, t, gp, -.7, 1.1, -1), yp("u3", e, t, gp, 0, 2, -1), yp("cf1", e, t, gp, -1, 0, 1), yp("cf2", e, t, gp, 1, 0, 1), yp("cf3", e, t, gp, 0, -1, 1), yp("cf4", e, t, gp, 0, 1, 1), yp("cn1", e, t, gp, -1, 0, -1), yp("cn2", e, t, gp, 1, 0, -1), yp("cn3", e, t, gp, 0, -1, -1), yp("cn4", e, t, gp, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
    };
    const bp = new oi;

    function xp(t, e) {
        this.object = t, void 0 === e && (e = 16776960);
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new Float32Array(24),
            r = new ur;
        r.setIndex(new Wi(n, 1)), r.setAttribute("position", new Wi(i, 3)), Ya.call(this, r, new Fa({
            color: e,
            toneMapped: !1
        })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
    }

    function wp(t, e) {
        this.type = "Box3Helper", this.box = t, e = e || 16776960;
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new ur;
        i.setIndex(new Wi(n, 1)), i.setAttribute("position", new Qi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ya.call(this, i, new Fa({
            color: e,
            toneMapped: !1
        })), this.type = "Box3Helper", this.geometry.computeBoundingSphere()
    }

    function _p(t, e, n) {
        this.plane = t, this.size = void 0 === e ? 1 : e;
        const i = void 0 !== n ? n : 16776960,
            r = new ur;
        r.setAttribute("position", new Qi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), qa.call(this, r, new Fa({
            color: i,
            toneMapped: !1
        })), this.type = "PlaneHelper";
        const o = new ur;
        o.setAttribute("position", new Qi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Ar(o, new Hi({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    xp.prototype = Object.create(Ya.prototype), xp.prototype.constructor = xp, xp.prototype.update = function(t) {
        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && bp.setFromObject(this.object), bp.isEmpty()) return;
        const e = bp.min,
            n = bp.max,
            i = this.geometry.attributes.position,
            r = i.array;
        r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
    }, xp.prototype.setFromObject = function(t) {
        return this.object = t, this.update(), this
    }, xp.prototype.copy = function(t) {
        return Ya.prototype.copy.call(this, t), this.object = t.object, this
    }, xp.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, wp.prototype = Object.create(Ya.prototype), wp.prototype.constructor = wp, wp.prototype.updateMatrixWorld = function(t) {
        const e = this.box;
        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Vn.prototype.updateMatrixWorld.call(this, t))
    }, _p.prototype = Object.create(qa.prototype), _p.prototype.constructor = _p, _p.prototype.updateMatrixWorld = function(t) {
        let e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? 1 : 0, this.lookAt(this.plane.normal), Vn.prototype.updateMatrixWorld.call(this, t)
    };
    const Mp = new yn;
    let Sp, Tp;

    function Ep(t, e, n, i, r, o) {
        Vn.call(this), this.type = "ArrowHelper", void 0 === t && (t = new yn(0, 0, 1)), void 0 === e && (e = new yn(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === Sp && (Sp = new ur, Sp.setAttribute("position", new Qi([0, 0, 0, 0, 1, 0], 3)), Tp = new yl(0, .5, 1, 5, 1), Tp.translate(0, -.5, 0)), this.position.copy(e), this.line = new qa(Sp, new Fa({
            color: i,
            toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ar(Tp, new Hi({
            color: i,
            toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o)
    }

    function Cp(t) {
        const e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            n = new ur;
        n.setAttribute("position", new Qi(e, 3)), n.setAttribute("color", new Qi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        const i = new Fa({
            vertexColors: !0,
            toneMapped: !1
        });
        Ya.call(this, n, i), this.type = "AxesHelper"
    }
    Ep.prototype = Object.create(Vn.prototype), Ep.prototype.constructor = Ep, Ep.prototype.setDirection = function(t) {
        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            Mp.set(t.z, 0, -t.x).normalize();
            const e = Math.acos(t.y);
            this.quaternion.setFromAxisAngle(Mp, e)
        }
    }, Ep.prototype.setLength = function(t, e, n) {
        void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
    }, Ep.prototype.setColor = function(t) {
        this.line.material.color.set(t), this.cone.material.color.set(t)
    }, Ep.prototype.copy = function(t) {
        return Vn.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
    }, Ep.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, Cp.prototype = Object.create(Ya.prototype), Cp.prototype.constructor = Cp;
    const Ap = Math.pow(2, 8),
        Lp = [.125, .215, .35, .446, .526, .582],
        Pp = 5 + Lp.length,
        Op = {
            3e3: 0,
            3001: 1,
            3002: 2,
            3004: 3,
            3005: 4,
            3006: 5,
            3007: 6
        },
        Rp = new Bu,
        {
            _lodPlanes: Ip,
            _sizeLods: Dp,
            _sigmas: Np
        } = function() {
            const t = [],
                e = [],
                n = [];
            let i = 8;
            for (let r = 0; r < Pp; r++) {
                const o = Math.pow(2, i);
                e.push(o);
                let s = 1 / o;
                r > 4 ? s = Lp[r - 8 + 4 - 1] : 0 == r && (s = 0), n.push(s);
                const a = 1 / (o - 1),
                    c = -a / 2,
                    l = 1 + a / 2,
                    u = [c, c, l, c, l, l, c, c, l, l, c, l],
                    h = 6,
                    p = 6,
                    f = 3,
                    d = 2,
                    m = 1,
                    g = new Float32Array(f * p * h),
                    v = new Float32Array(d * p * h),
                    y = new Float32Array(m * p * h);
                for (let t = 0; t < h; t++) {
                    const e = t % 3 * 2 / 3 - 1,
                        n = t > 2 ? 0 : -1,
                        i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    g.set(i, f * p * t), v.set(u, d * p * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, m * p * t)
                }
                const b = new ur;
                b.setAttribute("position", new Wi(g, f)), b.setAttribute("uv", new Wi(v, d)), b.setAttribute("faceIndex", new Wi(y, m)), t.push(b), i > 4 && i--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }();
    let kp = null;
    const Up = (1 + Math.sqrt(5)) / 2,
        Bp = 1 / Up,
        zp = [new yn(1, 1, 1), new yn(-1, 1, 1), new yn(1, 1, -1), new yn(-1, 1, -1), new yn(0, Up, Bp), new yn(0, Up, -Bp), new yn(Bp, 0, Up), new yn(-Bp, 0, Up), new yn(Up, Bp, 0), new yn(-Up, Bp, 0)];

    function Fp(t) {
        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
            const e = new Float32Array(t),
                n = new yn(0, 1, 0);
            return new Tl({
                name: "SphericalGaussianBlur",
                defines: {
                    n: t
                },
                uniforms: {
                    envMap: {
                        value: null
                    },
                    samples: {
                        value: 1
                    },
                    weights: {
                        value: e
                    },
                    latitudinal: {
                        value: !1
                    },
                    dTheta: {
                        value: 0
                    },
                    mipInt: {
                        value: 0
                    },
                    poleAxis: {
                        value: n
                    },
                    inputEncoding: {
                        value: Op[3e3]
                    },
                    outputEncoding: {
                        value: Op[3e3]
                    }
                },
                vertexShader: qp(),
                fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${Xp()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
    }

    function jp(t) {
        return void 0 !== t && 1009 === t.type && (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding)
    }

    function Hp(t) {
        const e = new fn(3 * Ap, 3 * Ap, t);
        return e.texture.mapping = 306, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
    }

    function Gp(t, e, n, i, r) {
        t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
    }

    function Vp() {
        return new Tl({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                texelSize: {
                    value: new sn(1, 1)
                },
                inputEncoding: {
                    value: Op[3e3]
                },
                outputEncoding: {
                    value: Op[3e3]
                }
            },
            vertexShader: qp(),
            fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${Xp()}\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function Wp() {
        return new Tl({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                inputEncoding: {
                    value: Op[3e3]
                },
                outputEncoding: {
                    value: Op[3e3]
                }
            },
            vertexShader: qp(),
            fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${Xp()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function qp() {
        return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t"
    }

    function Xp() {
        return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t"
    }
    Fp.prototype = {
        constructor: Fp,
        fromScene: function(t, e = 0, n = .1, i = 100) {
            kp = this._renderer.getRenderTarget();
            const r = this._allocateTargets();
            return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
        },
        fromEquirectangular: function(t) {
            return this._fromTexture(t)
        },
        fromCubemap: function(t) {
            return this._fromTexture(t)
        },
        compileCubemapShader: function() {
            null === this._cubemapShader && (this._cubemapShader = Wp(), this._compileMaterial(this._cubemapShader))
        },
        compileEquirectangularShader: function() {
            null === this._equirectShader && (this._equirectShader = Vp(), this._compileMaterial(this._equirectShader))
        },
        dispose: function() {
            this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
            for (let t = 0; t < Ip.length; t++) Ip[t].dispose()
        },
        _cleanup: function(t) {
            this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(kp), t.scissorTest = !1, Gp(t, 0, 0, t.width, t.height)
        },
        _fromTexture: function(t) {
            kp = this._renderer.getRenderTarget();
            const e = this._allocateTargets(t);
            return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
        },
        _allocateTargets: function(t) {
            const e = {
                    magFilter: 1003,
                    minFilter: 1003,
                    generateMipmaps: !1,
                    type: 1009,
                    format: 1023,
                    encoding: jp(t) ? t.encoding : 3002,
                    depthBuffer: !1,
                    stencilBuffer: !1
                },
                n = Hp(e);
            return n.depthBuffer = !t, this._pingPongRenderTarget = Hp(e), n
        },
        _compileMaterial: function(t) {
            const e = new Ar(Ip[0], t);
            this._renderer.compile(e, Rp)
        },
        _sceneToCubeUV: function(t, e, n, i) {
            const r = new Gr(90, 1, e, n),
                o = [1, -1, 1, 1, 1, 1],
                s = [1, 1, 1, -1, -1, -1],
                a = this._renderer,
                c = a.outputEncoding,
                l = a.toneMapping,
                u = a.getClearColor(),
                h = a.getClearAlpha();
            a.toneMapping = 0, a.outputEncoding = 3e3;
            let p = t.background;
            if (p && p.isColor) {
                p.convertSRGBToLinear();
                const e = Math.max(p.r, p.g, p.b),
                    n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
                p = p.multiplyScalar(Math.pow(2, -n));
                const i = (n + 128) / 255;
                a.setClearColor(p, i), t.background = null
            }
            for (let e = 0; e < 6; e++) {
                const n = e % 3;
                0 == n ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])), Gp(i, n * Ap, e > 2 ? Ap : 0, Ap, Ap), a.setRenderTarget(i), a.render(t, r)
            }
            a.toneMapping = l, a.outputEncoding = c, a.setClearColor(u, h)
        },
        _textureToCubeUV: function(t, e) {
            const n = this._renderer;
            t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Wp()) : null == this._equirectShader && (this._equirectShader = Vp());
            const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                r = new Ar(Ip[0], i),
                o = i.uniforms;
            o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = Op[t.encoding], o.outputEncoding.value = Op[e.texture.encoding], Gp(e, 0, 0, 3 * Ap, 2 * Ap), n.setRenderTarget(e), n.render(r, Rp)
        },
        _applyPMREM: function(t) {
            const e = this._renderer,
                n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < Pp; e++) {
                const n = Math.sqrt(Np[e] * Np[e] - Np[e - 1] * Np[e - 1]),
                    i = zp[(e - 1) % zp.length];
                this._blur(t, e - 1, e, n, i)
            }
            e.autoClear = n
        },
        _blur: function(t, e, n, i, r) {
            const o = this._pingPongRenderTarget;
            this._halfBlur(t, o, e, n, i, "latitudinal", r), this._halfBlur(o, t, n, n, i, "longitudinal", r)
        },
        _halfBlur: function(t, e, n, i, r, o, s) {
            const a = this._renderer,
                c = this._blurMaterial;
            "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
            const l = new Ar(Ip[i], c),
                u = c.uniforms,
                h = Dp[n] - 1,
                p = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                f = r / p,
                d = isFinite(r) ? 1 + Math.floor(3 * f) : 20;
            d > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${d} samples when the maximum is set to 20`);
            const m = [];
            let g = 0;
            for (let t = 0; t < 20; ++t) {
                const e = t / f,
                    n = Math.exp(-e * e / 2);
                m.push(n), 0 == t ? g += n : t < d && (g += 2 * n)
            }
            for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
            u.envMap.value = t.texture, u.samples.value = d, u.weights.value = m, u.latitudinal.value = "latitudinal" === o, s && (u.poleAxis.value = s), u.dTheta.value = p, u.mipInt.value = 8 - n, u.inputEncoding.value = Op[t.texture.encoding], u.outputEncoding.value = Op[t.texture.encoding];
            const v = Dp[i];
            Gp(e, 3 * Math.max(0, Ap - 2 * v), (0 === i ? 0 : 2 * Ap) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(l, Rp)
        }
    };

    function Zp(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), gu.call(this, t), this.type = "catmullrom"
    }
    cu.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(cu.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, Object.assign(Au.prototype, {
        createPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            const e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            const e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            const e = new Nr;
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.vertices.push(new yn(i.x, i.y, i.z || 0))
            }
            return e
        }
    }), Object.assign(Lu.prototype, {
        fromPoints: function(t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }
    }), Object.create(gu.prototype), Object.create(gu.prototype), Zp.prototype = Object.create(gu.prototype), Object.assign(Zp.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), lp.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, ip.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(Ql.prototype, {
        extractUrlBase: function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Xu(t)
        }
    }), Ql.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    }, Object.assign(Ku.prototype, {
        setTexturePath: function(t) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
        }
    }), Object.assign(Xh.prototype, {
        center: function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        size: function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(oi.prototype, {
        center: function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        },
        size: function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(ci.prototype, {
        empty: function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }
    }), Yr.prototype.setFromMatrix = function(t) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
    }, $h.prototype.center = function(t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, Object.assign(on, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), on.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), on.ceilPowerOfTwo(t)
        }
    }), Object.assign(an.prototype, {
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBufferAttribute: function(t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(En.prototype, {
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        getPosition: function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new yn).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBufferAttribute: function(t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(t, e, n, i, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o)
        }
    }), xi.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
    }, mn.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
    }, Object.assign(gi.prototype, {
        isIntersectionBox: function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }
    }), Object.assign(Oi.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        },
        midpoint: function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        },
        normal: function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        },
        plane: function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }
    }), Object.assign(Oi, {
        barycoordFromPoint: function(t, e, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Oi.getBarycoord(t, e, n, i, r)
        },
        normal: function(t, e, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Oi.getNormal(t, e, n, i)
        }
    }), Object.assign(Pu.prototype, {
        extractAllPoints: function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        },
        extrude: function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new el(this, t)
        },
        makeGeometry: function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new fl(this, t)
        }
    }), Object.assign(sn.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(yn.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(pn.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Nr.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        },
        applyMatrix: function(t) {
            return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }
    }), Object.assign(Vn.prototype, {
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        },
        applyMatrix: function(t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }
    }), Object.defineProperties(Vn.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.assign(Ar.prototype, {
        setDrawMode: function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }), Object.defineProperties(Ar.prototype, {
        drawMode: {
            get: function() {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
            },
            set: function() {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }), Object.defineProperties(La.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Ia.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Pa.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(cu.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
        }
    }), Gr.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
    }, Object.defineProperties(Ou.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
            }
        }
    }), Object.defineProperties(Wi.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage
            },
            set: function() {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048)
            }
        }
    }), Object.assign(Wi.prototype, {
        setDynamic: function(t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(ur.prototype, {
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        },
        addAttribute: function(t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Wi(arguments[1], arguments[2])))
        },
        addDrawCall: function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        },
        removeAttribute: function(t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
        },
        applyMatrix: function(t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }
    }), Object.defineProperties(ur.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(Zu.prototype, {
        maxInstancedCount: {
            get: function() {
                return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount
            },
            set: function(t) {
                console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t
            }
        }
    }), Object.defineProperties(Hh.prototype, {
        linePrecision: {
            get: function() {
                return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
            },
            set: function(t) {
                console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t
            }
        }
    }), Object.defineProperties(ca.prototype, {
        dynamic: {
            get: function() {
                return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage
            },
            set: function(t) {
                console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t)
            }
        }
    }), Object.assign(ca.prototype, {
        setDynamic: function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this
        },
        setArray: function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(nl.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Fh.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(ji.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new Ni
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
            }
        }
    }), Object.defineProperties(Al.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(jr.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
            }
        }
    }), Object.assign(ra.prototype, {
        clearTarget: function(t, e, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
        },
        animate: function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }
    }), Object.defineProperties(ra.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? 3001 : 3e3
            }
        },
        toneMappingWhitePoint: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
            }
        }
    }), Object.defineProperties(Ys.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(fn.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
            }
        }
    }), Object.defineProperties(xh.prototype, {
        load: {
            value: function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                const e = this;
                return (new lh).load(t, (function(t) {
                    e.setBuffer(t)
                })), this
            }
        },
        startTime: {
            set: function() {
                console.warn("THREE.Audio: .startTime is now .play( delay ).")
            }
        }
    }), Eh.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, Vr.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
    };
    ln.crossOrigin = void 0, ln.loadTexture = function(t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const r = new au;
        r.setCrossOrigin(this.crossOrigin);
        const o = r.load(t, n, void 0, i);
        return e && (o.mapping = e), o
    }, ln.loadTextureCube = function(t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const r = new su;
        r.setCrossOrigin(this.crossOrigin);
        const o = r.load(t, n, void 0, i);
        return e && (o.mapping = e), o
    }, ln.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, ln.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    };
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: "118"
        }
    }));
    var Yp = function(t, e) {
        var n, i, r, o, s;
        void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.emitter = Object(a.default)(), this.enabled = !0, this.target = new yn, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        }, this.mouseButtons = {
            LEFT: Ye,
            MIDDLE: $e,
            RIGHT: Je
        }, this.touches = {
            ONE: Ke,
            TWO: tn
        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.thetaAddon = 0, this.phiAddon = 0, this.getPolarAngle = function() {
            return m.phi
        }, this.getAzimuthalAngle = function() {
            return m.theta
        }, this.setPolarAngle = function(t) {
            m.phi = t, this.update(!0)
        }, this.setAzimuthalAngle = function(t) {
            var e = m.theta;
            m.theta = t, this.emitter.emit("rotate", {
                x: t - e,
                y: 0
            }), this.update(!0)
        }, this.saveState = function() {
            c.target0.copy(c.target), c.position0.copy(c.object.position), c.zoom0 = c.object.zoom
        }, this.reset = function() {
            c.target.copy(c.target0), c.object.position.copy(c.position0), c.object.zoom = c.zoom0, c.object.updateProjectionMatrix(), c.dispatchEvent(l), c.update(), f = p.NONE
        }, this.update = (n = new yn, i = (new mn).setFromUnitVectors(t.up, new yn(0, 1, 0)), r = i.clone().inverse(), o = new yn, s = new mn, function(t) {
            var e = c.object.position;
            return n.copy(e).sub(c.target), n.applyQuaternion(i), t || m.setFromVector3(n), c.autoRotate && f === p.NONE && P(2 * Math.PI / 60 / 60 * c.autoRotateSpeed), c.enableDamping ? (m.theta += g.theta * c.dampingFactor, m.phi += g.phi * c.dampingFactor) : (m.theta += g.theta, m.phi += g.phi), m.theta += c.thetaAddon, m.phi += c.phiAddon, m.theta = Math.max(c.minAzimuthAngle, Math.min(c.maxAzimuthAngle, m.theta)), m.phi = Math.max(c.minPolarAngle, Math.min(c.maxPolarAngle, m.phi)), m.makeSafe(), m.radius *= v, m.radius = Math.max(c.minDistance, Math.min(c.maxDistance, m.radius)), !0 === c.enableDamping ? c.target.addScaledVector(y, c.dampingFactor) : c.target.add(y), n.setFromSpherical(m), n.applyQuaternion(r), e.copy(c.target).add(n), c.object.lookAt(c.target), !0 === c.enableDamping ? (g.theta *= 1 - c.dampingFactor, g.phi *= 1 - c.dampingFactor, y.multiplyScalar(1 - c.dampingFactor)) : (g.set(0, 0, 0), y.set(0, 0, 0)), v = 1, c.emitter.emit("update", m.phi, m.theta), !!(b || o.distanceToSquared(c.object.position) > d || 8 * (1 - s.dot(c.object.quaternion)) > d) && (c.dispatchEvent(l), o.copy(c.object.position), s.copy(c.object.quaternion), b = !1, !0)
        }), this.dispose = function() {
            c.domElement.removeEventListener("contextmenu", tt, !1), c.domElement.removeEventListener("mousedown", q, !1), c.domElement.removeEventListener("wheel", Y, !1), c.domElement.removeEventListener("touchstart", J, !1), c.domElement.removeEventListener("touchend", Q, !1), c.domElement.removeEventListener("touchmove", K, !1), document.removeEventListener("mousemove", X, !1), document.removeEventListener("mouseup", Z, !1), c.domElement.removeEventListener("keydown", $, !1)
        };
        var c = this,
            l = {
                type: "change"
            },
            u = {
                type: "start"
            },
            h = {
                type: "end"
            },
            p = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            },
            f = p.NONE,
            d = 1e-6,
            m = new Wh,
            g = new Wh,
            v = 1,
            y = new yn,
            b = !1,
            x = new sn,
            w = new sn,
            _ = new sn,
            M = new sn,
            S = new sn,
            T = new sn,
            E = new sn,
            C = new sn,
            A = new sn;

        function L() {
            return Math.pow(.95, c.zoomSpeed)
        }

        function P(t) {
            g.theta -= t
        }

        function O(t) {
            g.phi -= t
        }
        var R, I = (R = new yn, function(t, e) {
                R.setFromMatrixColumn(e, 0), R.multiplyScalar(-t), y.add(R)
            }),
            D = function() {
                var t = new yn;
                return function(e, n) {
                    !0 === c.screenSpacePanning ? t.setFromMatrixColumn(n, 1) : (t.setFromMatrixColumn(n, 0), t.crossVectors(c.object.up, t)), t.multiplyScalar(e), y.add(t)
                }
            }(),
            N = function() {
                var t = new yn;
                return function(e, n) {
                    var i = c.domElement;
                    if (c.object.isPerspectiveCamera) {
                        var r = c.object.position;
                        t.copy(r).sub(c.target);
                        var o = t.length();
                        o *= Math.tan(c.object.fov / 2 * Math.PI / 180), I(2 * e * o / i.clientHeight, c.object.matrix), D(2 * n * o / i.clientHeight, c.object.matrix)
                    } else c.object.isOrthographicCamera ? (I(e * (c.object.right - c.object.left) / c.object.zoom / i.clientWidth, c.object.matrix), D(n * (c.object.top - c.object.bottom) / c.object.zoom / i.clientHeight, c.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), c.enablePan = !1)
                }
            }();

        function k(t) {
            c.object.isPerspectiveCamera ? v /= t : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom * t)), c.object.updateProjectionMatrix(), b = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1)
        }

        function U(t) {
            c.object.isPerspectiveCamera ? v *= t : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom / t)), c.object.updateProjectionMatrix(), b = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1)
        }

        function B(t) {
            x.set(t.clientX, t.clientY)
        }

        function z(t) {
            M.set(t.clientX, t.clientY)
        }

        function F(t) {
            if (1 == t.touches.length) x.set(t.touches[0].pageX, t.touches[0].pageY);
            else {
                var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                    n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                x.set(e, n)
            }
        }

        function j(t) {
            if (1 == t.touches.length) M.set(t.touches[0].pageX, t.touches[0].pageY);
            else {
                var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                    n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                M.set(e, n)
            }
        }

        function H(t) {
            var e = t.touches[0].pageX - t.touches[1].pageX,
                n = t.touches[0].pageY - t.touches[1].pageY,
                i = Math.sqrt(e * e + n * n);
            E.set(0, i)
        }

        function G(t) {
            if (1 == t.touches.length) w.set(t.touches[0].pageX, t.touches[0].pageY);
            else {
                var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                    n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                w.set(e, n)
            }
            _.subVectors(w, x).multiplyScalar(c.rotateSpeed);
            var i = c.domElement;
            P(2 * Math.PI * _.x / i.clientHeight), O(2 * Math.PI * _.y / i.clientHeight), x.copy(w)
        }

        function V(t) {
            if (1 == t.touches.length) S.set(t.touches[0].pageX, t.touches[0].pageY);
            else {
                var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                    n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                S.set(e, n)
            }
            T.subVectors(S, M).multiplyScalar(c.panSpeed), N(T.x, T.y), M.copy(S)
        }

        function W(t) {
            var e = t.touches[0].pageX - t.touches[1].pageX,
                n = t.touches[0].pageY - t.touches[1].pageY,
                i = Math.sqrt(e * e + n * n);
            C.set(0, i), A.set(0, Math.pow(C.y / E.y, c.zoomSpeed)), k(A.y), E.copy(C)
        }

        function q(t) {
            if (!1 !== c.enabled) {
                var e;
                switch (t.preventDefault(), c.domElement.focus ? c.domElement.focus() : window.focus(), t.button) {
                    case 0:
                        e = c.mouseButtons.LEFT;
                        break;
                    case 1:
                        e = c.mouseButtons.MIDDLE;
                        break;
                    case 2:
                        e = c.mouseButtons.RIGHT;
                        break;
                    default:
                        e = -1
                }
                switch (e) {
                    case $e:
                        if (!1 === c.enableZoom) return;
                        ! function(t) {
                            E.set(t.clientX, t.clientY)
                        }(t), f = p.DOLLY;
                        break;
                    case Ye:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === c.enablePan) return;
                            z(t), f = p.PAN
                        } else {
                            if (!1 === c.enableRotate) return;
                            B(t), f = p.ROTATE
                        }
                        break;
                    case Je:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === c.enableRotate) return;
                            B(t), f = p.ROTATE
                        } else {
                            if (!1 === c.enablePan) return;
                            z(t), f = p.PAN
                        }
                        break;
                    default:
                        f = p.NONE
                }
                f !== p.NONE && (document.addEventListener("mousemove", X, !1), document.addEventListener("mouseup", Z, !1), c.dispatchEvent(u))
            }
        }

        function X(t) {
            if (!1 !== c.enabled) switch (t.preventDefault(), f) {
                case p.ROTATE:
                    if (!1 === c.enableRotate) return;
                    ! function(t) {
                        w.set(t.clientX, t.clientY), _.subVectors(w, x).multiplyScalar(c.rotateSpeed);
                        var e = c.domElement;
                        P(2 * Math.PI * _.x / e.clientHeight), O(2 * Math.PI * _.y / e.clientHeight), x.copy(w), c.emitter.emit("rotate", _), c.update()
                    }(t);
                    break;
                case p.DOLLY:
                    if (!1 === c.enableZoom) return;
                    ! function(t) {
                        C.set(t.clientX, t.clientY), A.subVectors(C, E), A.y > 0 ? k(L()) : A.y < 0 && U(L()), E.copy(C), c.update()
                    }(t);
                    break;
                case p.PAN:
                    if (!1 === c.enablePan) return;
                    ! function(t) {
                        S.set(t.clientX, t.clientY), T.subVectors(S, M).multiplyScalar(c.panSpeed), N(T.x, T.y), M.copy(S), c.update()
                    }(t)
            }
        }

        function Z(t) {
            !1 !== c.enabled && (document.removeEventListener("mousemove", X, !1), document.removeEventListener("mouseup", Z, !1), c.dispatchEvent(h), f = p.NONE)
        }

        function Y(t) {
            !1 === c.enabled || !1 === c.enableZoom || f !== p.NONE && f !== p.ROTATE || (t.preventDefault(), t.stopPropagation(), c.dispatchEvent(u), function(t) {
                t.deltaY < 0 ? U(L()) : t.deltaY > 0 && k(L()), c.update()
            }(t), c.dispatchEvent(h))
        }

        function $(t) {
            !1 !== c.enabled && !1 !== c.enableKeys && !1 !== c.enablePan && function(t) {
                var e = !1;
                switch (t.keyCode) {
                    case c.keys.UP:
                        N(0, c.keyPanSpeed), e = !0;
                        break;
                    case c.keys.BOTTOM:
                        N(0, -c.keyPanSpeed), e = !0;
                        break;
                    case c.keys.LEFT:
                        N(c.keyPanSpeed, 0), e = !0;
                        break;
                    case c.keys.RIGHT:
                        N(-c.keyPanSpeed, 0), e = !0
                }
                e && (t.preventDefault(), c.update())
            }(t)
        }

        function J(t) {
            if (!1 !== c.enabled) {
                switch (t.preventDefault(), t.touches.length) {
                    case 1:
                        switch (c.touches.ONE) {
                            case Ke:
                                if (!1 === c.enableRotate) return;
                                F(t), f = p.TOUCH_ROTATE;
                                break;
                            case Qe:
                                if (!1 === c.enablePan) return;
                                j(t), f = p.TOUCH_PAN;
                                break;
                            default:
                                f = p.NONE
                        }
                        break;
                    case 2:
                        switch (c.touches.TWO) {
                            case tn:
                                if (!1 === c.enableZoom && !1 === c.enablePan) return;
                                ! function(t) {
                                    c.enableZoom && H(t), c.enablePan && j(t)
                                }(t), f = p.TOUCH_DOLLY_PAN;
                                break;
                            case en:
                                if (!1 === c.enableZoom && !1 === c.enableRotate) return;
                                ! function(t) {
                                    c.enableZoom && H(t), c.enableRotate && F(t)
                                }(t), f = p.TOUCH_DOLLY_ROTATE;
                                break;
                            default:
                                f = p.NONE
                        }
                        break;
                    default:
                        f = p.NONE
                }
                f !== p.NONE && c.dispatchEvent(u)
            }
        }

        function K(t) {
            if (!1 !== c.enabled) switch (t.preventDefault(), t.stopPropagation(), f) {
                case p.TOUCH_ROTATE:
                    if (!1 === c.enableRotate) return;
                    G(t), c.update();
                    break;
                case p.TOUCH_PAN:
                    if (!1 === c.enablePan) return;
                    V(t), c.update();
                    break;
                case p.TOUCH_DOLLY_PAN:
                    if (!1 === c.enableZoom && !1 === c.enablePan) return;
                    ! function(t) {
                        c.enableZoom && W(t), c.enablePan && V(t)
                    }(t), c.update();
                    break;
                case p.TOUCH_DOLLY_ROTATE:
                    if (!1 === c.enableZoom && !1 === c.enableRotate) return;
                    ! function(t) {
                        c.enableZoom && W(t), c.enableRotate && G(t)
                    }(t), c.update();
                    break;
                default:
                    f = p.NONE
            }
        }

        function Q(t) {
            !1 !== c.enabled && (c.dispatchEvent(h), f = p.NONE)
        }

        function tt(t) {
            !1 !== c.enabled && t.preventDefault()
        }
        c.domElement.addEventListener("contextmenu", tt, !1), c.domElement.addEventListener("mousedown", q, !1), c.domElement.addEventListener("wheel", Y, !1), c.domElement.addEventListener("touchstart", J, !1), c.domElement.addEventListener("touchend", Q, !1), c.domElement.addEventListener("touchmove", K, !1), c.domElement.addEventListener("keydown", $, !1), -1 === c.domElement.tabIndex && (c.domElement.tabIndex = 0), this.update()
    };
    (Yp.prototype = Object.create(nn.prototype)).constructor = Yp;
    var $p = function(t, e) {
        Yp.call(this, t, e), this.mouseButtons.LEFT = Je, this.mouseButtons.RIGHT = Ye, this.touches.ONE = Qe, this.touches.TWO = en
    };

    function Jp(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }($p.prototype = Object.create(nn.prototype)).constructor = $p;
    var Kp = new(function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t)
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function(t, e) {
                    this.camera = t, this.onMouseMove = this.onMouseMove.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onMouseUp = this.onMouseUp.bind(this), this.enable = this.enable.bind(this), this.disable = this.disable.bind(this), this.startTransition = this.startTransition.bind(this), this.endTransition = this.endTransition.bind(this), this.orbit = new Yp(t, e), this.orbit.enableDamping = !0, this.orbit.enableZoom = !1, this.orbit.rotateSpeed = -.2, this.orbit.minPolarAngle = .4 * Math.PI, this.orbit.maxPolarAngle = .6 * Math.PI, window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mousedown", this.onMouseDown), window.addEventListener("mouseup", this.onMouseUp), this.deltaX = 0, this.deltaVelX = 0, this.deltaY = 0, this.deltaVelY = 0, this._isEnabled = !0, this.defaultFOV = 65, this.destFOV = this.defaultFOV
                }
            }, {
                key: "setFOV",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultFOV;
                    this.destFOV = t, this.camera.fov = t, this.camera.updateProjectionMatrix()
                }
            }, {
                key: "enable",
                value: function() {
                    this._isEnabled = !0, this.orbit.enabled = !0
                }
            }, {
                key: "disable",
                value: function() {
                    this._isEnabled = !1, this.orbit.enabled = !1
                }
            }, {
                key: "startTransition",
                value: function() {
                    this._isTransitionning = !0
                }
            }, {
                key: "endTransition",
                value: function() {
                    this._isTransitionning = !1
                }
            }, {
                key: "isTransitionning",
                value: function() {
                    return this._isTransitionning
                }
            }, {
                key: "onMouseDown",
                value: function() {
                    this.isDragging = !0
                }
            }, {
                key: "onMouseUp",
                value: function() {
                    this.isDragging = !1
                }
            }, {
                key: "onMouseMove",
                value: function(t) {
                    this._isEnabled && (t.clientX < 100 ? this.onLeftScreen() : t.clientX > window.innerWidth - 100 ? this.onRightScreen() : (this.isOnLeftScreen = !1, this.isOnRightScreen = !1), t.clientY < 100 ? this.onTopScreen() : t.clientY > window.innerHeight - 100 ? this.onBottomScreen() : (this.isOnBottomScreen = !1, this.isOnTopScreen = !1))
                }
            }, {
                key: "onRightScreen",
                value: function() {
                    this.isOnRightScreen || (this.isOnLeftScreen = !1, this.isOnRightScreen = !0, this.isDragging || (this.deltaVelX = -.002))
                }
            }, {
                key: "onLeftScreen",
                value: function() {
                    this.isOnLeftScreen || (this.isOnRightScreen = !1, this.isOnLeftScreen = !0, this.isDragging || (this.deltaVelX = .002))
                }
            }, {
                key: "onTopScreen",
                value: function() {
                    this.isOnTopScreen || (this.isOnBottomScreen = !1, this.isOnTopScreen = !0, this.isDragging || (this.deltaVelY = .002))
                }
            }, {
                key: "onBottomScreen",
                value: function() {
                    this.isOnBottomScreen || (this.isOnTopScreen = !1, this.isOnBottomScreen = !0, this.isDragging || (this.deltaVelY = -.002))
                }
            }, {
                key: "update",
                value: function() {
                    this._isEnabled && (this.deltaX += this.deltaVelX, this.deltaY += this.deltaVelY, this.orbit.thetaAddon += .01 * (this.deltaX - this.orbit.thetaAddon), this.orbit.phiAddon += .01 * (this.deltaY - this.orbit.phiAddon), this.deltaVelX *= .8, this.deltaX *= .9, this.deltaVelY *= .8, this.deltaY *= .9, this.orbit && this.orbit.update())
                }
            }, {
                key: "enterRoom",
                value: function() {
                    var t = this;
                    return gsap.fromTo(this.camera, {
                        fov: 90
                    }, {
                        fov: this.destFOV,
                        duration: 1,
                        ease: "expo.out",
                        onUpdate: function() {
                            t.camera.updateProjectionMatrix()
                        },
                        onComplete: function() {
                            t.orbit.enabled = !0
                        }
                    })
                }
            }, {
                key: "endAnimation",
                value: function() {
                    var t = this;
                    return gsap.fromTo(this.camera, {
                        fov: 120
                    }, {
                        fov: 40,
                        duration: 5,
                        ease: "none",
                        onUpdate: function() {
                            t.camera.updateProjectionMatrix()
                        }
                    })
                }
            }, {
                key: "startAnimation",
                value: function() {
                    var t = gsap.timeline();
                    return t.fromTo(this, {
                        phi: .4 * Math.PI
                    }, {
                        phi: .5 * Math.PI,
                        duration: 1,
                        ease: "cubic.inOut"
                    }), t.fromTo(this, {
                        theta: 1
                    }, {
                        theta: 1.5,
                        duration: 2,
                        ease: "cubic.inOut"
                    }, "-=0.5"), t.to(this, {
                        theta: -.1,
                        duration: 4,
                        ease: "cubic.inOut"
                    }, "-=0.5"), t
                }
            }, {
                key: "lookAtTransition",
                value: function(t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .5,
                        i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
                    return this.theta - e > Math.PI ? e += 2 * Math.PI : this.theta - e < -Math.PI && (e -= 2 * Math.PI), gsap.to(this, {
                        phi: t,
                        theta: e,
                        duration: n,
                        ease: i
                    })
                }
            }, {
                key: "exitRoom",
                value: function() {
                    var t = this;
                    return this.orbit.enabled = !1, gsap.to(this.camera, {
                        fov: this.destFOV - 20,
                        duration: .8,
                        ease: "expo.in",
                        onUpdate: function() {
                            t.camera.updateProjectionMatrix()
                        }
                    })
                }
            }, {
                key: "phi",
                get: function() {
                    return this.orbit.getPolarAngle()
                },
                set: function(t) {
                    this.orbit.setPolarAngle(t)
                }
            }, {
                key: "theta",
                get: function() {
                    return this.orbit.getAzimuthalAngle()
                },
                set: function(t) {
                    this.orbit.setAzimuthalAngle(t)
                }
            }]) && Jp(e.prototype, n), i && Jp(e, i), t
        }()),
        Qp = n(5),
        tf = n.n(Qp),
        ef = {};
    window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, (function(t, e, n) {
        ef[e] = n
    }));
    var nf = Object(a.default)(),
        rf = !1;

    function of () {
        return rf
    }

    function sf() {
        Kp.isTransitionning() || (rf = !1, nf.emit("close"))
    }

    function af(t) {
        nf.on("open", t)
    }

    function cf(t) {
        nf.on("close", t)
    }
    var lf = tf.a.reduce((function(t, e) {
            return e.hints && (t = t.concat(e.hints)), t
        }), []),
        uf = lf.filter((function(t) {
            return !t.souvenir
        })),
        hf = lf.filter((function(t) {
            return t.souvenir
        })).length,
        pf = (uf.length, lf.length),
        ff = [],
        df = [],
        mf = [];

    function gf(t) {
        return ff.indexOf(t) > -1
    }

    function vf() {
        return {
            total: ff.length,
            hintFound: ff
        }
    }

    function yf() {
        return {
            total: df.length,
            tipFound: df
        }
    }

    function bf() {
        return mf.length === hf - 1
    }

    function xf() {
        return mf.length === hf
    }

    function wf(t) {
        nf.on("last", t)
    }
    var _f = Object(a.default)(),
        Mf = !1;

    function Sf() {
        return Mf
    }

    function Tf() {
        Kp.isTransitionning() || (Mf = !1, _f.emit("pause:end"))
    }

    function Ef(t) {
        _f.on("pause:start", t)
    }

    function Cf(t) {
        _f.on("pause:end", t)
    }

    function Af(t) {
        return (Af = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Lf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Pf(t, e) {
        return (Pf = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Of(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Df(t);
            if (e) {
                var r = Df(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Rf(this, n)
        }
    }

    function Rf(t, e) {
        return !e || "object" !== Af(e) && "function" != typeof e ? If(t) : e
    }

    function If(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Df(t) {
        return (Df = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Nf = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Pf(t, e)
        }(o, t);
        var e, n, i, r = Of(o);

        function o(t) {
            var e;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), (e = r.call(this, t)).transitionOut = e.transitionOut.bind(If(e)), e.pauseStart = e.pauseStart.bind(If(e)), e.pauseEnd = e.pauseEnd.bind(If(e)), e.$logoContent = e.$one(".Intro-logoContent"), Ef(e.pauseStart), Cf(e.pauseEnd), e
        }
        return e = o, (n = [{
            key: "recenter",
            value: function() {
                this.$el.style.transform = "translate(-50%, -50%)", this.$logoContent.style.display = "block"
            }
        }, {
            key: "pauseStart",
            value: function() {
                N(), document.querySelector(".Home").addEventListener("click", Tf)
            }
        }, {
            key: "pauseEnd",
            value: function() {
                k(), document.querySelector(".Home").removeEventListener("click", Tf)
            }
        }, {
            key: "transitionIn",
            value: function() {
                return this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.fromTo(this.$el, {
                    opacity: 0
                }, {
                    duration: 1,
                    opacity: 1
                }), this.tl
            }
        }, {
            key: "transitionOut",
            value: function() {
                return this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.to(this.$el, {
                    duration: 1,
                    opacity: 0
                }), this.tl
            }
        }]) && Lf(e.prototype, n), i && Lf(e, i), o
    }(s.a);

    function kf(t) {
        return (kf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Uf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Bf(t, e) {
        return (Bf = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function zf(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Hf(t);
            if (e) {
                var r = Hf(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Ff(this, n)
        }
    }

    function Ff(t, e) {
        return !e || "object" !== kf(e) && "function" != typeof e ? jf(t) : e
    }

    function jf(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Hf(t) {
        return (Hf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Gf = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Bf(t, e)
            }(o, t);
            var e, n, i, r = zf(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onButtonClick = e.onButtonClick.bind(jf(e)), e.link = e.$one("a"), e.link.addEventListener("click", e.onButtonClick), e
            }
            return e = o, (n = [{
                key: "onButtonClick",
                value: function(t) {
                    Oe("ButtonSitePromo", "Click", "Bouton site promo cliqu")
                }
            }]) && Uf(e.prototype, n), i && Uf(e, i), o
        }(s.a),
        Vf = n(9),
        Wf = n.n(Vf);

    function qf(t) {
        return (qf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Xf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Zf(t, e) {
        return (Zf = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Yf(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Kf(t);
            if (e) {
                var r = Kf(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return $f(this, n)
        }
    }

    function $f(t, e) {
        return !e || "object" !== qf(e) && "function" != typeof e ? Jf(t) : e
    }

    function Jf(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Kf(t) {
        return (Kf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Qf = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Zf(t, e)
            }(o, t);
            var e, n, i, r = Yf(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onLoad = e.onLoad.bind(Jf(e)), e.onPlay = e.onPlay.bind(Jf(e)), e.onMetadata = e.onMetadata.bind(Jf(e)), e.resize = e.resize.bind(Jf(e)), e.onVideoFinished = e.onVideoFinished.bind(Jf(e)), e.onStart = e.onStart.bind(Jf(e)), e.onTimeUpdate = e.onTimeUpdate.bind(Jf(e)), e.onCanPlay = e.onCanPlay.bind(Jf(e)), e.onButtonClick = e.onButtonClick.bind(Jf(e)), e.video = e.$one("video"), e.$logo = e.$one(".EndVideo-logo"), e.$outro = e.$one(".EndVideo-outro"), e.$outroPhrases = e.$all(".EndVideo-outro p, .EndVideo-outro-buttons"), e.$phrase1 = e.$all(".EndVideo-phrase--1 p"), e.$phrase2 = e.$all(".EndVideo-phrase--2 p"), e.$buttons = e.$all(".EndVideo-outro-buttons"), c.on("startend", e.onStart), c.on("loadvideoend", e.onLoad), c.on("playvideoend", e.onPlay), e.$buttons.forEach((function(t) {
                    t.addEventListener("click", e.onButtonClick)
                })), e.video.videoWidth ? e.onMetadata() : e.video.addEventListener("loadedmetadata", e.onMetadata), e
            }
            return e = o, (n = [{
                key: "onButtonClick",
                value: function(t) {
                    Oe("Downloads", "Click", t.target.getAttribute("data-dest"))
                }
            }, {
                key: "onMetadata",
                value: function() {
                    this.resize(), window.addEventListener("resize", this.resize)
                }
            }, {
                key: "onLoad",
                value: function() {
                    var t = this,
                        e = this.video.play();
                    e.then ? e.then((function() {
                        t.video.pause()
                    })) : this.video.pause()
                }
            }, {
                key: "resize",
                value: function() {
                    var t = Wf.a.contain({
                        w: this.video.videoWidth,
                        h: this.video.videoHeight
                    }, {
                        w: window.innerWidth,
                        h: window.innerHeight
                    });
                    this.video.style.top = t.top + "px", this.video.style.right = "0px", this.video.style.width = t.width + "px", this.video.style.height = t.height + "px"
                }
            }, {
                key: "onStart",
                value: function() {
                    var t = gsap.timeline();
                    t.fromTo(this.$el, {
                        display: "none",
                        opacity: 0
                    }, {
                        duration: 1,
                        display: "block",
                        opacity: 1
                    }, 0), t.fromTo(this.$phrase1, {
                        opacity: 0
                    }, {
                        duration: 2,
                        opacity: 1,
                        stagger: .2
                    }, 0), t.to(this.$phrase1, {
                        opacity: 0,
                        duration: .5,
                        stagger: .2
                    }, 4.5)
                }
            }, {
                key: "onPlay",
                value: function() {
                    gsap.timeline().fromTo(this.video, {
                        display: "none",
                        opacity: 0
                    }, {
                        duration: 1,
                        display: "block",
                        opacity: 1
                    }), this.video.play(), this.video.addEventListener("ended", this.onVideoFinished), this.video.addEventListener("timeupdate", this.onTimeUpdate), this.video.addEventListener("playing", this.onCanPlay)
                }
            }, {
                key: "onCanPlay",
                value: function() {
                    this.video.removeEventListener("playing", this.onCanPlay), gsap.fromTo(this.$phrase2, {
                        opacity: 0
                    }, {
                        duration: 1,
                        opacity: 1,
                        stagger: 1
                    }, 1)
                }
            }, {
                key: "onTimeUpdate",
                value: function() {
                    this.video.currentTime > 8 && !this.phrase2Hidden && this.onVideoFadeOut()
                }
            }, {
                key: "onVideoFadeOut",
                value: function() {
                    this.phrase2Hidden = !0, gsap.timeline().to(this.$phrase2, {
                        opacity: 0,
                        duration: 1
                    }, 0)
                }
            }, {
                key: "onVideoFinished",
                value: function() {
                    var t = gsap.timeline();
                    t.to(this.video, {
                        duration: 1,
                        opacity: 0
                    }, 0), t.fromTo(this.$outro, {
                        display: "none",
                        opacity: 0
                    }, {
                        duration: 1,
                        display: "block",
                        opacity: 1
                    }, 1), t.fromTo(this.$outroPhrases, {
                        opacity: 0
                    }, {
                        duration: 1,
                        opacity: 1,
                        stagger: 1.5
                    }, 1), Oe("Ending", "End", "Fin de la squence de fin")
                }
            }]) && Xf(e.prototype, n), i && Xf(e, i), o
        }(s.a),
        td = function(t) {
            Vn.call(this), this.element = t || document.createElement("div"), this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.addEventListener("removed", (function() {
                this.traverse((function(t) {
                    t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element)
                }))
            }))
        };
    td.prototype = Object.assign(Object.create(Vn.prototype), {
        constructor: td,
        copy: function(t, e) {
            return Vn.prototype.copy.call(this, t, e), this.element = t.element.cloneNode(!0), this
        }
    });
    var ed = function(t) {
        td.call(this, t)
    };
    (ed.prototype = Object.create(td.prototype)).constructor = ed;

    function nd(t) {
        return (nd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function id(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function rd(t, e) {
        return (rd = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function od(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = ad(t);
            if (e) {
                var r = ad(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return sd(this, n)
        }
    }

    function sd(t, e) {
        return !e || "object" !== nd(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function ad(t) {
        return (ad = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var cd = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && rd(t, e)
            }(o, t);
            var e, n, i, r = od(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).element.style.pointerEvents = "none", e.element.style.display = "none", e.visible = !1, e
            }
            return e = o, (n = [{
                key: "start",
                value: function(t) {
                    var e = this,
                        n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    this.position.x = 2e3 * parseFloat(this.element.getAttribute("data-x")), this.position.y = 2e3 * parseFloat(this.element.getAttribute("data-y")), this.position.z = 0, this.element.style.display = "block", this.visible = !0;
                    var r = 10;
                    this.tl && this.tl.kill(), this.tl = gsap.timeline({
                        onComplete: function() {
                            e.visible = !1, e.element.style.display = "none", t()
                        }
                    }), this.tl.fromTo(this.element, {
                        opacity: 0
                    }, {
                        opacity: 1,
                        duration: r
                    }, 0), this.tl.fromTo(this.position, {
                        z: -1e4
                    }, {
                        z: 0,
                        duration: r,
                        ease: "none"
                    }, 0), this.tl.to(this.element, {
                        opacity: 0,
                        duration: 1
                    }, r - 1), n && this.tl.progress(i / 3)
                }
            }, {
                key: "kill",
                value: function() {
                    this.tl && this.tl.kill(), this.visible = !1, this.element.style.display = "none"
                }
            }]) && id(e.prototype, n), i && id(e, i), o
        }(td),
        ld = document.getElementById("Css3d"),
        ud = new function() {
            var t, e, n, i, r = this,
                o = new En,
                s = {
                    camera: {
                        fov: 0,
                        style: ""
                    },
                    objects: new WeakMap
                },
                a = document.createElement("div");
            a.style.overflow = "hidden", this.domElement = a;
            var c = document.createElement("div");
            c.style.WebkitTransformStyle = "preserve-3d", c.style.transformStyle = "preserve-3d", c.style.pointerEvents = "none", a.appendChild(c);
            var l = /Trident/i.test(navigator.userAgent);

            function u(t) {
                return Math.abs(t) < 1e-10 ? 0 : t
            }

            function h(t) {
                var e = t.elements;
                return "matrix3d(" + u(e[0]) + "," + u(-e[1]) + "," + u(e[2]) + "," + u(e[3]) + "," + u(e[4]) + "," + u(-e[5]) + "," + u(e[6]) + "," + u(e[7]) + "," + u(e[8]) + "," + u(-e[9]) + "," + u(e[10]) + "," + u(e[11]) + "," + u(e[12]) + "," + u(-e[13]) + "," + u(e[14]) + "," + u(e[15]) + ")"
            }

            function p(t, e) {
                var r = t.elements,
                    o = "matrix3d(" + u(r[0]) + "," + u(r[1]) + "," + u(r[2]) + "," + u(r[3]) + "," + u(-r[4]) + "," + u(-r[5]) + "," + u(-r[6]) + "," + u(-r[7]) + "," + u(r[8]) + "," + u(r[9]) + "," + u(r[10]) + "," + u(r[11]) + "," + u(r[12]) + "," + u(r[13]) + "," + u(r[14]) + "," + u(r[15]) + ")";
                return l ? "translate(-50%,-50%)translate(" + n + "px," + i + "px)" + e + o : "translate(-50%,-50%)" + o
            }
            this.getSize = function() {
                return {
                    width: t,
                    height: e
                }
            }, this.setSize = function(r, o) {
                n = (t = r) / 2, i = (e = o) / 2, a.style.width = r + "px", a.style.height = o + "px", c.style.width = r + "px", c.style.height = o + "px"
            };
            var f, d, m = (f = new yn, d = new yn, function(t, e) {
                return f.setFromMatrixPosition(t.matrixWorld), d.setFromMatrixPosition(e.matrixWorld), f.distanceToSquared(d)
            });

            function g(t) {
                for (var e = function(t) {
                        var e = [];
                        return t.traverse((function(t) {
                            t instanceof td && e.push(t)
                        })), e
                    }(t).sort((function(t, e) {
                        return s.objects.get(t).distanceToCameraSquared - s.objects.get(e).distanceToCameraSquared
                    })), n = e.length, i = 0, r = e.length; i < r; i++) e[i].element.style.zIndex = n - i
            }
            this.render = function(t, e) {
                var f = e.projectionMatrix.elements[5] * i;
                if (s.camera.fov !== f && (e.isPerspectiveCamera ? (a.style.WebkitPerspective = f + "px", a.style.perspective = f + "px") : (a.style.WebkitPerspective = "", a.style.perspective = ""), s.camera.fov = f), !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), e.isOrthographicCamera) var d = -(e.right + e.left) / 2,
                    v = (e.top + e.bottom) / 2;
                var y = e.isOrthographicCamera ? "scale(" + f + ")translate(" + u(d) + "px," + u(v) + "px)" + h(e.matrixWorldInverse) : "translateZ(" + f + "px)" + h(e.matrixWorldInverse),
                    b = y + "translate(" + n + "px," + i + "px)";
                s.camera.style === b || l || (c.style.WebkitTransform = b, c.style.transform = b, s.camera.style = b),
                    function t(e, n, i, a) {
                        if (e instanceof td) {
                            var u;
                            e.onBeforeRender(r, n, i), e instanceof ed ? (o.copy(i.matrixWorldInverse), o.transpose(), o.copyPosition(e.matrixWorld), o.scale(e.scale), o.elements[3] = 0, o.elements[7] = 0, o.elements[11] = 0, o.elements[15] = 1, u = p(o, a)) : u = p(e.matrixWorld, a);
                            var h = e.element,
                                f = s.objects.get(e);
                            if (void 0 === f || f.style !== u) {
                                h.style.WebkitTransform = u, h.style.transform = u;
                                var d = {
                                    style: u
                                };
                                l && (d.distanceToCameraSquared = m(i, e)), s.objects.set(e, d)
                            }
                            h.style.display = e.visible ? "" : "none", h.parentNode !== c && c.appendChild(h), e.onAfterRender(r, n, i)
                        }
                        for (var g = 0, v = e.children.length; g < v; g++) t(e.children[g], n, i, a)
                    }(t, t, e, y), l && g(t)
            }
        };

    function hd() {
        ud.setSize(window.innerWidth, window.innerHeight)
    }
    ld.appendChild(ud.domElement), window.addEventListener("resize", hd), hd();
    var pd, fd = new Wn,
        dd = new Gr(40, window.innerWidth / window.innerHeight, 1, 1e4);

    function md() {
        for (pd && pd.kill(); fd.children.length;) fd.remove(fd.children[0])
    }

    function gd(t) {
        return (gd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function vd(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function yd(t, e) {
        return (yd = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function bd(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = _d(t);
            if (e) {
                var r = _d(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return xd(this, n)
        }
    }

    function xd(t, e) {
        return !e || "object" !== gd(e) && "function" != typeof e ? wd(t) : e
    }

    function wd(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function _d(t) {
        return (_d = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Md = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && yd(t, e)
            }(o, t);
            var e, n, i, r = bd(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).update = e.update.bind(wd(e)), e.show = e.show.bind(wd(e)), e.hide = e.hide.bind(wd(e)), e.hidden = e.hidden.bind(wd(e)), e.onResize = e.onResize.bind(wd(e)), e.$phrases = e.$all(".Phrase"), e.camera = new Gr(40, window.innerWidth / window.innerHeight, 1, 1e4), e.camera.position.z = 4e3, e.scene = new Wn, e.phrases = e.$phrases.map((function(t) {
                    var n = new cd(t);
                    return e.scene.add(n), n
                })), af(e.show), cf(e.hide), window.addEventListener("resize", e.onResize), e
            }
            return e = o, (n = [{
                key: "onResize",
                value: function() {
                    this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix()
                }
            }, {
                key: "show",
                value: function() {
                    N(), gsap.ticker.add(this.update), this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.fromTo([this.$el, ud.domElement], {
                        alpha: 0,
                        display: "none"
                    }, {
                        alpha: 1,
                        display: "block",
                        duration: 2
                    }, .5), this.startQueue(), document.querySelector(".Home").addEventListener("click", sf)
                }
            }, {
                key: "hide",
                value: function() {
                    document.querySelector(".Home").removeEventListener("click", sf), k(), this.tl && this.tl.kill(), this.tl = gsap.timeline({
                        onComplete: this.hidden
                    }), this.tl.to([this.$el, ud.domElement], {
                        alpha: 0,
                        display: "none",
                        duration: .5
                    })
                }
            }, {
                key: "hidden",
                value: function() {
                    this.phrases.forEach((function(t) {
                        return t.kill()
                    })), gsap.ticker.remove(this.update)
                }
            }, {
                key: "startQueue",
                value: function() {
                    var t = yf().total;
                    this.queue = this.phrases.slice(0, t);
                    for (var e = 0; e < Math.min(t, 3); e++) this.onQueue(!0, e)
                }
            }, {
                key: "onPhraseEnd",
                value: function(t) {
                    this.queue.push(t), this.onQueue()
                }
            }, {
                key: "onQueue",
                value: function() {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        i = this.queue.shift();
                    i.start((function() {
                        t.onPhraseEnd(i)
                    }), e, n)
                }
            }, {
                key: "update",
                value: function() {
                    ud.render(this.scene, this.camera)
                }
            }]) && vd(e.prototype, n), i && vd(e, i), o
        }(s.a),
        Sd = new et.a({
            id: "eye",
            use: "eye-usage",
            viewBox: "0 0 50 30",
            content: '<symbol viewBox="0 0 50 30" xmlns="http://www.w3.org/2000/svg" id="eye">\n  <path d="M44.46 14.11C44.25 14.44 44.03 14.76 43.8 15.08C43.69 15.24 43.58 15.39 43.47 15.54C43.41 15.62 43.36 15.69 43.3 15.77C43.23 15.86 43.34 15.72 43.34 15.71C43.32 15.71 43.22 15.86 43.21 15.88C42.73 16.49 42.21 17.08 41.68 17.64C41.15 18.19 40.59 18.72 40.02 19.22C39.72 19.48 39.43 19.72 39.12 19.96C39.11 19.97 39.01 20.04 39.01 20.05C39.01 20.05 39.19 19.91 39.04 20.03C38.96 20.09 38.89 20.15 38.81 20.2C38.66 20.31 38.5 20.42 38.35 20.53C37.07 21.44 35.71 22.22 34.28 22.86C34.19 22.9 34.11 22.94 34.02 22.98C33.98 23 33.78 23.05 33.76 23.09C33.76 23.08 33.97 23 33.79 23.08C33.76 23.09 33.72 23.11 33.69 23.12C33.59 23.16 33.49 23.2 33.39 23.24C33.02 23.39 32.65 23.52 32.27 23.65C31.51 23.91 30.74 24.13 29.96 24.31C29.57 24.4 29.17 24.48 28.77 24.55C28.59 24.58 28.41 24.61 28.22 24.64C28.12 24.65 28.03 24.67 27.93 24.68C27.9 24.68 27.74 24.71 27.88 24.69C28.03 24.67 27.82 24.7 27.79 24.7C26.97 24.8 26.14 24.87 25.32 24.88C24.49 24.9 23.66 24.88 22.82 24.82C22.42 24.79 22.03 24.75 21.63 24.7C21.58 24.7 21.53 24.69 21.48 24.68C21.71 24.71 21.57 24.69 21.52 24.68C21.42 24.67 21.33 24.65 21.23 24.64C21.02 24.61 20.82 24.57 20.61 24.54C19.05 24.26 17.51 23.82 16.03 23.24C15.94 23.21 15.85 23.17 15.76 23.13C15.7 23.11 15.43 23 15.66 23.09C15.47 23.01 15.29 22.93 15.1 22.85C14.74 22.69 14.39 22.52 14.04 22.34C13.36 21.99 12.69 21.6 12.04 21.18C11.71 20.97 11.39 20.75 11.07 20.52C10.91 20.41 10.76 20.3 10.61 20.19C10.53 20.13 10.46 20.08 10.38 20.02C10.34 19.99 10.23 19.91 10.41 20.04C10.36 20.01 10.32 19.97 10.27 19.93C9.67003 19.45 9.09003 18.95 8.53003 18.43C7.97003 17.89 7.43003 17.33 6.92003 16.74C6.66003 16.44 6.42003 16.15 6.18003 15.84C6.15003 15.8 6.12003 15.77 6.09003 15.73C6.02003 15.64 6.13003 15.78 6.13003 15.79C6.14003 15.78 5.97003 15.58 5.96003 15.56C5.83003 15.39 5.71003 15.22 5.59003 15.05C5.37003 14.74 5.16003 14.43 4.95003 14.11C4.95003 14.44 4.95003 14.77 4.95003 15.09C5.16003 14.76 5.38003 14.44 5.61003 14.12C5.72003 13.96 5.83003 13.81 5.94003 13.66C6.00003 13.58 6.05003 13.51 6.11003 13.43C6.18003 13.34 6.07003 13.48 6.07003 13.49C6.09003 13.49 6.19003 13.34 6.20003 13.32C6.68003 12.71 7.20003 12.12 7.73003 11.56C8.26003 11.01 8.81003 10.48 9.39003 9.98C9.69003 9.72 9.98003 9.48 10.29 9.24C10.3 9.23 10.4 9.16 10.4 9.15C10.4 9.15 10.22 9.29 10.37 9.17C10.45 9.11 10.52 9.05 10.6 9C10.75 8.89 10.91 8.78 11.06 8.67C12.34 7.76 13.7 6.98 15.13 6.34C15.22 6.3 15.3 6.26 15.39 6.22C15.43 6.2 15.63 6.15 15.65 6.11C15.65 6.12 15.44 6.2 15.62 6.12C15.65 6.11 15.69 6.09 15.72 6.08C15.82 6.04 15.92 6 16.02 5.96C16.39 5.81 16.76 5.68 17.14 5.55C17.9 5.29 18.67 5.07 19.45 4.89C19.84 4.8 20.24 4.72 20.64 4.65C20.82 4.62 21 4.59 21.19 4.56C21.29 4.55 21.38 4.53 21.48 4.52C21.51 4.52 21.67 4.49 21.53 4.51C21.39 4.53 21.6 4.5 21.63 4.5C22.45 4.4 23.28 4.33 24.1 4.32C24.93 4.3 25.76 4.32 26.6 4.38C27 4.41 27.4 4.45 27.79 4.5C27.84 4.5 27.89 4.51 27.94 4.52C27.71 4.49 27.85 4.51 27.9 4.52C28 4.53 28.09 4.55 28.19 4.56C28.4 4.59 28.6 4.63 28.81 4.66C30.37 4.94 31.91 5.38 33.39 5.96C33.48 5.99 33.57 6.03 33.66 6.07C33.72 6.09 33.99 6.2 33.76 6.11C33.95 6.19 34.13 6.27 34.32 6.35C34.68 6.51 35.03 6.68 35.38 6.86C36.06 7.21 36.73 7.6 37.38 8.02C37.71 8.23 38.03 8.45 38.35 8.68C38.51 8.79 38.66 8.9 38.81 9.01C38.89 9.07 38.96 9.12 39.04 9.18C39.08 9.21 39.19 9.29 39.01 9.16C39.06 9.19 39.1 9.23 39.15 9.27C39.75 9.75 40.33 10.25 40.89 10.77C41.45 11.31 41.99 11.87 42.5 12.46C42.76 12.76 43 13.05 43.24 13.36C43.27 13.4 43.3 13.43 43.33 13.47C43.4 13.56 43.29 13.42 43.29 13.41C43.28 13.42 43.45 13.62 43.46 13.64C43.59 13.81 43.71 13.98 43.83 14.15C44.05 14.46 44.26 14.77 44.47 15.09C44.75 15.52 45.34 15.73 45.8 15.44C46.23 15.16 46.44 14.57 46.15 14.11C44.36 11.33 42.06 8.93 39.37 7.01C36.71 5.12 33.67 3.75 30.49 3.02C27.1 2.24 23.57 2.17 20.14 2.78C16.92 3.35 13.8 4.59 11.04 6.36C8.26003 8.15 5.86003 10.45 3.95003 13.15C3.72003 13.47 3.51003 13.79 3.29003 14.12C3.11003 14.4 3.11003 14.82 3.29003 15.1C5.08003 17.88 7.38003 20.28 10.07 22.2C12.73 24.09 15.77 25.46 18.95 26.19C22.34 26.97 25.87 27.04 29.3 26.43C32.52 25.86 35.64 24.62 38.4 22.85C41.18 21.06 43.57 18.76 45.49 16.06C45.72 15.74 45.93 15.42 46.15 15.09C46.43 14.66 46.25 14 45.8 13.76C45.31 13.51 44.75 13.65 44.46 14.11Z" />\n  <path d="M30.37 14.6C30.37 14.77 30.37 14.94 30.35 15.11C30.35 15.19 30.34 15.27 30.33 15.34C30.33 15.4 30.29 15.51 30.34 15.28C30.33 15.32 30.33 15.37 30.32 15.41C30.27 15.74 30.19 16.06 30.09 16.37C30.04 16.53 29.98 16.68 29.92 16.83C29.88 16.93 29.95 16.74 29.95 16.75C29.95 16.76 29.91 16.85 29.9 16.87C29.87 16.95 29.83 17.03 29.79 17.1C29.64 17.39 29.48 17.66 29.29 17.92C29.26 17.97 29.19 18.09 29.14 18.12C29.14 18.12 29.27 17.97 29.19 18.05C29.16 18.08 29.14 18.12 29.11 18.15C29.01 18.27 28.9 18.39 28.79 18.5C28.68 18.62 28.57 18.72 28.45 18.83C28.4 18.88 28.34 18.93 28.28 18.98C28.25 19.01 28.21 19.03 28.18 19.06C28.08 19.15 28.2 19.06 28.23 19.03C28.16 19.14 27.94 19.24 27.84 19.31C27.7 19.4 27.57 19.48 27.43 19.56C27.29 19.64 27.15 19.71 27 19.78C26.97 19.79 26.94 19.8 26.91 19.82C26.74 19.9 26.96 19.81 26.96 19.8C26.92 19.85 26.78 19.87 26.72 19.89C26.4 20.01 26.07 20.1 25.74 20.16C25.66 20.17 25.59 20.19 25.51 20.2C25.47 20.2 25.42 20.21 25.38 20.22C25.38 20.22 25.58 20.2 25.47 20.21C25.29 20.22 25.11 20.24 24.93 20.25C24.59 20.26 24.25 20.24 23.92 20.21C23.81 20.2 24.01 20.22 24.01 20.22C23.97 20.21 23.92 20.21 23.88 20.2C23.8 20.19 23.73 20.18 23.65 20.16C23.48 20.13 23.31 20.08 23.14 20.04C22.99 20 22.85 19.95 22.71 19.9C22.64 19.88 22.57 19.85 22.5 19.82C22.33 19.76 22.54 19.84 22.55 19.84C22.52 19.84 22.43 19.79 22.4 19.77C22.11 19.63 21.83 19.48 21.56 19.3C21.43 19.22 21.32 19.13 21.2 19.04C21.09 18.97 21.34 19.16 21.24 19.07C21.22 19.05 21.19 19.03 21.17 19.01C21.1 18.95 21.02 18.89 20.95 18.82C20.71 18.61 20.49 18.38 20.29 18.14C20.27 18.12 20.25 18.09 20.23 18.07C20.12 17.94 20.25 18.11 20.26 18.12C20.2 18.08 20.15 17.97 20.11 17.92C20.02 17.79 19.93 17.66 19.85 17.52C19.77 17.38 19.69 17.24 19.62 17.1C19.59 17.03 19.55 16.96 19.52 16.9C19.51 16.87 19.5 16.84 19.48 16.81C19.39 16.61 19.53 16.96 19.49 16.83C19.38 16.52 19.27 16.22 19.19 15.9C19.15 15.74 19.12 15.58 19.09 15.41C19.09 15.38 19.08 15.34 19.08 15.31C19.06 15.17 19.1 15.5 19.09 15.37C19.08 15.28 19.07 15.19 19.07 15.1C19.05 14.76 19.05 14.42 19.07 14.08C19.07 14 19.08 13.92 19.09 13.85C19.11 13.67 19.08 13.9 19.08 13.91C19.07 13.89 19.1 13.79 19.1 13.78C19.12 13.61 19.16 13.45 19.2 13.29C19.28 12.97 19.39 12.67 19.5 12.36C19.54 12.24 19.42 12.53 19.48 12.41C19.49 12.38 19.5 12.35 19.52 12.32C19.55 12.24 19.59 12.16 19.63 12.09C19.7 11.95 19.78 11.81 19.86 11.67C19.94 11.53 20.03 11.4 20.12 11.27C20.16 11.21 20.21 11.15 20.25 11.09C20.32 10.98 20.13 11.23 20.22 11.13C20.25 11.09 20.29 11.05 20.32 11.01C20.52 10.77 20.75 10.54 20.99 10.33C21.04 10.28 21.1 10.23 21.16 10.18C21.18 10.16 21.21 10.14 21.23 10.12C21.36 10.01 21.19 10.14 21.18 10.15C21.25 10.03 21.48 9.93 21.6 9.86C21.87 9.69 22.15 9.53 22.44 9.4C22.47 9.39 22.5 9.38 22.53 9.36C22.65 9.3 22.36 9.42 22.48 9.38C22.55 9.36 22.62 9.33 22.69 9.3C22.86 9.24 23.02 9.19 23.19 9.14C23.34 9.1 23.49 9.06 23.64 9.03C23.72 9.02 23.79 9 23.87 8.99C23.91 8.98 23.96 8.98 24 8.97C24.13 8.95 23.75 8.99 23.98 8.97C24.32 8.94 24.65 8.92 25 8.94C25.16 8.94 25.32 8.96 25.47 8.97C25.65 8.98 25.28 8.94 25.51 8.97C25.6 9 25.7 9.02 25.79 9.04C26.11 9.11 26.43 9.2 26.73 9.31C26.8 9.33 26.87 9.37 26.94 9.39C27.06 9.43 26.77 9.31 26.89 9.37C26.92 9.38 26.95 9.39 26.98 9.41C27.14 9.48 27.29 9.56 27.44 9.64C27.57 9.71 27.7 9.79 27.82 9.87C27.94 9.94 28.16 10.05 28.24 10.16C28.23 10.15 28.06 10.01 28.19 10.13C28.21 10.15 28.24 10.17 28.26 10.19C28.32 10.24 28.37 10.29 28.43 10.34C28.56 10.45 28.68 10.57 28.8 10.69C28.9 10.8 29 10.91 29.1 11.02C29.13 11.05 29.15 11.09 29.18 11.12C29.24 11.19 29.26 11.15 29.15 11.07C29.21 11.11 29.26 11.22 29.3 11.27C29.48 11.53 29.65 11.81 29.8 12.09C29.83 12.16 29.87 12.23 29.9 12.29C29.92 12.33 29.93 12.37 29.95 12.41C30 12.51 29.91 12.32 29.92 12.33C29.96 12.36 30 12.52 30.01 12.57C30.04 12.65 30.07 12.74 30.09 12.82C30.19 13.13 30.27 13.45 30.32 13.78C30.32 13.82 30.33 13.87 30.34 13.91C30.34 13.91 30.32 13.71 30.33 13.82C30.33 13.9 30.34 13.98 30.35 14.05C30.36 14.24 30.37 14.42 30.37 14.6C30.37 15.11 30.82 15.6 31.34 15.57C31.86 15.55 32.32 15.14 32.31 14.6C32.3 13.06 31.84 11.5 30.94 10.25C30.01 8.95 28.75 7.99 27.25 7.44C24.35 6.38 20.88 7.31 18.92 9.7C17.89 10.95 17.27 12.44 17.14 14.06C17.01 15.6 17.41 17.21 18.21 18.53C18.98 19.8 20.14 20.87 21.5 21.48C23.01 22.16 24.65 22.36 26.28 22.03C29.27 21.43 31.74 18.88 32.21 15.86C32.27 15.44 32.32 15.02 32.32 14.59C32.32 14.08 31.87 13.59 31.35 13.62C30.81 13.65 30.38 14.05 30.37 14.6Z" />\n  <path d="M23 14.64C23 14.55 23 14.46 23.01 14.37C23.02 14.15 22.98 14.52 23.01 14.4C23.02 14.36 23.0201 14.31 23.0301 14.27C23.0501 14.18 23.07 14.1 23.09 14.02C23.1 13.97 23.12 13.92 23.14 13.86C23.18 13.71 23.1101 13.9 23.1201 13.91C23.0901 13.83 23.34 13.5 23.38 13.43C23.4 13.4 23.4301 13.36 23.4501 13.33C23.5101 13.23 23.33 13.46 23.42 13.38C23.49 13.31 23.5501 13.23 23.6101 13.17C23.6701 13.11 23.7301 13.05 23.7901 13C23.9001 12.9 23.74 13.02 23.74 13.03C23.74 13.02 23.83 12.97 23.84 12.96C23.99 12.86 24.15 12.78 24.31 12.7C24.42 12.65 24.0901 12.78 24.2901 12.71C24.3301 12.7 24.37 12.68 24.41 12.67C24.49 12.65 24.58 12.62 24.66 12.6C24.7 12.59 24.7501 12.59 24.7901 12.58C24.9701 12.54 24.64 12.59 24.76 12.58C24.86 12.58 24.96 12.57 25.06 12.57C25.57 12.57 26.0601 12.13 26.0301 11.6C26.0101 11.08 25.6 10.62 25.06 10.63C22.86 10.65 21.07 12.45 21.05 14.64C21.05 15.15 21.5001 15.64 22.0201 15.61C22.5601 15.59 22.99 15.19 23 14.64Z" />\n</symbol>'
        });
    it.a.add(Sd);

    function Td(t) {
        return (Td = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Ed(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Cd(t, e) {
        return (Cd = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Ad(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Od(t);
            if (e) {
                var r = Od(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Ld(this, n)
        }
    }

    function Ld(t, e) {
        return !e || "object" !== Td(e) && "function" != typeof e ? Pd(t) : e
    }

    function Pd(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Od(t) {
        return (Od = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Rd = ".channel-split-green",
        Id = ".channel-split-blue",
        Dd = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Cd(t, e)
            }(o, t);
            var e, n, i, r = Ad(o);

            function o(t) {
                var e;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onEnd = e.onEnd.bind(Pd(e)), e.onMouseOver = e.onMouseOver.bind(Pd(e)), e.onMouseOut = e.onMouseOut.bind(Pd(e)), e.onClick = e.onClick.bind(Pd(e)), e.onOpen = e.onOpen.bind(Pd(e)), e.onClose = e.onClose.bind(Pd(e)), e.onHintFound = e.onHintFound.bind(Pd(e)), e.$arcContainer = e.$one(".HintsButton-circles");
                var n, i = e.$arcContainer.getAttribute("xmlns");
                e.nbTips = pf, e.angle = 360 / e.nbTips, e.arcs = [];
                for (var s = 0; s < e.nbTips; s++) {
                    var a = document.createElementNS(i, "path"),
                        l = s * e.angle,
                        u = (s + 1) * e.angle,
                        h = ce(l + .5 * e.angle - 90),
                        p = 4 * Math.cos(h),
                        f = 4 * Math.sin(h);
                    a.setAttribute("class", "HintsButton-arc"), a.setAttribute("d", ue(60, 60, 19, l, u)), a.style.transform = "translate(".concat(p, "px, ").concat(f, "px)"), e.$arcContainer.appendChild(a), e.arcs.push(a)
                }
                return re(t), e.$red = e.$one(".channel-split-red"), e.$green = e.$one(Rd), e.$blue = e.$one(Id), e.$el.addEventListener("mouseover", e.onMouseOver), e.$el.addEventListener("mouseout", e.onMouseOut), e.$el.addEventListener("click", e.onClick), af(e.onOpen), cf(e.onClose), n = e.onHintFound, nf.on("hint", n), c.on("startend", e.onEnd), e
            }
            return e = o, (n = [{
                key: "onEnd",
                value: function() {
                    this.$el.style.display = "none"
                }
            }, {
                key: "onHintFound",
                value: function(t) {
                    for (var e = vf(), n = 0; n < this.nbTips; n++) n === e.total - 1 && this.highlightArc(n)
                }
            }, {
                key: "highlightArc",
                value: function(t) {
                    var e = this,
                        n = [this.$all(".channel-split-red .HintsButton-arc")[t], this.$all(Rd + " .HintsButton-arc")[t], this.$all(Id + " .HintsButton-arc")[t]],
                        i = this.$all("#sofGlow feComponentTransfer feFuncA");
                    this.glow = 0;
                    var r = gsap.timeline({
                        onUpdate: function() {
                            i.forEach((function(t) {
                                t.setAttribute("slope", e.glow)
                            }))
                        }
                    });
                    r.set(n, {
                        alpha: .6
                    }), r.fromTo(this.$el, {
                        scale: 1.2
                    }, {
                        scale: 1,
                        duration: 1,
                        ease: "expo.out"
                    }, 0), r.fromTo(this, {
                        glow: 20
                    }, {
                        glow: 0,
                        duration: 2,
                        ease: "expo.out"
                    }, 0)
                }
            }, {
                key: "onOpen",
                value: function() {}
            }, {
                key: "onClose",
                value: function() {}
            }, {
                key: "onClick",
                value: function() {
                    vf().total <= 0 || ( of () ? sf() : Sf() || Kp.isTransitionning() || (rf = !0, nf.emit("open"), Oe("Inventaire", "Open", "Inventaire ouvert")))
                }
            }, {
                key: "onMouseOver",
                value: function() {
                    vf().total <= 0 || Sf() || (this.tl && this.tl.kill(), this.wiggleTl = se(this.$red, this.$blue, 1), R())
                }
            }, {
                key: "onMouseOut",
                value: function() {
                    vf().total <= 0 || Sf() || (this.wiggleTl && this.wiggleTl.kill(), this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.add(oe(this.$red, this.$blue), 0), I())
                }
            }, {
                key: "transitionIn",
                value: function() {
                    return this.tl = gsap.timeline(), this.tl.fromTo(this.$el, {
                        opacity: 0
                    }, {
                        opacity: 1,
                        duration: .5
                    }), this.tl
                }
            }]) && Ed(e.prototype, n), i && Ed(e, i), o
        }(s.a);

    function Nd(t) {
        return (Nd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function kd(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Ud(t, e) {
        return (Ud = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Bd(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = jd(t);
            if (e) {
                var r = jd(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return zd(this, n)
        }
    }

    function zd(t, e) {
        return !e || "object" !== Nd(e) && "function" != typeof e ? Fd(t) : e
    }

    function Fd(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function jd(t) {
        return (jd = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Hd = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Ud(t, e)
        }(o, t);
        var e, n, i, r = Bd(o);

        function o(t) {
            var e;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(Fd(e)), e.onMouseLeave = e.onMouseLeave.bind(Fd(e)), e.onEnd = e.onEnd.bind(Fd(e)), e.$choices = e.$one(".Languages-choices"), e.$buttons = e.$all(".LanguageButton"), e.$button = e.$buttons.shift(), e.isHidden = !0, e.$button.addEventListener("mouseover", e.onMouseOver), c.on("startend", e.onEnd), e
        }
        return e = o, (n = [{
            key: "onEnd",
            value: function() {
                this.$el.style.display = "none"
            }
        }, {
            key: "onMouseOver",
            value: function() {
                this.show(), this.$button.removeEventListener("mouseover", this.onMouseOver), this.$el.addEventListener("mouseleave", this.onMouseLeave)
            }
        }, {
            key: "onMouseLeave",
            value: function() {
                this.$el.removeEventListener("mouseleave", this.onMouseLeave), this.$button.addEventListener("mouseover", this.onMouseOver), this.hide()
            }
        }, {
            key: "show",
            value: function() {
                this.isHidden = !1, this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.set(this.$choices, {
                    display: "block"
                }), this.tl.fromTo(this.$choices, {
                    alpha: 0
                }, {
                    alpha: 1,
                    duration: .4
                }, 0), this.tl.fromTo(this.$buttons, {
                    y: -30
                }, {
                    y: 0,
                    force3D: !0,
                    duration: .4,
                    stagger: .1,
                    ease: "expo.out"
                }, 0)
            }
        }, {
            key: "hide",
            value: function() {
                this.isHidden = !0, this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.to(this.$choices, {
                    duration: .4,
                    alpha: 0
                }), this.tl.set(this.$choices, {
                    display: "none"
                })
            }
        }, {
            key: "transitionIn",
            value: function() {
                return this.tl = gsap.timeline(), this.tl.fromTo(this.$el, {
                    opacity: 0
                }, {
                    opacity: 1,
                    duration: .5
                }), this.tl
            }
        }]) && kd(e.prototype, n), i && kd(e, i), o
    }(s.a);

    function Gd(t) {
        return (Gd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Vd(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Wd(t, e) {
        return (Wd = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function qd(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Yd(t);
            if (e) {
                var r = Yd(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Xd(this, n)
        }
    }

    function Xd(t, e) {
        return !e || "object" !== Gd(e) && "function" != typeof e ? Zd(t) : e
    }

    function Zd(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Yd(t) {
        return (Yd = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var $d = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Wd(t, e)
            }(o, t);
            var e, n, i, r = qd(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onEnd = e.onEnd.bind(Zd(e)), c.on("startend", e.onEnd), e
            }
            return e = o, (n = [{
                key: "onEnd",
                value: function() {
                    this.$el.style.display = "none"
                }
            }, {
                key: "transitionIn",
                value: function() {
                    return this.tl = gsap.timeline(), this.tl.fromTo(this.$el, {
                        opacity: 0
                    }, {
                        opacity: 1,
                        duration: .5
                    }), this.tl
                }
            }]) && Vd(e.prototype, n), i && Vd(e, i), o
        }(s.a),
        Jd = new et.a({
            id: "logo",
            use: "logo-usage",
            viewBox: "0 0 110 140",
            content: '<symbol viewBox="0 0 110 140" xmlns="http://www.w3.org/2000/svg" id="logo">\n  <path d="M54.83 12.35C65.4 12.35 74.67 14.58 82.65 19.03C90.63 23.49 96.81 29.88 101.22 38.22C105.62 46.56 107.82 56.69 107.82 68.6C107.82 80.2 105.57 90.35 101.06 99.06C96.55 107.76 90.28 114.55 82.26 119.42C74.23 124.29 65.03 126.72 54.68 126.72C44.11 126.72 34.84 124.49 26.86 120.04C18.88 115.59 12.69 109.16 8.29 100.77C3.88 92.38 1.69 82.28 1.69 70.47C1.69 58.87 3.97 48.72 8.53 40.01C13.09 31.31 19.35 24.52 27.33 19.65C35.3 14.79 44.47 12.35 54.83 12.35ZM24.53 109.94L27.33 112.74L10.7 136.51L7.44 134.34L24.53 109.94ZM80.31 25.87L82.64 28.98L29.03 112.74L26.23 109.94L80.31 25.87ZM96.47 3.8L99.42 5.82L83.72 28.97L81.39 25.86L96.47 3.8ZM54.21 15.15C48.1 15.15 42.79 17.48 38.28 22.14C33.77 26.8 30.28 33.23 27.79 41.41C25.3 49.6 24.06 59.07 24.06 69.85C24.06 80.83 25.46 90.39 28.26 98.52C31.06 106.65 34.84 112.92 39.6 117.32C44.36 121.72 49.6 123.92 55.3 123.92C61.41 123.92 66.72 121.59 71.23 116.93C75.74 112.27 79.23 105.82 81.72 97.58C84.2 89.35 85.45 79.89 85.45 69.22C85.45 58.14 84.05 48.55 81.26 40.47C78.46 32.39 74.71 26.15 69.99 21.74C65.26 17.35 60.01 15.15 54.21 15.15Z" />\n</symbol>'
        });
    it.a.add(Jd);

    function Kd(t) {
        return (Kd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Qd(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function tm(t, e) {
        return (tm = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function em(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = rm(t);
            if (e) {
                var r = rm(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return nm(this, n)
        }
    }

    function nm(t, e) {
        return !e || "object" !== Kd(e) && "function" != typeof e ? im(t) : e
    }

    function im(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function rm(t) {
        return (rm = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var om = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && tm(t, e)
        }(o, t);
        var e, n, i, r = em(o);

        function o(t) {
            var e;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), (e = r.call(this, t)).onMouseOver = e.onMouseOver.bind(im(e)), e.onMouseOut = e.onMouseOut.bind(im(e)), e.onClick = e.onClick.bind(im(e)), e.onTransitionInComplete = e.onTransitionInComplete.bind(im(e)), re(t), e.$red = e.$one(".channel-split-red"), e.$green = e.$one(".channel-split-green"), e.$blue = e.$one(".channel-split-blue"), e
        }
        return e = o, (n = [{
            key: "onMouseOver",
            value: function() { of () || (this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl.to(this.$el, {
                    opacity: .6,
                    duration: .5
                }), this.wiggleTl = se(this.$red, this.$blue, 2), R())
            }
        }, {
            key: "onMouseOut",
            value: function() { of () || (this.wiggleTl && this.wiggleTl.kill(), this.tl && this.tl.kill(), this.tl = gsap.timeline(), this.tl = gsap.timeline(), this.tl.to(this.$el, {
                    opacity: .1,
                    duration: .5
                }), this.tl.add(oe(this.$red, this.$blue), 0), I())
            }
        }, {
            key: "transitionIn",
            value: function() {
                return this.tl && this.tl.kill(), this.tl = gsap.timeline({
                    onComplete: this.onTransitionInComplete
                }), this.tl.fromTo(this.$el, {
                    opacity: 0
                }, {
                    duration: 1,
                    opacity: 1
                }, 0), this.tl.fromTo(this.$el, {
                    x: .5 * -window.innerWidth + 60 + 28
                }, {
                    x: 0,
                    duration: 1,
                    ease: "expo.inOut",
                    opacity: .1
                }, 4.5), this.tl
            }
        }, {
            key: "onClick",
            value: function() {
                Sf() ? Tf() : of () || Kp.isTransitionning() || (Mf = !0, _f.emit("pause:start"), track("Logo", "Click", "Click sur le logo"))
            }
        }, {
            key: "onTransitionInComplete",
            value: function() {
                this.$el.addEventListener("mouseover", this.onMouseOver), this.$el.addEventListener("mouseout", this.onMouseOut), this.$el.addEventListener("click", this.onClick)
            }
        }]) && Qd(e.prototype, n), i && Qd(e, i), o
    }(s.a);

    function sm(t) {
        return (sm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function am(t, e) {
        return (am = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function cm(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = um(t);
            if (e) {
                var r = um(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return lm(this, n)
        }
    }

    function lm(t, e) {
        return !e || "object" !== sm(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function um(t) {
        return (um = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var hm = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && am(t, e)
        }(n, t);
        var e = cm(n);

        function n(t) {
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, n), e.call(this, t)
        }
        return n
    }(s.a);

    function pm(t) {
        return (pm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function fm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function dm(t, e) {
        return (dm = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function mm(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = ym(t);
            if (e) {
                var r = ym(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return gm(this, n)
        }
    }

    function gm(t, e) {
        return !e || "object" !== pm(e) && "function" != typeof e ? vm(t) : e
    }

    function vm(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function ym(t) {
        return (ym = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var bm = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && dm(t, e)
        }(o, t);
        var e, n, i, r = mm(o);

        function o(t) {
            var e, n, i, s, a, l, u;
            return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).onMouseMove = e.onMouseMove.bind(vm(e)), e.update = e.update.bind(vm(e)), e.onUIOver = e.onUIOver.bind(vm(e)), e.onUIOut = e.onUIOut.bind(vm(e)), e.onDoorOver = e.onDoorOver.bind(vm(e)), e.onDoorOut = e.onDoorOut.bind(vm(e)), e.onHintOver = e.onHintOver.bind(vm(e)), e.onHintOut = e.onHintOut.bind(vm(e)), e.onProgress = e.onProgress.bind(vm(e)), e.onValidate = e.onValidate.bind(vm(e)), e.onCrossModeEnable = e.onCrossModeEnable.bind(vm(e)), e.onCrossModeDisable = e.onCrossModeDisable.bind(vm(e)), e.onEnd = e.onEnd.bind(vm(e)), window.addEventListener("mousemove", e.onMouseMove), e.mouse = {
                    x: .5 * window.innerWidth,
                    y: .5 * window.innerHeight
                }, e.position = {
                    x: e.mouse.x,
                    y: e.mouse.y
                }, e.scale = 1, e.$cross = e.$one(".Cursor-cross"), e.$circle = e.$one(".Cursor-ring-circle"), e.radius = e.$circle.r.baseVal.value, e.circumference = 2 * e.radius * Math.PI, e.$circle.style.strokeDasharray = "".concat(e.circumference, " ").concat(e.circumference), e.percent = 0, e.onProgress(), O(e.onUIOver), n = e.onUIOut, L.on("ui:out", n), i = e.onDoorOver, L.on("door:over", i),
                function(t) {
                    L.on("door:out", t)
                }(e.onDoorOut),
                function(t) {
                    L.on("hint:over", t)
                }(e.onHintOver),
                function(t) {
                    L.on("hint:out", t)
                }(e.onHintOut), s = e.onProgress, L.on("hint:progress", s), a = e.onValidate, L.on("hint:validate", a), l = e.onCrossModeEnable, L.on("cross:enable", l), u = e.onCrossModeDisable, L.on("cross:disable", u), af((function() {
                    e.onProgress(1)
                })), c.on("startend", e.onEnd), e
        }
        return e = o, (n = [{
            key: "onEnd",
            value: function() {
                this.$el.style.display = "none"
            }
        }, {
            key: "onMouseMove",
            value: function(t) {
                this.mouse.x = t.clientX, this.mouse.y = t.clientY
            }
        }, {
            key: "onCrossModeEnable",
            value: function() {
                this.onProgress(1), this.$cross.style.display = "block"
            }
        }, {
            key: "onCrossModeDisable",
            value: function() {
                this.onProgress(1), this.$cross.style.display = "none"
            }
        }, {
            key: "onValidate",
            value: function() {
                this.onProgress(1), gsap.fromTo(this, {
                    scale: 1.5
                }, {
                    scale: 1,
                    ease: "expo.out",
                    duration: .8
                })
            }
        }, {
            key: "onProgress",
            value: function(t) {
                this.$circle.style.strokeDashoffset = this.circumference - t * this.circumference
            }
        }, {
            key: "onUIOver",
            value: function(t) {
                gsap.to(this, {
                    scale: 1.5,
                    ease: "expo.out",
                    duration: .8
                }), gsap.to(this.$circle, {
                    fill: "transparent",
                    duration: .4
                })
            }
        }, {
            key: "onUIOut",
            value: function(t) {
                gsap.to(this, {
                    scale: 1,
                    ease: "expo.out",
                    duration: .8
                }), gsap.to(this.$circle, {
                    fill: "transparent",
                    duration: .4
                })
            }
        }, {
            key: "onDoorOver",
            value: function(t) {
                gsap.to(this, {
                    scale: .3,
                    ease: "expo.out",
                    duration: .8
                }), gsap.to(this.$circle, {
                    fill: "white",
                    duration: .4
                })
            }
        }, {
            key: "onDoorOut",
            value: function(t) {
                gsap.to(this, {
                    scale: 1,
                    ease: "expo.out",
                    duration: .8
                }), gsap.to(this.$circle, {
                    fill: "transparent",
                    duration: .4
                })
            }
        }, {
            key: "onHintOver",
            value: function(t) {
                gsap.to(this, {
                    scale: 1.5,
                    ease: "expo.out",
                    duration: .8
                }), gsap.to(this.$circle, {
                    fill: "transparent",
                    duration: .4
                })
            }
        }, {
            key: "onHintOut",
            value: function(t) {
                gsap.to(this, {
                    scale: 1,
                    ease: "expo.out",
                    duration: .8
                }), gsap.to(this.$circle, {
                    fill: "transparent",
                    duration: .4
                })
            }
        }, {
            key: "update",
            value: function() {
                this.position.x += .5 * (this.mouse.x - this.position.x), this.position.y += .5 * (this.mouse.y - this.position.y), this.$el.style.transform = "translate3D(".concat(this.position.x, "px, ").concat(this.position.y, "px, 0) scale(").concat(this.scale, ")")
            }
        }, {
            key: "transitionIn",
            value: function() {
                return this.tl = gsap.timeline(), this.tl.fromTo(this.$el, {
                    opacity: 0
                }, {
                    opacity: 1,
                    duration: .5
                }), this.tl
            }
        }]) && fm(e.prototype, n), i && fm(e, i), o
    }(s.a);

    function xm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var wm = new(function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.resolvers = [], this.manifest = []
            }
            var e, n, i;
            return e = t, (n = [{
                key: "warn",
                value: function() {
                    for (var t, e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                    (t = console).warn.apply(t, ["[Preloader]"].concat(n))
                }
            }, {
                key: "init",
                value: function() {
                    for (var t = this, e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                    n.forEach((function(e) {
                        e.hasOwnProperty("type") || t.warn("init()", "This resolver shoud have a `type` property", e), "function" != typeof e.resolve && t.warn("init()", "This resolver should implement a `resolve` function", e), "function" != typeof e.get && t.warn("init()", "This resolver should implement a `get` function", e), t.resolvers.push(e)
                    }))
                }
            }, {
                key: "load",
                value: function(t) {
                    var e = this,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "/",
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    Array.isArray(t) || this.warn("load()", "manifest should be an array", t), t = t.map((function(t) {
                        var e = t.url;
                        return t.dataUrl || (e = t.cdn && i ? i + t.url : n + t.url, e += "?v=" + t.version), Object.assign({}, t, {
                            url: e
                        })
                    })), this.manifest = this.manifest.concat(t);
                    for (var r = 0, o = t.length; r < o; r++) {
                        for (var s = t[r], a = !1, c = 0, l = t.length; c < l; c++)
                            if (r !== c && t[c].id === s.id) {
                                a = !0;
                                break
                            }
                        if (a) {
                            this.warn("load()", "This id is used twice in the manifest: `" + s.id + "`");
                            break
                        }
                    }
                    var u = t.map((function(t) {
                        var n = e.getResolverForType(t.type).resolve(t);
                        return "function" != typeof n.then && e.warn("resolver for type `" + t.type + "` does not return a promise in its resolve method, check its implementation"), n
                    }));
                    return Promise.all(u).catch((function(t) {
                        return console.error(t)
                    }))
                }
            }, {
                key: "getResolverForType",
                value: function(t) {
                    return this.resolvers.find((function(e) {
                        return e.type === t
                    }))
                }
            }, {
                key: "get",
                value: function(t) {
                    var e = this.manifest.find((function(e) {
                        return e.id === t
                    }));
                    if (e) {
                        for (var n = this.getResolverForType(e.type), i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) r[o - 1] = arguments[o];
                        return n.get(e, r)
                    }
                }
            }]) && xm(e.prototype, n), i && xm(e, i), t
        }()),
        _m = function() {
            function t(t) {
                Ql.call(this, t), this.dracoLoader = null, this.ddsLoader = null, this.pluginCallbacks = [], this.register((function(t) {
                    return new s(t)
                }))
            }

            function e() {
                var t = {};
                return {
                    get: function(e) {
                        return t[e]
                    },
                    add: function(e, n) {
                        t[e] = n
                    },
                    remove: function(e) {
                        delete t[e]
                    },
                    removeAll: function() {
                        t = {}
                    }
                }
            }
            t.prototype = Object.assign(Object.create(Ql.prototype), {
                constructor: t,
                load: function(t, e, n, i) {
                    var r, o = this;
                    r = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Xu(t), o.manager.itemStart(t);
                    var s = function(e) {
                            i ? i(e) : console.error(e), o.manager.itemError(t), o.manager.itemEnd(t)
                        },
                        a = new eu(o.manager);
                    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), "use-credentials" === o.crossOrigin && a.setWithCredentials(!0), a.load(t, (function(n) {
                        try {
                            o.parse(n, r, (function(n) {
                                e(n), o.manager.itemEnd(t)
                            }), s)
                        } catch (t) {
                            s(t)
                        }
                    }), n, s)
                },
                setDRACOLoader: function(t) {
                    return this.dracoLoader = t, this
                },
                setDDSLoader: function(t) {
                    return this.ddsLoader = t, this
                },
                register: function(t) {
                    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
                },
                unregister: function(t) {
                    return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
                },
                parse: function(t, e, s, c) {
                    var l, f = {},
                        g = {};
                    if ("string" == typeof t) l = t;
                    else if (qu(new Uint8Array(t, 0, 4)) === a) {
                        try {
                            f[n.KHR_BINARY_GLTF] = new u(t)
                        } catch (t) {
                            return void(c && c(t))
                        }
                        l = f[n.KHR_BINARY_GLTF].content
                    } else l = qu(new Uint8Array(t));
                    var v = JSON.parse(l);
                    if (void 0 === v.asset || v.asset.version[0] < 2) c && c(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    else {
                        var y = new F(v, {
                            path: e || this.resourcePath || "",
                            crossOrigin: this.crossOrigin,
                            manager: this.manager
                        });
                        y.fileLoader.setRequestHeader(this.requestHeader);
                        for (var b = 0; b < this.pluginCallbacks.length; b++) {
                            var x = this.pluginCallbacks[b](y);
                            g[x.name] = x, f[x.name] = !0
                        }
                        if (v.extensionsUsed)
                            for (b = 0; b < v.extensionsUsed.length; ++b) {
                                var w = v.extensionsUsed[b],
                                    _ = v.extensionsRequired || [];
                                switch (w) {
                                    case n.KHR_LIGHTS_PUNCTUAL:
                                        f[w] = new r(v);
                                        break;
                                    case n.KHR_MATERIALS_UNLIT:
                                        f[w] = new o;
                                        break;
                                    case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        f[w] = new d;
                                        break;
                                    case n.KHR_DRACO_MESH_COMPRESSION:
                                        f[w] = new h(v, this.dracoLoader);
                                        break;
                                    case n.MSFT_TEXTURE_DDS:
                                        f[w] = new i(this.ddsLoader);
                                        break;
                                    case n.KHR_TEXTURE_TRANSFORM:
                                        f[w] = new p;
                                        break;
                                    case n.KHR_MESH_QUANTIZATION:
                                        f[w] = new m;
                                        break;
                                    default:
                                        _.indexOf(w) >= 0 && void 0 === g[w] && console.warn('THREE.GLTFLoader: Unknown extension "' + w + '".')
                                }
                            }
                        y.setExtensions(f), y.setPlugins(g), y.parse(s, c)
                    }
                }
            });
            var n = {
                KHR_BINARY_GLTF: "KHR_binary_glTF",
                KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                MSFT_TEXTURE_DDS: "MSFT_texture_dds"
            };

            function i(t) {
                if (!t) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
                this.name = n.MSFT_TEXTURE_DDS, this.ddsLoader = t
            }

            function r(t) {
                this.name = n.KHR_LIGHTS_PUNCTUAL;
                var e = t.extensions && t.extensions[n.KHR_LIGHTS_PUNCTUAL] || {};
                this.lightDefs = e.lights || []
            }

            function o() {
                this.name = n.KHR_MATERIALS_UNLIT
            }

            function s(t) {
                this.parser = t, this.name = n.KHR_MATERIALS_CLEARCOAT
            }
            r.prototype.loadLight = function(t) {
                var e, n = this.lightDefs[t],
                    i = new Ni(16777215);
                void 0 !== n.color && i.fromArray(n.color);
                var r = void 0 !== n.range ? n.range : 0;
                switch (n.type) {
                    case "directional":
                        (e = new Fu(i)).target.position.set(0, 0, -1), e.add(e.target);
                        break;
                    case "point":
                        (e = new Uu(i)).distance = r;
                        break;
                    case "spot":
                        (e = new Nu(i)).distance = r, n.spot = n.spot || {}, n.spot.innerConeAngle = void 0 !== n.spot.innerConeAngle ? n.spot.innerConeAngle : 0, n.spot.outerConeAngle = void 0 !== n.spot.outerConeAngle ? n.spot.outerConeAngle : Math.PI / 4, e.angle = n.spot.outerConeAngle, e.penumbra = 1 - n.spot.innerConeAngle / n.spot.outerConeAngle, e.target.position.set(0, 0, -1), e.add(e.target);
                        break;
                    default:
                        throw new Error('THREE.GLTFLoader: Unexpected light type, "' + n.type + '".')
                }
                return e.position.set(0, 0, 0), e.decay = 2, void 0 !== n.intensity && (e.intensity = n.intensity), e.name = n.name || "light_" + t, Promise.resolve(e)
            }, o.prototype.getMaterialType = function() {
                return Hi
            }, o.prototype.extendParams = function(t, e, n) {
                var i = [];
                t.color = new Ni(1, 1, 1), t.opacity = 1;
                var r = e.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        var o = r.baseColorFactor;
                        t.color.fromArray(o), t.opacity = o[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture))
                }
                return Promise.all(i)
            }, s.prototype.getMaterialType = function() {
                return Cl
            }, s.prototype.extendMaterialParams = function(t, e) {
                var n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                var r = [],
                    o = i.extensions[this.name];
                if (void 0 !== o.clearcoatFactor && (e.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (e.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                    var s = o.clearcoatNormalTexture.scale;
                    e.clearcoatNormalScale = new sn(s, s)
                }
                return Promise.all(r)
            };
            var a = "glTF",
                c = 1313821514,
                l = 5130562;

            function u(t) {
                this.name = n.KHR_BINARY_GLTF, this.content = null, this.body = null;
                var e = new DataView(t, 0, 12);
                if (this.header = {
                        magic: qu(new Uint8Array(t.slice(0, 4))),
                        version: e.getUint32(4, !0),
                        length: e.getUint32(8, !0)
                    }, this.header.magic !== a) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                for (var i = new DataView(t, 12), r = 0; r < i.byteLength;) {
                    var o = i.getUint32(r, !0);
                    r += 4;
                    var s = i.getUint32(r, !0);
                    if (r += 4, s === c) {
                        var u = new Uint8Array(t, 12 + r, o);
                        this.content = qu(u)
                    } else if (s === l) {
                        var h = 12 + r;
                        this.body = t.slice(h, h + o)
                    }
                    r += o
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }

            function h(t, e) {
                if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = n.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
            }

            function p() {
                this.name = n.KHR_TEXTURE_TRANSFORM
            }

            function f(t) {
                El.call(this), this.isGLTFSpecularGlossinessMaterial = !0;
                var e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                    n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                    i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                    r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                    o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"),
                    s = {
                        specular: {
                            value: (new Ni).setHex(16777215)
                        },
                        glossiness: {
                            value: 1
                        },
                        specularMap: {
                            value: null
                        },
                        glossinessMap: {
                            value: null
                        }
                    };
                this._extraUniforms = s, this.onBeforeCompile = function(t) {
                    for (var a in s) t.uniforms[a] = s[a];
                    t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;"), t.fragmentShader = t.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;"), t.fragmentShader = t.fragmentShader.replace("#include <roughnessmap_pars_fragment>", e), t.fragmentShader = t.fragmentShader.replace("#include <metalnessmap_pars_fragment>", n), t.fragmentShader = t.fragmentShader.replace("#include <roughnessmap_fragment>", i), t.fragmentShader = t.fragmentShader.replace("#include <metalnessmap_fragment>", r), t.fragmentShader = t.fragmentShader.replace("#include <lights_physical_fragment>", o)
                }, Object.defineProperties(this, {
                    specular: {
                        get: function() {
                            return s.specular.value
                        },
                        set: function(t) {
                            s.specular.value = t
                        }
                    },
                    specularMap: {
                        get: function() {
                            return s.specularMap.value
                        },
                        set: function(t) {
                            s.specularMap.value = t
                        }
                    },
                    glossiness: {
                        get: function() {
                            return s.glossiness.value
                        },
                        set: function(t) {
                            s.glossiness.value = t
                        }
                    },
                    glossinessMap: {
                        get: function() {
                            return s.glossinessMap.value
                        },
                        set: function(t) {
                            s.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_ROUGHNESSMAP = "") : (delete this.defines.USE_ROUGHNESSMAP, delete this.defines.USE_GLOSSINESSMAP)
                        }
                    }
                }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
            }

            function d() {
                return {
                    name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                    specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                    getMaterialType: function() {
                        return f
                    },
                    extendParams: function(t, e, n) {
                        var i = e.extensions[this.name];
                        t.color = new Ni(1, 1, 1), t.opacity = 1;
                        var r = [];
                        if (Array.isArray(i.diffuseFactor)) {
                            var o = i.diffuseFactor;
                            t.color.fromArray(o), t.opacity = o[3]
                        }
                        if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, "map", i.diffuseTexture)), t.emissive = new Ni(0, 0, 0), t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, t.specular = new Ni(1, 1, 1), Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                            var s = i.specularGlossinessTexture;
                            r.push(n.assignTexture(t, "glossinessMap", s)), r.push(n.assignTexture(t, "specularMap", s))
                        }
                        return Promise.all(r)
                    },
                    createMaterial: function(t) {
                        var e = new f(t);
                        return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = 0, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e
                    }
                }
            }

            function m() {
                this.name = n.KHR_MESH_QUANTIZATION
            }

            function g(t, e, n, i) {
                kl.call(this, t, e, n, i)
            }
            h.prototype.decodePrimitive = function(t, e) {
                var n = this.json,
                    i = this.dracoLoader,
                    r = t.extensions[this.name].bufferView,
                    o = t.extensions[this.name].attributes,
                    s = {},
                    a = {},
                    c = {};
                for (var l in o) {
                    var u = A[l] || l.toLowerCase();
                    s[u] = o[l]
                }
                for (l in t.attributes) {
                    u = A[l] || l.toLowerCase();
                    if (void 0 !== o[l]) {
                        var h = n.accessors[t.attributes[l]],
                            p = S[h.componentType];
                        c[u] = p, a[u] = !0 === h.normalized
                    }
                }
                return e.getDependency("bufferView", r).then((function(t) {
                    return new Promise((function(e) {
                        i.decodeDracoFile(t, (function(t) {
                            for (var n in t.attributes) {
                                var i = t.attributes[n],
                                    r = a[n];
                                void 0 !== r && (i.normalized = r)
                            }
                            e(t)
                        }), s, c)
                    }))
                }))
            }, p.prototype.extendTexture = function(t, e) {
                return t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.needsUpdate = !0, t
            }, f.prototype = Object.create(El.prototype), f.prototype.constructor = f, f.prototype.copy = function(t) {
                return El.prototype.copy.call(this, t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
            }, g.prototype = Object.create(kl.prototype), g.prototype.constructor = g, g.prototype.copySampleValue_ = function(t) {
                for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i * 3 + i, o = 0; o !== i; o++) e[o] = n[r + o];
                return e
            }, g.prototype.beforeStart_ = g.prototype.copySampleValue_, g.prototype.afterEnd_ = g.prototype.copySampleValue_, g.prototype.interpolate_ = function(t, e, n, i) {
                for (var r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = 2 * s, c = 3 * s, l = i - e, u = (n - e) / l, h = u * u, p = h * u, f = t * c, d = f - c, m = -2 * p + 3 * h, g = p - h, v = 1 - m, y = g - h + u, b = 0; b !== s; b++) {
                    var x = o[d + b + s],
                        w = o[d + b + a] * l,
                        _ = o[f + b + s],
                        M = o[f + b] * l;
                    r[b] = v * x + y * w + m * _ + g * M
                }
                return r
            };
            var v = 0,
                y = 1,
                b = 2,
                x = 3,
                w = 4,
                _ = 5,
                M = 6,
                S = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                },
                T = {
                    9728: 1003,
                    9729: 1006,
                    9984: 1004,
                    9985: 1007,
                    9986: 1005,
                    9987: 1008
                },
                E = {
                    33071: 1001,
                    33648: 1002,
                    10497: 1e3
                },
                C = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                },
                A = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv2",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                },
                L = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                },
                P = {
                    CUBICSPLINE: void 0,
                    LINEAR: 2301,
                    STEP: 2300
                },
                O = "OPAQUE",
                R = "MASK",
                I = "BLEND",
                D = {
                    "image/png": 1023,
                    "image/jpeg": 1022
                };

            function N(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }

            function k(t, e, n) {
                for (var i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i])
            }

            function U(t, e) {
                void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
            }

            function B(t, e) {
                if (t.updateMorphTargets(), void 0 !== e.weights)
                    for (var n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
                if (e.extras && Array.isArray(e.extras.targetNames)) {
                    var r = e.extras.targetNames;
                    if (t.morphTargetInfluences.length === r.length) {
                        t.morphTargetDictionary = {};
                        for (n = 0, i = r.length; n < i; n++) t.morphTargetDictionary[r[n]] = n
                    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                }
            }

            function z(t) {
                for (var e = "", n = Object.keys(t).sort(), i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
                return e
            }

            function F(t, n) {
                this.json = t || {}, this.extensions = {}, this.plugins = {}, this.options = n || {}, this.cache = new e, this.associations = new Map, this.primitiveCache = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new nh(this.options.manager) : this.textureLoader = new au(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new eu(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }

            function j(t, e, n) {
                var i = e.attributes,
                    r = [];

                function o(e, i) {
                    return n.getDependency("accessor", e).then((function(e) {
                        t.setAttribute(i, e)
                    }))
                }
                for (var s in i) {
                    var a = A[s] || s.toLowerCase();
                    a in t.attributes || r.push(o(i[s], a))
                }
                if (void 0 !== e.indices && !t.index) {
                    var c = n.getDependency("accessor", e.indices).then((function(e) {
                        t.setIndex(e)
                    }));
                    r.push(c)
                }
                return U(t, e),
                    function(t, e, n) {
                        var i = e.attributes,
                            r = new oi;
                        if (void 0 !== i.POSITION) {
                            var o = (f = n.json.accessors[i.POSITION]).min,
                                s = f.max;
                            if (void 0 !== o && void 0 !== s) {
                                r.set(new yn(o[0], o[1], o[2]), new yn(s[0], s[1], s[2]));
                                var a = e.targets;
                                if (void 0 !== a) {
                                    for (var c = new yn, l = new yn, u = 0, h = a.length; u < h; u++) {
                                        var p = a[u];
                                        if (void 0 !== p.POSITION) {
                                            var f;
                                            o = (f = n.json.accessors[p.POSITION]).min, s = f.max;
                                            void 0 !== o && void 0 !== s ? (l.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))), l.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))), l.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))), c.max(l)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                        }
                                    }
                                    r.expandByVector(c)
                                }
                                t.boundingBox = r;
                                var d = new ci;
                                r.getCenter(d.center), d.radius = r.min.distanceTo(r.max) / 2, t.boundingSphere = d
                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }(t, e, n), Promise.all(r).then((function() {
                        return void 0 !== e.targets ? function(t, e, n) {
                            for (var i = !1, r = !1, o = 0, s = e.length; o < s; o++) {
                                if (void 0 !== (l = e[o]).POSITION && (i = !0), void 0 !== l.NORMAL && (r = !0), i && r) break
                            }
                            if (!i && !r) return Promise.resolve(t);
                            var a = [],
                                c = [];
                            for (o = 0, s = e.length; o < s; o++) {
                                var l = e[o];
                                if (i) {
                                    var u = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position;
                                    a.push(u)
                                }
                                if (r) {
                                    u = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                                    c.push(u)
                                }
                            }
                            return Promise.all([Promise.all(a), Promise.all(c)]).then((function(e) {
                                var n = e[0],
                                    o = e[1];
                                return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = o), t.morphTargetsRelative = !0, t
                            }))
                        }(t, e.targets, n) : t
                    }))
            }

            function H(t, e) {
                var n = t.getIndex();
                if (null === n) {
                    var i = [],
                        r = t.getAttribute("position");
                    if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                    for (var o = 0; o < r.count; o++) i.push(o);
                    t.setIndex(i), n = t.getIndex()
                }
                var s = n.count - 2,
                    a = [];
                if (2 === e)
                    for (o = 1; o <= s; o++) a.push(n.getX(0)), a.push(n.getX(o)), a.push(n.getX(o + 1));
                else
                    for (o = 0; o < s; o++) o % 2 == 0 ? (a.push(n.getX(o)), a.push(n.getX(o + 1)), a.push(n.getX(o + 2))) : (a.push(n.getX(o + 2)), a.push(n.getX(o + 1)), a.push(n.getX(o)));
                a.length / 3 !== s && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                var c = t.clone();
                return c.setIndex(a), c
            }
            return F.prototype.setExtensions = function(t) {
                this.extensions = t
            }, F.prototype.setPlugins = function(t) {
                this.plugins = t
            }, F.prototype.parse = function(t, e) {
                var n = this,
                    i = this.json,
                    r = this.extensions;
                this.cache.removeAll(), this.markDefs(), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function(e) {
                    var o = {
                        scene: e[0][i.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    k(r, o, i), U(o, i), t(o)
                })).catch(e)
            }, F.prototype.markDefs = function() {
                for (var t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [], i = {}, r = {}, o = 0, s = e.length; o < s; o++)
                    for (var a = e[o].joints, c = 0, l = a.length; c < l; c++) t[a[c]].isBone = !0;
                for (var u = 0, h = t.length; u < h; u++) {
                    var p = t[u];
                    void 0 !== p.mesh && (void 0 === i[p.mesh] && (i[p.mesh] = r[p.mesh] = 0), i[p.mesh]++, void 0 !== p.skin && (n[p.mesh].isSkinnedMesh = !0))
                }
                this.json.meshReferences = i, this.json.meshUses = r
            }, F.prototype._invokeOne = function(t) {
                var e = Object.values(this.plugins);
                e.push(this);
                for (var n = 0; n < e.length; n++) {
                    var i = t(e[n]);
                    if (i) return i
                }
            }, F.prototype._invokeAll = function(t) {
                var e = Object.values(this.plugins);
                e.unshift(this);
                for (var n = [], i = 0; i < e.length; i++) n.push(t(e[i]));
                return Promise.all(n)
            }, F.prototype.getDependency = function(t, e) {
                var i = t + ":" + e,
                    r = this.cache.get(i);
                if (!r) {
                    switch (t) {
                        case "scene":
                            r = this.loadScene(e);
                            break;
                        case "node":
                            r = this.loadNode(e);
                            break;
                        case "mesh":
                            r = this._invokeOne((function(t) {
                                return t.loadMesh && t.loadMesh(e)
                            }));
                            break;
                        case "accessor":
                            r = this.loadAccessor(e);
                            break;
                        case "bufferView":
                            r = this._invokeOne((function(t) {
                                return t.loadBufferView && t.loadBufferView(e)
                            }));
                            break;
                        case "buffer":
                            r = this.loadBuffer(e);
                            break;
                        case "material":
                            r = this._invokeOne((function(t) {
                                return t.loadMaterial && t.loadMaterial(e)
                            }));
                            break;
                        case "texture":
                            r = this.loadTexture(e);
                            break;
                        case "skin":
                            r = this.loadSkin(e);
                            break;
                        case "animation":
                            r = this.loadAnimation(e);
                            break;
                        case "camera":
                            r = this.loadCamera(e);
                            break;
                        case "light":
                            r = this.extensions[n.KHR_LIGHTS_PUNCTUAL].loadLight(e);
                            break;
                        default:
                            throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(i, r)
                }
                return r
            }, F.prototype.getDependencies = function(t) {
                var e = this.cache.get(t);
                if (!e) {
                    var n = this,
                        i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                    e = Promise.all(i.map((function(e, i) {
                        return n.getDependency(t, i)
                    }))), this.cache.add(t, e)
                }
                return e
            }, F.prototype.loadBuffer = function(t) {
                var e = this.json.buffers[t],
                    i = this.fileLoader;
                if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
                var r = this.options;
                return new Promise((function(t, n) {
                    i.load(N(e.uri, r.path), t, void 0, (function() {
                        n(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                    }))
                }))
            }, F.prototype.loadBufferView = function(t) {
                var e = this.json.bufferViews[t];
                return this.getDependency("buffer", e.buffer).then((function(t) {
                    var n = e.byteLength || 0,
                        i = e.byteOffset || 0;
                    return t.slice(i, i + n)
                }))
            }, F.prototype.loadAccessor = function(t) {
                var e = this,
                    n = this.json,
                    i = this.json.accessors[t];
                if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                var r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(t) {
                    var r, o = t[0],
                        s = C[i.type],
                        a = S[i.componentType],
                        c = a.BYTES_PER_ELEMENT,
                        l = c * s,
                        u = i.byteOffset || 0,
                        h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                        p = !0 === i.normalized;
                    if (h && h !== l) {
                        var f = Math.floor(u / h),
                            d = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + f + ":" + i.count,
                            m = e.cache.get(d);
                        m || (m = new ca(new a(o, f * h, i.count * h / c), h / c), e.cache.add(d, m)), r = new ua(m, s, u % h / c, p)
                    } else r = new Wi(null === o ? new a(i.count * s) : new a(o, u, i.count * s), s, p);
                    if (void 0 !== i.sparse) {
                        var g = C.SCALAR,
                            v = S[i.sparse.indices.componentType],
                            y = i.sparse.indices.byteOffset || 0,
                            b = i.sparse.values.byteOffset || 0,
                            x = new v(t[1], y, i.sparse.count * g),
                            w = new a(t[2], b, i.sparse.count * s);
                        null !== o && (r = new Wi(r.array.slice(), r.itemSize, r.normalized));
                        for (var _ = 0, M = x.length; _ < M; _++) {
                            var T = x[_];
                            if (r.setX(T, w[_ * s]), s >= 2 && r.setY(T, w[_ * s + 1]), s >= 3 && r.setZ(T, w[_ * s + 2]), s >= 4 && r.setW(T, w[_ * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return r
                }))
            }, F.prototype.loadTexture = function(t) {
                var e, i = this,
                    r = this.json,
                    o = this.options,
                    s = this.textureLoader,
                    a = self.URL || self.webkitURL,
                    c = r.textures[t],
                    l = c.extensions || {},
                    u = (e = l[n.MSFT_TEXTURE_DDS] ? r.images[l[n.MSFT_TEXTURE_DDS].source] : r.images[c.source]).uri,
                    h = !1;
                return void 0 !== e.bufferView && (u = i.getDependency("bufferView", e.bufferView).then((function(t) {
                    h = !0;
                    var n = new Blob([t], {
                        type: e.mimeType
                    });
                    return u = a.createObjectURL(n)
                }))), Promise.resolve(u).then((function(t) {
                    var e = o.manager.getHandler(t);
                    return e || (e = l[n.MSFT_TEXTURE_DDS] ? i.extensions[n.MSFT_TEXTURE_DDS].ddsLoader : s), new Promise((function(n, i) {
                        var r = n;
                        !0 === e.isImageBitmapLoader && (r = function(t) {
                            n(new sc(t))
                        }), e.load(N(t, o.path), r, void 0, i)
                    }))
                })).then((function(n) {
                    !0 === h && a.revokeObjectURL(u), n.flipY = !1, c.name && (n.name = c.name), e.mimeType in D && (n.format = D[e.mimeType]);
                    var o = (r.samplers || {})[c.sampler] || {};
                    return n.magFilter = T[o.magFilter] || 1006, n.minFilter = T[o.minFilter] || 1008, n.wrapS = E[o.wrapS] || 1e3, n.wrapT = E[o.wrapT] || 1e3, i.associations.set(n, {
                        type: "textures",
                        index: t
                    }), n
                }))
            }, F.prototype.assignTexture = function(t, e, i) {
                var r = this;
                return this.getDependency("texture", i.index).then((function(o) {
                    if (!o.isCompressedTexture) switch (e) {
                        case "aoMap":
                        case "emissiveMap":
                        case "metalnessMap":
                        case "normalMap":
                        case "roughnessMap":
                            o.format = 1022
                    }
                    if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === e && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + e + " not yet supported."), r.extensions[n.KHR_TEXTURE_TRANSFORM]) {
                        var s = void 0 !== i.extensions ? i.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (s) {
                            var a = r.associations.get(o);
                            o = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(o, s), r.associations.set(o, a)
                        }
                    }
                    t[e] = o
                }))
            }, F.prototype.assignFinalMaterial = function(t) {
                var e = t.geometry,
                    n = t.material,
                    i = void 0 !== e.attributes.tangent,
                    r = void 0 !== e.attributes.color,
                    o = void 0 === e.attributes.normal,
                    s = !0 === t.isSkinnedMesh,
                    a = Object.keys(e.morphAttributes).length > 0,
                    c = a && void 0 !== e.morphAttributes.normal;
                if (t.isPoints) {
                    var l = "PointsMaterial:" + n.uuid,
                        u = this.cache.get(l);
                    u || (u = new Ja, ji.prototype.copy.call(u, n), u.color.copy(n.color), u.map = n.map, u.sizeAttenuation = !1, this.cache.add(l, u)), n = u
                } else if (t.isLine) {
                    l = "LineBasicMaterial:" + n.uuid;
                    var h = this.cache.get(l);
                    h || (h = new Fa, ji.prototype.copy.call(h, n), h.color.copy(n.color), this.cache.add(l, h)), n = h
                }
                if (i || r || o || s || a) {
                    l = "ClonedMaterial:" + n.uuid + ":";
                    n.isGLTFSpecularGlossinessMaterial && (l += "specular-glossiness:"), s && (l += "skinning:"), i && (l += "vertex-tangents:"), r && (l += "vertex-colors:"), o && (l += "flat-shading:"), a && (l += "morph-targets:"), c && (l += "morph-normals:");
                    var p = this.cache.get(l);
                    p || (p = n.clone(), s && (p.skinning = !0), i && (p.vertexTangents = !0), r && (p.vertexColors = !0), o && (p.flatShading = !0), a && (p.morphTargets = !0), c && (p.morphNormals = !0), this.cache.add(l, p), this.associations.set(p, this.associations.get(n))), n = p
                }
                n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), n.normalScale && !i && (n.normalScale.y = -n.normalScale.y), n.clearcoatNormalScale && !i && (n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y), t.material = n
            }, F.prototype.getMaterialType = function() {
                return El
            }, F.prototype.loadMaterial = function(t) {
                var e, i = this,
                    r = this.json,
                    o = this.extensions,
                    s = r.materials[t],
                    a = {},
                    c = s.extensions || {},
                    l = [];
                if (c[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                    var u = o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    e = u.getMaterialType(), l.push(u.extendParams(a, s, i))
                } else if (c[n.KHR_MATERIALS_UNLIT]) {
                    var h = o[n.KHR_MATERIALS_UNLIT];
                    e = h.getMaterialType(), l.push(h.extendParams(a, s, i))
                } else {
                    var p = s.pbrMetallicRoughness || {};
                    if (a.color = new Ni(1, 1, 1), a.opacity = 1, Array.isArray(p.baseColorFactor)) {
                        var d = p.baseColorFactor;
                        a.color.fromArray(d), a.opacity = d[3]
                    }
                    void 0 !== p.baseColorTexture && l.push(i.assignTexture(a, "map", p.baseColorTexture)), a.metalness = void 0 !== p.metallicFactor ? p.metallicFactor : 1, a.roughness = void 0 !== p.roughnessFactor ? p.roughnessFactor : 1, void 0 !== p.metallicRoughnessTexture && (l.push(i.assignTexture(a, "metalnessMap", p.metallicRoughnessTexture)), l.push(i.assignTexture(a, "roughnessMap", p.metallicRoughnessTexture))), e = this._invokeOne((function(e) {
                        return e.getMaterialType && e.getMaterialType(t)
                    })), l.push(this._invokeAll((function(e) {
                        return e.extendMaterialParams && e.extendMaterialParams(t, a)
                    })))
                }!0 === s.doubleSided && (a.side = 2);
                var m = s.alphaMode || O;
                return m === I ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, m === R && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && e !== Hi && (l.push(i.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new sn(1, 1), void 0 !== s.normalTexture.scale && a.normalScale.set(s.normalTexture.scale, s.normalTexture.scale)), void 0 !== s.occlusionTexture && e !== Hi && (l.push(i.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && e !== Hi && (a.emissive = (new Ni).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && e !== Hi && l.push(i.assignTexture(a, "emissiveMap", s.emissiveTexture)), Promise.all(l).then((function() {
                    var r;
                    return r = e === f ? o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new e(a), s.name && (r.name = s.name), r.map && (r.map.encoding = 3001), r.emissiveMap && (r.emissiveMap.encoding = 3001), U(r, s), i.associations.set(r, {
                        type: "materials",
                        index: t
                    }), s.extensions && k(o, r, s), r
                }))
            }, F.prototype.loadGeometries = function(t) {
                var e = this,
                    i = this.extensions,
                    r = this.primitiveCache;

                function o(t) {
                    return i[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                        return j(n, t, e)
                    }))
                }
                for (var s, a, c = [], l = 0, u = t.length; l < u; l++) {
                    var h, p = t[l],
                        f = (a = void 0, (a = (s = p).extensions && s.extensions[n.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + a.bufferView + ":" + a.indices + ":" + z(a.attributes) : s.indices + ":" + z(s.attributes) + ":" + s.mode),
                        d = r[f];
                    if (d) c.push(d.promise);
                    else h = p.extensions && p.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? o(p) : j(new ur, p, e), r[f] = {
                        primitive: p,
                        promise: h
                    }, c.push(h)
                }
                return Promise.all(c)
            }, F.prototype.loadMesh = function(t) {
                for (var e, n = this, i = this.json.meshes[t], r = i.primitives, o = [], s = 0, a = r.length; s < a; s++) {
                    var c = void 0 === r[s].material ? (void 0 === (e = this.cache).DefaultMaterial && (e.DefaultMaterial = new El({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0
                    })), e.DefaultMaterial) : this.getDependency("material", r[s].material);
                    o.push(c)
                }
                return o.push(n.loadGeometries(r)), Promise.all(o).then((function(e) {
                    for (var o = e.slice(0, e.length - 1), s = e[e.length - 1], a = [], c = 0, l = s.length; c < l; c++) {
                        var u, h = s[c],
                            p = r[c],
                            f = o[c];
                        if (p.mode === w || p.mode === _ || p.mode === M || void 0 === p.mode) !0 !== (u = !0 === i.isSkinnedMesh ? new Pa(h, f) : new Ar(h, f)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), p.mode === _ ? u.geometry = H(u.geometry, 1) : p.mode === M && (u.geometry = H(u.geometry, 2));
                        else if (p.mode === y) u = new Ya(h, f);
                        else if (p.mode === x) u = new qa(h, f);
                        else if (p.mode === b) u = new $a(h, f);
                        else {
                            if (p.mode !== v) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                            u = new nc(h, f)
                        }
                        Object.keys(u.geometry.morphAttributes).length > 0 && B(u, i), u.name = i.name || "mesh_" + t, s.length > 1 && (u.name += "_" + c), U(u, i), n.assignFinalMaterial(u), a.push(u)
                    }
                    if (1 === a.length) return a[0];
                    var d = new ta;
                    for (c = 0, l = a.length; c < l; c++) d.add(a[c]);
                    return d
                }))
            }, F.prototype.loadCamera = function(t) {
                var e, n = this.json.cameras[t],
                    i = n[n.type];
                if (i) return "perspective" === n.type ? e = new Gr(on.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new Bu(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = n.name), U(e, n), Promise.resolve(e);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }, F.prototype.loadSkin = function(t) {
                var e = this.json.skins[t],
                    n = {
                        joints: e.joints
                    };
                return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                    return n.inverseBindMatrices = t, n
                }))
            }, F.prototype.loadAnimation = function(t) {
                for (var e = this.json.animations[t], n = [], i = [], r = [], o = [], s = [], a = 0, c = e.channels.length; a < c; a++) {
                    var l = e.channels[a],
                        u = e.samplers[l.sampler],
                        h = l.target,
                        p = void 0 !== h.node ? h.node : h.id,
                        f = void 0 !== e.parameters ? e.parameters[u.input] : u.input,
                        d = void 0 !== e.parameters ? e.parameters[u.output] : u.output;
                    n.push(this.getDependency("node", p)), i.push(this.getDependency("accessor", f)), r.push(this.getDependency("accessor", d)), o.push(u), s.push(h)
                }
                return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(o), Promise.all(s)]).then((function(n) {
                    for (var i = n[0], r = n[1], o = n[2], s = n[3], a = n[4], c = [], l = 0, u = i.length; l < u; l++) {
                        var h = i[l],
                            p = r[l],
                            f = o[l],
                            d = s[l],
                            m = a[l];
                        if (void 0 !== h) {
                            var v;
                            switch (h.updateMatrix(), h.matrixAutoUpdate = !0, L[m.path]) {
                                case L.weights:
                                    v = Gl;
                                    break;
                                case L.rotation:
                                    v = Wl;
                                    break;
                                case L.position:
                                case L.scale:
                                default:
                                    v = Xl
                            }
                            var y = h.name ? h.name : h.uuid,
                                b = void 0 !== d.interpolation ? P[d.interpolation] : 2301,
                                x = [];
                            L[m.path] === L.weights ? h.traverse((function(t) {
                                !0 === t.isMesh && t.morphTargetInfluences && x.push(t.name ? t.name : t.uuid)
                            })) : x.push(y);
                            var w = f.array;
                            if (f.normalized) {
                                var _;
                                if (w.constructor === Int8Array) _ = 1 / 127;
                                else if (w.constructor === Uint8Array) _ = 1 / 255;
                                else if (w.constructor == Int16Array) _ = 1 / 32767;
                                else {
                                    if (w.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                    _ = 1 / 65535
                                }
                                for (var M = new Float32Array(w.length), S = 0, T = w.length; S < T; S++) M[S] = w[S] * _;
                                w = M
                            }
                            for (S = 0, T = x.length; S < T; S++) {
                                var E = new v(x[S] + "." + L[m.path], p.array, w, b);
                                "CUBICSPLINE" === d.interpolation && (E.createInterpolant = function(t) {
                                    return new g(this.times, this.values, this.getValueSize() / 3, t)
                                }, E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(E)
                            }
                        }
                    }
                    return new Zl(e.name ? e.name : "animation_" + t, void 0, c)
                }))
            }, F.prototype.loadNode = function(t) {
                var e, i = this.json,
                    r = this.extensions,
                    o = this,
                    s = i.meshReferences,
                    a = i.meshUses,
                    c = i.nodes[t];
                return (e = [], void 0 !== c.mesh && e.push(o.getDependency("mesh", c.mesh).then((function(t) {
                    var e;
                    if (s[c.mesh] > 1) {
                        var n = a[c.mesh]++;
                        (e = t.clone()).name += "_instance_" + n
                    } else e = t;
                    return void 0 !== c.weights && e.traverse((function(t) {
                        if (t.isMesh)
                            for (var e = 0, n = c.weights.length; e < n; e++) t.morphTargetInfluences[e] = c.weights[e]
                    })), e
                }))), void 0 !== c.camera && e.push(o.getDependency("camera", c.camera)), c.extensions && c.extensions[n.KHR_LIGHTS_PUNCTUAL] && void 0 !== c.extensions[n.KHR_LIGHTS_PUNCTUAL].light && e.push(o.getDependency("light", c.extensions[n.KHR_LIGHTS_PUNCTUAL].light)), Promise.all(e)).then((function(e) {
                    var n;
                    if ((n = !0 === c.isBone ? new Da : e.length > 1 ? new ta : 1 === e.length ? e[0] : new Vn) !== e[0])
                        for (var i = 0, s = e.length; i < s; i++) n.add(e[i]);
                    if (c.name && (n.userData.name = c.name, n.name = Uh.sanitizeNodeName(c.name)), U(n, c), c.extensions && k(r, n, c), void 0 !== c.matrix) {
                        var a = new En;
                        a.fromArray(c.matrix), n.applyMatrix4(a)
                    } else void 0 !== c.translation && n.position.fromArray(c.translation), void 0 !== c.rotation && n.quaternion.fromArray(c.rotation), void 0 !== c.scale && n.scale.fromArray(c.scale);
                    return o.associations.set(n, {
                        type: "nodes",
                        index: t
                    }), n
                }))
            }, F.prototype.loadScene = function() {
                function t(e, n, i, r) {
                    var o = i.nodes[e];
                    return r.getDependency("node", e).then((function(t) {
                        return void 0 === o.skin ? t : r.getDependency("skin", o.skin).then((function(t) {
                            for (var n = [], i = 0, o = (e = t).joints.length; i < o; i++) n.push(r.getDependency("node", e.joints[i]));
                            return Promise.all(n)
                        })).then((function(n) {
                            return t.traverse((function(t) {
                                if (t.isMesh) {
                                    for (var i = [], r = [], o = 0, s = n.length; o < s; o++) {
                                        var a = n[o];
                                        if (a) {
                                            i.push(a);
                                            var c = new En;
                                            void 0 !== e.inverseBindMatrices && c.fromArray(e.inverseBindMatrices.array, 16 * o), r.push(c)
                                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[o])
                                    }
                                    t.bind(new Ia(i, r), t.matrixWorld)
                                }
                            })), t
                        }));
                        var e
                    })).then((function(e) {
                        n.add(e);
                        var s = [];
                        if (o.children)
                            for (var a = o.children, c = 0, l = a.length; c < l; c++) {
                                var u = a[c];
                                s.push(t(u, e, i, r))
                            }
                        return Promise.all(s)
                    }))
                }
                return function(e) {
                    var n = this.json,
                        i = this.extensions,
                        r = this.json.scenes[e],
                        o = new ta;
                    r.name && (o.name = r.name), U(o, r), r.extensions && k(i, o, r);
                    for (var s = r.nodes || [], a = [], c = 0, l = s.length; c < l; c++) a.push(t(s[c], o, n, this));
                    return Promise.all(a).then((function() {
                        return o
                    }))
                }
            }(), t
        }();

    function Mm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Sm = function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.type = "gltf", this.loader = new _m
        }
        var e, n, i;
        return e = t, (n = [{
            key: "resolve",
            value: function(t) {
                var e = this;
                return new Promise((function(n) {
                    e.loader.load(t.url, (function(e) {
                        n(Object.assign(t, {
                            gltf: e
                        }))
                    }))
                }))
            }
        }, {
            key: "get",
            value: function(t) {
                return t.gltf.scene
            }
        }]) && Mm(e.prototype, n), i && Mm(e, i), t
    }();

    function Tm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Em = function() {
        function t(e) {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.type = "texture", this.renderer = e, this.loader = new au
        }
        var e, n, i;
        return e = t, (n = [{
            key: "resolve",
            value: function(t) {
                var e = this;
                return new Promise((function(n) {
                    e.loader.load(t.url, (function(i) {
                        e.renderer && (t.linear && (i.minFilter = i.magFilter = 1006), e.renderer.initTexture(i)), n(Object.assign(t, {
                            texture: i
                        }))
                    }))
                }))
            }
        }, {
            key: "get",
            value: function(t) {
                return t.texture
            }
        }]) && Tm(e.prototype, n), i && Tm(e, i), t
    }();

    function Cm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Am = function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.type = "image"
        }
        var e, n, i;
        return e = t, (n = [{
            key: "resolve",
            value: function(t) {
                return new Promise((function(e) {
                    var n = new Image;
                    n.onload = function() {
                        e(Object.assign(t, {
                            image: n
                        }))
                    }, n.src = t.url
                }))
            }
        }, {
            key: "get",
            value: function(t) {
                return t.image
            }
        }]) && Cm(e.prototype, n), i && Cm(e, i), t
    }();

    function Lm(t) {
        var e = "function" == typeof Map ? new Map : void 0;
        return (Lm = function(t) {
            if (null === t || (n = t, -1 === Function.toString.call(n).indexOf("[native code]"))) return t;
            var n;
            if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== e) {
                if (e.has(t)) return e.get(t);
                e.set(t, i)
            }

            function i() {
                return Pm(t, arguments, Gm(this).constructor)
            }
            return i.prototype = Object.create(t.prototype, {
                constructor: {
                    value: i,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), Bm(i, t)
        })(t)
    }

    function Pm(t, e, n) {
        return (Pm = Hm() ? Reflect.construct : function(t, e, n) {
            var i = [null];
            i.push.apply(i, e);
            var r = new(Function.bind.apply(t, i));
            return n && Bm(r, n.prototype), r
        }).apply(null, arguments)
    }

    function Om(t, e, n, i) {
        return (Om = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(t, e, n, i) {
            var r, o = Im(t, e);
            if (o) {
                if ((r = Object.getOwnPropertyDescriptor(o, e)).set) return r.set.call(i, n), !0;
                if (!r.writable) return !1
            }
            if (r = Object.getOwnPropertyDescriptor(i, e)) {
                if (!r.writable) return !1;
                r.value = n, Object.defineProperty(i, e, r)
            } else ! function(t, e, n) {
                e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n
            }(i, e, n);
            return !0
        })(t, e, n, i)
    }

    function Rm(t, e, n) {
        return (Rm = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
            var i = Im(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        })(t, e, n || t)
    }

    function Im(t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Gm(t)););
        return t
    }

    function Dm(t, e) {
        var n;
        if ("undefined" == typeof Symbol || null == t[Symbol.iterator]) {
            if (Array.isArray(t) || (n = function(t, e) {
                    if (!t) return;
                    if ("string" == typeof t) return Nm(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === n && t.constructor && (n = t.constructor.name);
                    if ("Map" === n || "Set" === n) return Array.from(t);
                    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Nm(t, e)
                }(t)) || e && t && "number" == typeof t.length) {
                n && (t = n);
                var i = 0,
                    r = function() {};
                return {
                    s: r,
                    n: function() {
                        return i >= t.length ? {
                            done: !0
                        } : {
                            done: !1,
                            value: t[i++]
                        }
                    },
                    e: function(t) {
                        throw t
                    },
                    f: r
                }
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }
        var o, s = !0,
            a = !1;
        return {
            s: function() {
                n = t[Symbol.iterator]()
            },
            n: function() {
                var t = n.next();
                return s = t.done, t
            },
            e: function(t) {
                a = !0, o = t
            },
            f: function() {
                try {
                    s || null == n.return || n.return()
                } finally {
                    if (a) throw o
                }
            }
        }
    }

    function Nm(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function km(t) {
        return (km = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Um(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                writable: !0,
                configurable: !0
            }
        }), e && Bm(t, e)
    }

    function Bm(t, e) {
        return (Bm = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function zm(t) {
        var e = Hm();
        return function() {
            var n, i = Gm(t);
            if (e) {
                var r = Gm(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Fm(this, n)
        }
    }

    function Fm(t, e) {
        return !e || "object" !== km(e) && "function" != typeof e ? jm(t) : e
    }

    function jm(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Hm() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
        } catch (t) {
            return !1
        }
    }

    function Gm(t) {
        return (Gm = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }

    function Vm(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Wm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function qm(t, e, n) {
        return e && Wm(t.prototype, e), n && Wm(t, n), t
    }
    var Xm = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
        Zm = (new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]), function(t) {
            Um(n, t);
            var e = zm(n);

            function n() {
                var t;
                return Vm(this, n), (t = e.call(this, {
                    type: "CopyMaterial",
                    uniforms: {
                        inputBuffer: new Fh(null),
                        opacity: new Fh(1)
                    },
                    fragmentShader: "uniform sampler2D inputBuffer;uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n}",
                    vertexShader: Xm,
                    depthWrite: !1,
                    depthTest: !1
                })).toneMapped = !1, t
            }
            return n
        }(jr)),
        Ym = function(t) {
            Um(n, t);
            var e = zm(n);

            function n() {
                var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                return Vm(this, n), (t = e.call(this, {
                    type: "EffectMaterial",
                    defines: {
                        DEPTH_PACKING: "0",
                        ENCODE_OUTPUT: "1"
                    },
                    uniforms: {
                        inputBuffer: new Fh(null),
                        depthBuffer: new Fh(null),
                        resolution: new Fh(new sn),
                        texelSize: new Fh(new sn),
                        cameraNear: new Fh(.3),
                        cameraFar: new Fh(1e3),
                        aspect: new Fh(1),
                        time: new Fh(0)
                    },
                    depthWrite: !1,
                    depthTest: !1,
                    dithering: a
                })).toneMapped = !1, null !== i && t.setShaderParts(i), null !== r && t.setDefines(r), null !== o && t.setUniforms(o), t.adoptCameraSettings(s), t
            }
            return qm(n, [{
                key: "setShaderParts",
                value: function(t) {
                    return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\nuniform sampler2D inputBuffer;\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}".replace($m.FRAGMENT_HEAD, t.get($m.FRAGMENT_HEAD)).replace($m.FRAGMENT_MAIN_UV, t.get($m.FRAGMENT_MAIN_UV)).replace($m.FRAGMENT_MAIN_IMAGE, t.get($m.FRAGMENT_MAIN_IMAGE)), this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}".replace($m.VERTEX_HEAD, t.get($m.VERTEX_HEAD)).replace($m.VERTEX_MAIN_SUPPORT, t.get($m.VERTEX_MAIN_SUPPORT)), this.needsUpdate = !0, this
                }
            }, {
                key: "setDefines",
                value: function(t) {
                    var e, n = Dm(t.entries());
                    try {
                        for (n.s(); !(e = n.n()).done;) {
                            var i = e.value;
                            this.defines[i[0]] = i[1]
                        }
                    } catch (t) {
                        n.e(t)
                    } finally {
                        n.f()
                    }
                    return this.needsUpdate = !0, this
                }
            }, {
                key: "setUniforms",
                value: function(t) {
                    var e, n = Dm(t.entries());
                    try {
                        for (n.s(); !(e = n.n()).done;) {
                            var i = e.value;
                            this.uniforms[i[0]] = i[1]
                        }
                    } catch (t) {
                        n.e(t)
                    } finally {
                        n.f()
                    }
                    return this
                }
            }, {
                key: "adoptCameraSettings",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    null !== t && (this.uniforms.cameraNear.value = t.near, this.uniforms.cameraFar.value = t.far, t instanceof Gr ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                }
            }, {
                key: "setSize",
                value: function(t, e) {
                    var n = Math.max(t, 1),
                        i = Math.max(e, 1);
                    this.uniforms.resolution.value.set(n, i), this.uniforms.texelSize.value.set(1 / n, 1 / i), this.uniforms.aspect.value = n / i
                }
            }, {
                key: "depthPacking",
                get: function() {
                    return Number(this.defines.DEPTH_PACKING)
                },
                set: function(t) {
                    this.defines.DEPTH_PACKING = t.toFixed(0), this.needsUpdate = !0
                }
            }]), n
        }(jr),
        $m = {
            FRAGMENT_HEAD: "FRAGMENT_HEAD",
            FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
            FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
            VERTEX_HEAD: "VERTEX_HEAD",
            VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
        },
        Jm = new Hr,
        Km = null;
    var Qm = function() {
            function t() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Pass",
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Wn,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Jm;
                Vm(this, t), this.name = e, this.scene = n, this.camera = i, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
            }
            return qm(t, [{
                key: "getFullscreenMaterial",
                value: function() {
                    return null !== this.screen ? this.screen.material : null
                }
            }, {
                key: "setFullscreenMaterial",
                value: function(t) {
                    var e = this.screen;
                    null !== e ? e.material = t : ((e = new Ar(function() {
                        if (null === Km) {
                            var t = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                                e = new Float32Array([0, 0, 2, 0, 0, 2]);
                            void 0 !== (Km = new ur).setAttribute ? (Km.setAttribute("position", new Wi(t, 3)), Km.setAttribute("uv", new Wi(e, 2))) : (Km.addAttribute("position", new Wi(t, 3)), Km.addAttribute("uv", new Wi(e, 2)))
                        }
                        return Km
                    }(), t)).frustumCulled = !1, null === this.scene && (this.scene = new Wn), this.scene.add(e), this.screen = e)
                }
            }, {
                key: "getDepthTexture",
                value: function() {
                    return null
                }
            }, {
                key: "setDepthTexture",
                value: function(t) {}
            }, {
                key: "render",
                value: function(t, e, n, i, r) {
                    throw new Error("Render method not implemented!")
                }
            }, {
                key: "setSize",
                value: function(t, e) {}
            }, {
                key: "initialize",
                value: function(t, e, n) {}
            }, {
                key: "dispose",
                value: function() {
                    var t = this.getFullscreenMaterial();
                    null !== t && t.dispose();
                    for (var e = 0, n = Object.keys(this); e < n.length; e++) {
                        var i = n[e];
                        null !== this[i] && "function" == typeof this[i].dispose && this[i].dispose()
                    }
                }
            }, {
                key: "renderToScreen",
                get: function() {
                    return !this.rtt
                },
                set: function(t) {
                    if (this.rtt === t) {
                        var e = this.getFullscreenMaterial();
                        null !== e && (e.needsUpdate = !0), this.rtt = !t
                    }
                }
            }]), t
        }(),
        tg = function(t) {
            Um(n, t);
            var e = zm(n);

            function n() {
                var t;
                return Vm(this, n), (t = e.call(this, "ClearMaskPass", null, null)).needsSwap = !1, t
            }
            return qm(n, [{
                key: "render",
                value: function(t, e, n, i, r) {
                    var o = t.state.buffers.stencil;
                    o.setLocked(!1), o.setTest(!1)
                }
            }]), n
        }(Qm),
        eg = new Ni,
        ng = function(t) {
            Um(n, t);
            var e = zm(n);

            function n() {
                var t, i = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                    r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                return Vm(this, n), (t = e.call(this, "ClearPass", null, null)).needsSwap = !1, t.color = i, t.depth = r, t.stencil = o, t.overrideClearColor = null, t.overrideClearAlpha = -1, t
            }
            return qm(n, [{
                key: "render",
                value: function(t, e, n, i, r) {
                    var o = this.overrideClearColor,
                        s = this.overrideClearAlpha,
                        a = t.getClearAlpha(),
                        c = null !== o,
                        l = s >= 0;
                    c ? (eg.copy(t.getClearColor()), t.setClearColor(o, l ? s : a)) : l && t.setClearAlpha(s), t.setRenderTarget(this.renderToScreen ? null : e), t.clear(this.color, this.depth, this.stencil), c ? t.setClearColor(eg, a) : l && t.setClearAlpha(a)
                }
            }]), n
        }(Qm),
        ig = !1,
        rg = function() {
            function t() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                Vm(this, t), this.originalMaterials = new Map, this.material = null, this.materialInstanced = null, this.materialSkinning = null, this.setMaterial(e)
            }
            return qm(t, [{
                key: "setMaterial",
                value: function(t) {
                    this.disposeMaterials(), null !== t && (this.material = t, this.materialInstanced = t.clone(), this.materialInstanced.uniforms = Object.assign({}, t.uniforms), this.materialSkinning = t.clone(), this.materialSkinning.uniforms = Object.assign({}, t.uniforms), this.materialSkinning.skinning = !0)
                }
            }, {
                key: "render",
                value: function(t, e, n) {
                    var i = this.material,
                        r = this.materialSkinning,
                        o = this.materialInstanced,
                        s = this.originalMaterials,
                        a = t.shadowMap.enabled,
                        c = t.sortObjects;
                    if (t.shadowMap.enabled = !1, t.sortObjects = !1, ig) {
                        var l = 0;
                        e.traverse((function(t) {
                            t.isMesh && (s.set(t, t.material), t.isInstancedMesh ? t.material = o : t.isSkinnedMesh ? t.material = r : t.material = i, ++l)
                        })), t.render(e, n);
                        var u, h = Dm(s);
                        try {
                            for (h.s(); !(u = h.n()).done;) {
                                var p = u.value;
                                p[0].material = p[1]
                            }
                        } catch (t) {
                            h.e(t)
                        } finally {
                            h.f()
                        }
                        l !== s.size && s.clear()
                    } else {
                        var f = e.overrideMaterial;
                        e.overrideMaterial = i, t.render(e, n), e.overrideMaterial = f
                    }
                    t.shadowMap.enabled = a, t.sortObjects = c
                }
            }, {
                key: "disposeMaterials",
                value: function() {
                    null !== this.materialInstanced && this.materialInstanced.dispose(), null !== this.materialSkinning && this.materialSkinning.dispose()
                }
            }, {
                key: "dispose",
                value: function() {
                    this.originalMaterials.clear(), this.disposeMaterials()
                }
            }], [{
                key: "workaroundEnabled",
                get: function() {
                    return ig
                },
                set: function(t) {
                    ig = t
                }
            }]), t
        }(),
        og = function(t) {
            Um(n, t);
            var e = zm(n);

            function n(t, i) {
                var r, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                return Vm(this, n), (r = e.call(this, "RenderPass", t, i)).needsSwap = !1, r.clearPass = new ng, r.depthTexture = null, r.overrideMaterialManager = null === o ? null : new rg(o), r
            }
            return qm(n, [{
                key: "getClearPass",
                value: function() {
                    return this.clearPass
                }
            }, {
                key: "getDepthTexture",
                value: function() {
                    return this.depthTexture
                }
            }, {
                key: "setDepthTexture",
                value: function(t) {
                    this.depthTexture = t
                }
            }, {
                key: "render",
                value: function(t, e, n, i, r) {
                    var o = this.scene,
                        s = this.camera,
                        a = this.renderToScreen ? null : e;
                    null === this.depthTexture || this.renderToScreen || (e.depthTexture = this.depthTexture, n.depthTexture = null), this.clear && this.clearPass.render(t, e), t.setRenderTarget(a), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(t, o, s) : t.render(o, s)
                }
            }, {
                key: "renderToScreen",
                get: function() {
                    return Rm(Gm(n.prototype), "renderToScreen", this)
                },
                set: function(t) {
                    ! function(t, e, n, i, r) {
                        if (!Om(t, e, n, i || t) && r) throw new Error("failed to set property")
                    }(Gm(n.prototype), "renderToScreen", t, this, !0), this.clearPass.renderToScreen = t
                }
            }, {
                key: "overrideMaterial",
                get: function() {
                    var t = this.overrideMaterialManager;
                    return null !== t ? t.material : null
                },
                set: function(t) {
                    var e = this.overrideMaterialManager;
                    null !== t && null !== e ? e.setMaterial(t) : null === t ? (e.dispose(), this.overrideMaterialManager = null) : this.overrideMaterialManager = new rg(t)
                }
            }, {
                key: "clear",
                get: function() {
                    return this.clearPass.enabled
                },
                set: function(t) {
                    this.clearPass.enabled = t
                }
            }]), n
        }(Qm),
        sg = 0,
        ag = 2,
        cg = 10,
        lg = 13,
        ug = 14,
        hg = 16,
        pg = new Map([
            [sg, null],
            [1, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}"],
            [ag, "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}"],
            [3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}"],
            [4, "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
            [5, "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
            [6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}"],
            [7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}"],
            [8, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}"],
            [9, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}"],
            [cg, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}"],
            [11, "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
            [12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}"],
            [lg, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}"],
            [ug, "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
            [15, "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
            [hg, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}"],
            [17, "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
            [18, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}"]
        ]),
        fg = function(t) {
            Um(n, t);
            var e = zm(n);

            function n(t) {
                var i, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return Vm(this, n), (i = e.call(this)).blendFunction = t, i.opacity = new Fh(r), i
            }
            return qm(n, [{
                key: "getBlendFunction",
                value: function() {
                    return this.blendFunction
                }
            }, {
                key: "setBlendFunction",
                value: function(t) {
                    this.blendFunction = t, this.dispatchEvent({
                        type: "change"
                    })
                }
            }, {
                key: "getShaderCode",
                value: function() {
                    return pg.get(this.blendFunction)
                }
            }]), n
        }(nn),
        dg = function(t) {
            Um(n, t);
            var e = zm(n);

            function n(t, i) {
                var r, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    s = o.attributes,
                    a = void 0 === s ? mg.NONE : s,
                    c = o.blendFunction,
                    l = void 0 === c ? hg : c,
                    u = o.defines,
                    h = void 0 === u ? new Map : u,
                    p = o.uniforms,
                    f = void 0 === p ? new Map : p,
                    d = o.extensions,
                    m = void 0 === d ? null : d,
                    g = o.vertexShader,
                    v = void 0 === g ? null : g;
                return Vm(this, n), (r = e.call(this)).name = t, r.attributes = a, r.fragmentShader = i, r.vertexShader = v, r.defines = h, r.uniforms = f, r.extensions = m, r.blendMode = new fg(l), r.blendMode.addEventListener("change", (function(t) {
                    return r.setChanged()
                })), r
            }
            return qm(n, [{
                key: "setChanged",
                value: function() {
                    this.dispatchEvent({
                        type: "change"
                    })
                }
            }, {
                key: "getAttributes",
                value: function() {
                    return this.attributes
                }
            }, {
                key: "setAttributes",
                value: function(t) {
                    this.attributes = t, this.setChanged()
                }
            }, {
                key: "getFragmentShader",
                value: function() {
                    return this.fragmentShader
                }
            }, {
                key: "setFragmentShader",
                value: function(t) {
                    this.fragmentShader = t, this.setChanged()
                }
            }, {
                key: "getVertexShader",
                value: function() {
                    return this.vertexShader
                }
            }, {
                key: "setVertexShader",
                value: function(t) {
                    this.vertexShader = t, this.setChanged()
                }
            }, {
                key: "setDepthTexture",
                value: function(t) {}
            }, {
                key: "update",
                value: function(t, e, n) {}
            }, {
                key: "setSize",
                value: function(t, e) {}
            }, {
                key: "initialize",
                value: function(t, e, n) {}
            }, {
                key: "dispose",
                value: function() {
                    for (var t = 0, e = Object.keys(this); t < e.length; t++) {
                        var n = e[t];
                        null !== this[n] && "function" == typeof this[n].dispose && this[n].dispose()
                    }
                }
            }]), n
        }(nn),
        mg = {
            NONE: 0,
            DEPTH: 1,
            CONVOLUTION: 2
        };

    function gg(t, e) {
        for (var n, i = []; null !== (n = t.exec(e));) i.push(n[1]);
        return i
    }

    function vg(t, e, n) {
        var i, r, o, s = Dm(e);
        try {
            for (s.s(); !(o = s.n()).done;) {
                var a = o.value;
                i = "$1" + t + a.charAt(0).toUpperCase() + a.slice(1), r = new RegExp("([^\\.])(\\b" + a + "\\b)", "g");
                var c, l = Dm(n.entries());
                try {
                    for (l.s(); !(c = l.n()).done;) {
                        var u = c.value;
                        null !== u[1] && n.set(u[0], u[1].replace(r, i))
                    }
                } catch (t) {
                    l.e(t)
                } finally {
                    l.f()
                }
            }
        } catch (t) {
            s.e(t)
        } finally {
            s.f()
        }
    }

    function yg(t, e, n, i, r, o, s) {
        var a = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,
            c = e.blendMode,
            l = new Map([
                ["fragment", e.getFragmentShader()],
                ["vertex", e.getVertexShader()]
            ]),
            u = void 0 !== l.get("fragment") && l.get("fragment").indexOf("mainImage") >= 0,
            h = void 0 !== l.get("fragment") && l.get("fragment").indexOf("mainUv") >= 0,
            p = [],
            f = [],
            d = !1,
            m = !1;
        if (void 0 === l.get("fragment")) console.error("Missing fragment shader", e);
        else if (h && 0 != (s & mg.CONVOLUTION)) console.error("Effects that transform UV coordinates are incompatible with convolution effects", e);
        else if (u || h) {
            if (h && (n.set($m.FRAGMENT_MAIN_UV, n.get($m.FRAGMENT_MAIN_UV) + "\t" + t + "MainUv(UV);\n"), d = !0), null !== l.get("vertex") && l.get("vertex").indexOf("mainSupport") >= 0) {
                var g = "\t" + t + "MainSupport(";
                l.get("vertex").indexOf("uv") >= 0 && (g += "vUv"), g += ");\n", n.set($m.VERTEX_MAIN_SUPPORT, n.get($m.VERTEX_MAIN_SUPPORT) + g), p = p.concat(gg(/(?:varying\s+\w+\s+(\w*))/g, l.get("vertex"))), f = f.concat(p).concat(gg(a, l.get("vertex")))
            }
            if (f = f.concat(gg(a, l.get("fragment"))).concat(Array.from(e.defines.keys()).map((function(t) {
                    return t.replace(/\([\w\s,]*\)/g, "")
                }))).concat(Array.from(e.uniforms.keys())), e.uniforms.forEach((function(e, n) {
                    return o.set(t + n.charAt(0).toUpperCase() + n.slice(1), e)
                })), e.defines.forEach((function(e, n) {
                    return r.set(t + n.charAt(0).toUpperCase() + n.slice(1), e)
                })), vg(t, f, r), vg(t, f, l), i.set(c.blendFunction, c), u) {
                var v = t + "MainImage(color0, UV, ";
                0 != (s & mg.DEPTH) && l.get("fragment").indexOf("depth") >= 0 && (v += "depth, ", m = !0), v += "color1);\n\t";
                var y = t + "BlendOpacity";
                o.set(y, c.opacity), v += "color0 = blend" + c.getBlendFunction() + "(color0, color1, " + y + ");\n\n\t", n.set($m.FRAGMENT_MAIN_IMAGE, n.get($m.FRAGMENT_MAIN_IMAGE) + v), n.set($m.FRAGMENT_HEAD, n.get($m.FRAGMENT_HEAD) + "uniform float " + y + ";\n\n")
            }
            n.set($m.FRAGMENT_HEAD, n.get($m.FRAGMENT_HEAD) + l.get("fragment") + "\n"), null !== l.get("vertex") && n.set($m.VERTEX_HEAD, n.get($m.VERTEX_HEAD) + l.get("vertex") + "\n")
        } else console.error("The fragment shader contains neither a mainImage nor a mainUv function", e);
        return {
            varyings: p,
            transformedUv: d,
            readDepth: m
        }
    }
    var bg = function(t) {
            Um(n, t);
            var e = zm(n);

            function n(t) {
                var i;
                Vm(this, n), (i = e.call(this, "EffectPass")).setFullscreenMaterial(new Ym(null, null, null, t));
                for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++) o[s - 1] = arguments[s];
                return i.effects = o.sort((function(t, e) {
                    return e.attributes - t.attributes
                })), i.skipRendering = !1, i.uniforms = 0, i.varyings = 0, i.minTime = 1, i.maxTime = 1e3, i
            }
            return qm(n, [{
                key: "verifyResources",
                value: function(t) {
                    var e = t.capabilities,
                        n = Math.min(e.maxFragmentUniforms, e.maxVertexUniforms);
                    this.uniforms > n && console.warn("The current rendering context doesn't support more than " + n + " uniforms, but " + this.uniforms + " were defined"), n = e.maxVaryings, this.varyings > n && console.warn("The current rendering context doesn't support more than " + n + " varyings, but " + this.varyings + " were defined")
                }
            }, {
                key: "updateMaterial",
                value: function() {
                    var t, e, n = /\bblend\b/g,
                        i = new Map([
                            [$m.FRAGMENT_HEAD, ""],
                            [$m.FRAGMENT_MAIN_UV, ""],
                            [$m.FRAGMENT_MAIN_IMAGE, ""],
                            [$m.VERTEX_HEAD, ""],
                            [$m.VERTEX_MAIN_SUPPORT, ""]
                        ]),
                        r = new Map,
                        o = new Map,
                        s = new Map,
                        a = new Set,
                        c = 0,
                        l = 0,
                        u = 0,
                        h = !1,
                        p = !1,
                        f = Dm(this.effects);
                    try {
                        for (f.s(); !(e = f.n()).done;) {
                            var d = e.value;
                            if (d.blendMode.getBlendFunction() === sg) u |= d.getAttributes() & mg.DEPTH;
                            else if (0 != (u & mg.CONVOLUTION) && 0 != (d.getAttributes() & mg.CONVOLUTION)) console.error("Convolution effects cannot be merged", d);
                            else if (u |= d.getAttributes(), l += (t = yg("e" + c++, d, i, r, o, s, u)).varyings.length, h = h || t.transformedUv, p = p || t.readDepth, null !== d.extensions) {
                                var m, g = Dm(d.extensions);
                                try {
                                    for (g.s(); !(m = g.n()).done;) {
                                        var v = m.value;
                                        a.add(v)
                                    }
                                } catch (t) {
                                    g.e(t)
                                } finally {
                                    g.f()
                                }
                            }
                        }
                    } catch (t) {
                        f.e(t)
                    } finally {
                        f.f()
                    }
                    var y, b = Dm(r.values());
                    try {
                        for (b.s(); !(y = b.n()).done;) {
                            var x = y.value;
                            i.set($m.FRAGMENT_HEAD, i.get($m.FRAGMENT_HEAD) + x.getShaderCode().replace(n, "blend" + x.getBlendFunction()) + "\n")
                        }
                    } catch (t) {
                        b.e(t)
                    } finally {
                        b.f()
                    }
                    0 != (u & mg.DEPTH) ? (p && i.set($m.FRAGMENT_MAIN_IMAGE, "float depth = readDepth(UV);\n\n\t" + i.get($m.FRAGMENT_MAIN_IMAGE)), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1, h ? (i.set($m.FRAGMENT_MAIN_UV, "vec2 transformedUv = vUv;\n" + i.get($m.FRAGMENT_MAIN_UV)), o.set("UV", "transformedUv")) : o.set("UV", "vUv"), i.forEach((function(t, e, n) {
                        return n.set(e, t.trim().replace(/^#/, "\n#"))
                    })), this.uniforms = s.size, this.varyings = l, this.skipRendering = 0 === c, this.needsSwap = !this.skipRendering;
                    var w = this.getFullscreenMaterial();
                    if (w.setShaderParts(i).setDefines(o).setUniforms(s), w.extensions = {}, a.size > 0) {
                        var _, M = Dm(a);
                        try {
                            for (M.s(); !(_ = M.n()).done;) {
                                var S = _.value;
                                w.extensions[S] = !0
                            }
                        } catch (t) {
                            M.e(t)
                        } finally {
                            M.f()
                        }
                    }
                    this.needsUpdate = !1
                }
            }, {
                key: "recompile",
                value: function(t) {
                    this.updateMaterial(), void 0 !== t && this.verifyResources(t)
                }
            }, {
                key: "getDepthTexture",
                value: function() {
                    return this.getFullscreenMaterial().uniforms.depthBuffer.value
                }
            }, {
                key: "setDepthTexture",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = this.getFullscreenMaterial();
                    n.uniforms.depthBuffer.value = t, n.depthPacking = e, n.needsUpdate = !0;
                    var i, r = Dm(this.effects);
                    try {
                        for (r.s(); !(i = r.n()).done;) {
                            var o = i.value;
                            o.setDepthTexture(t, e)
                        }
                    } catch (t) {
                        r.e(t)
                    } finally {
                        r.f()
                    }
                }
            }, {
                key: "render",
                value: function(t, e, n, i, r) {
                    var o = this.getFullscreenMaterial(),
                        s = o.uniforms.time.value + i;
                    this.needsUpdate && this.recompile(t);
                    var a, c = Dm(this.effects);
                    try {
                        for (c.s(); !(a = c.n()).done;) {
                            a.value.update(t, e, i)
                        }
                    } catch (t) {
                        c.e(t)
                    } finally {
                        c.f()
                    }
                    this.skipRendering && !this.renderToScreen || (o.uniforms.inputBuffer.value = e.texture, o.uniforms.time.value = s <= this.maxTime ? s : this.minTime, t.setRenderTarget(this.renderToScreen ? null : n), t.render(this.scene, this.camera))
                }
            }, {
                key: "setSize",
                value: function(t, e) {
                    this.getFullscreenMaterial().setSize(t, e);
                    var n, i = Dm(this.effects);
                    try {
                        for (i.s(); !(n = i.n()).done;) {
                            n.value.setSize(t, e)
                        }
                    } catch (t) {
                        i.e(t)
                    } finally {
                        i.f()
                    }
                }
            }, {
                key: "initialize",
                value: function(t, e, n) {
                    var i = this;
                    this.capabilities = t.capabilities;
                    var r, o = Dm(this.effects);
                    try {
                        for (o.s(); !(r = o.n()).done;) {
                            var s = r.value;
                            s.initialize(t, e, n), s.addEventListener("change", (function(t) {
                                return i.handleEvent(t)
                            }))
                        }
                    } catch (t) {
                        o.e(t)
                    } finally {
                        o.f()
                    }
                    this.updateMaterial(), this.verifyResources(t)
                }
            }, {
                key: "dispose",
                value: function() {
                    Rm(Gm(n.prototype), "dispose", this).call(this);
                    var t, e = Dm(this.effects);
                    try {
                        for (e.s(); !(t = e.n()).done;) {
                            t.value.dispose()
                        }
                    } catch (t) {
                        e.e(t)
                    } finally {
                        e.f()
                    }
                }
            }, {
                key: "handleEvent",
                value: function(t) {
                    switch (t.type) {
                        case "change":
                            this.needsUpdate = !0
                    }
                }
            }, {
                key: "encodeOutput",
                get: function() {
                    return void 0 !== this.getFullscreenMaterial().defines.ENCODE_OUTPUT
                },
                set: function(t) {
                    if (this.encodeOutput !== t) {
                        var e = this.getFullscreenMaterial();
                        e.needsUpdate = !0, t ? e.defines.ENCODE_OUTPUT = "1" : delete e.defines.ENCODE_OUTPUT
                    }
                }
            }, {
                key: "dithering",
                get: function() {
                    return this.getFullscreenMaterial().dithering
                },
                set: function(t) {
                    var e = this.getFullscreenMaterial();
                    e.dithering !== t && (e.dithering = t, e.needsUpdate = !0)
                }
            }]), n
        }(Qm),
        xg = function(t) {
            Um(n, t);
            var e = zm(n);

            function n(t, i) {
                var r;
                return Vm(this, n), (r = e.call(this, "MaskPass", t, i)).needsSwap = !1, r.clearPass = new ng(!1, !1, !0), r.inverse = !1, r
            }
            return qm(n, [{
                key: "render",
                value: function(t, e, n, i, r) {
                    var o = t.getContext(),
                        s = t.state.buffers,
                        a = this.scene,
                        c = this.camera,
                        l = this.clearPass,
                        u = this.inverse ? 0 : 1,
                        h = 1 - u;
                    s.color.setMask(!1), s.depth.setMask(!1), s.color.setLocked(!0), s.depth.setLocked(!0), s.stencil.setTest(!0), s.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), s.stencil.setFunc(o.ALWAYS, u, 4294967295), s.stencil.setClear(h), s.stencil.setLocked(!0), this.clear && (this.renderToScreen ? l.render(t, null) : (l.render(t, e), l.render(t, n))), this.renderToScreen ? (t.setRenderTarget(null), t.render(a, c)) : (t.setRenderTarget(e), t.render(a, c), t.setRenderTarget(n), t.render(a, c)), s.color.setLocked(!1), s.depth.setLocked(!1), s.stencil.setLocked(!1), s.stencil.setFunc(o.EQUAL, 1, 4294967295), s.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), s.stencil.setLocked(!0)
                }
            }, {
                key: "clear",
                get: function() {
                    return this.clearPass.enabled
                },
                set: function(t) {
                    this.clearPass.enabled = t
                }
            }]), n
        }(Qm),
        wg = function(t) {
            Um(n, t);
            var e = zm(n);

            function n(t) {
                var i, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "inputBuffer";
                return Vm(this, n), (i = e.call(this, "ShaderPass")).setFullscreenMaterial(t), i.uniform = null, i.setInput(r), i
            }
            return qm(n, [{
                key: "setInput",
                value: function(t) {
                    var e = this.getFullscreenMaterial();
                    if (this.uniform = null, null !== e) {
                        var n = e.uniforms;
                        void 0 !== n && void 0 !== n[t] && (this.uniform = n[t])
                    }
                }
            }, {
                key: "render",
                value: function(t, e, n, i, r) {
                    null !== this.uniform && null !== e && (this.uniform.value = e.texture), t.setRenderTarget(this.renderToScreen ? null : n), t.render(this.scene, this.camera)
                }
            }]), n
        }(Qm),
        _g = function() {
            function t() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = n.depthBuffer,
                    r = void 0 === i || i,
                    o = n.stencilBuffer,
                    s = void 0 !== o && o,
                    a = n.multisampling,
                    c = void 0 === a ? 0 : a,
                    l = n.frameBufferType;
                Vm(this, t), this.renderer = e, this.inputBuffer = null, this.outputBuffer = null, null !== this.renderer && (this.renderer.autoClear = !1, this.inputBuffer = this.createBuffer(r, s, l, c), this.outputBuffer = this.inputBuffer.clone(), this.enableExtensions()), this.copyPass = new wg(new Zm), this.depthTexture = null, this.passes = [], this.autoRenderToScreen = !0
            }
            return qm(t, [{
                key: "getRenderer",
                value: function() {
                    return this.renderer
                }
            }, {
                key: "enableExtensions",
                value: function() {
                    var t = this.inputBuffer.texture.type,
                        e = this.renderer.capabilities,
                        n = this.renderer.getContext();
                    1009 !== t && (e.isWebGL2 ? n.getExtension("EXT_color_buffer_float") : n.getExtension("EXT_color_buffer_half_float"))
                }
            }, {
                key: "replaceRenderer",
                value: function(t) {
                    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        n = this.renderer;
                    if (null !== n && n !== t) {
                        var i = n.getSize(new sn),
                            r = t.getSize(new sn),
                            o = n.domElement.parentNode;
                        this.renderer = t, this.renderer.autoClear = !1, i.equals(r) || this.setSize(), e && null !== o && (o.removeChild(n.domElement), o.appendChild(t.domElement)), this.enableExtensions()
                    }
                    return n
                }
            }, {
                key: "createDepthTexture",
                value: function() {
                    var t = this.depthTexture = new ac;
                    return this.inputBuffer.stencilBuffer ? (t.format = 1027, t.type = 1020) : t.type = 1014, t
                }
            }, {
                key: "createBuffer",
                value: function(t, e, n, i) {
                    var r = this.renderer.getDrawingBufferSize(new sn),
                        o = {
                            format: this.renderer.getContext().getContextAttributes().alpha || 1009 !== n ? 1023 : 1022,
                            minFilter: 1006,
                            magFilter: 1006,
                            stencilBuffer: e,
                            depthBuffer: t,
                            type: n
                        },
                        s = i > 0 ? new dn(r.width, r.height, o) : new fn(r.width, r.height, o);
                    return i > 0 && (s.samples = i), s.texture.name = "EffectComposer.Buffer", s.texture.generateMipmaps = !1, s
                }
            }, {
                key: "addPass",
                value: function(t, e) {
                    var n = this.passes,
                        i = this.renderer,
                        r = i.getContext().getContextAttributes().alpha,
                        o = this.inputBuffer.texture.type,
                        s = i.getDrawingBufferSize(new sn);
                    if (t.setSize(s.width, s.height), t.initialize(i, r, o), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), t.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== e ? n.splice(e, 0, t) : n.push(t), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), t.needsDepthTexture || null !== this.depthTexture)
                        if (null === this.depthTexture) {
                            var a, c = this.createDepthTexture(),
                                l = Dm(n);
                            try {
                                for (l.s(); !(a = l.n()).done;)(t = a.value).setDepthTexture(c)
                            } catch (t) {
                                l.e(t)
                            } finally {
                                l.f()
                            }
                        } else t.setDepthTexture(this.depthTexture)
                }
            }, {
                key: "removePass",
                value: function(t) {
                    var e = this.passes,
                        n = e.indexOf(t);
                    if (e.splice(n, 1).length > 0) {
                        if (null !== this.depthTexture) {
                            if (!e.reduce((function(t, e) {
                                    return t || e.needsDepthTexture
                                }), !1)) {
                                this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.outputBuffer.depthTexture = null, t.setDepthTexture(null);
                                var i, r = Dm(e);
                                try {
                                    for (r.s(); !(i = r.n()).done;)(t = i.value).setDepthTexture(null)
                                } catch (t) {
                                    r.e(t)
                                } finally {
                                    r.f()
                                }
                            }
                        }
                        this.autoRenderToScreen && e.length > 0 && n === e.length && (e[e.length - 1].renderToScreen = !0)
                    }
                }
            }, {
                key: "render",
                value: function(t) {
                    var e, n, i, r, o = this.renderer,
                        s = this.copyPass,
                        a = this.inputBuffer,
                        c = this.outputBuffer,
                        l = !1,
                        u = Dm(this.passes);
                    try {
                        for (u.s(); !(r = u.n()).done;) {
                            var h = r.value;
                            h.enabled && (h.render(o, a, c, t, l), h.needsSwap && (l && (s.renderToScreen = h.renderToScreen, e = o.getContext(), (n = o.state.buffers.stencil).setFunc(e.NOTEQUAL, 1, 4294967295), s.render(o, a, c, t, l), n.setFunc(e.EQUAL, 1, 4294967295)), i = a, a = c, c = i), h instanceof xg ? l = !0 : h instanceof tg && (l = !1))
                        }
                    } catch (t) {
                        u.e(t)
                    } finally {
                        u.f()
                    }
                }
            }, {
                key: "setSize",
                value: function(t, e, n) {
                    var i = this.renderer;
                    if (void 0 === t || void 0 === e) {
                        var r = i.getSize(new sn);
                        t = r.width, e = r.height
                    }
                    i.setSize(t, e, n);
                    var o = i.getDrawingBufferSize(new sn);
                    this.inputBuffer.setSize(o.width, o.height), this.outputBuffer.setSize(o.width, o.height);
                    var s, a = Dm(this.passes);
                    try {
                        for (a.s(); !(s = a.n()).done;) {
                            s.value.setSize(o.width, o.height)
                        }
                    } catch (t) {
                        a.e(t)
                    } finally {
                        a.f()
                    }
                }
            }, {
                key: "reset",
                value: function() {
                    var t = this.inputBuffer.clone();
                    this.dispose(), this.inputBuffer = t, this.outputBuffer = t.clone(), this.depthTexture = null, this.copyPass = new wg(new Zm), this.autoRenderToScreen = !0
                }
            }, {
                key: "dispose",
                value: function() {
                    var t, e = Dm(this.passes);
                    try {
                        for (e.s(); !(t = e.n()).done;) {
                            t.value.dispose()
                        }
                    } catch (t) {
                        e.e(t)
                    } finally {
                        e.f()
                    }
                    this.passes = [], null !== this.inputBuffer && (this.inputBuffer.dispose(), this.inputBuffer = null), null !== this.outputBuffer && (this.outputBuffer.dispose(), this.outputBuffer = null), null !== this.depthTexture && this.depthTexture.dispose(), this.copyPass.dispose()
                }
            }, {
                key: "multisampling",
                get: function() {
                    return this.inputBuffer instanceof dn ? this.inputBuffer.samples : 0
                },
                set: function(t) {
                    var e = this.inputBuffer,
                        n = this.multisampling;
                    n > 0 && t > 0 ? (this.inputBuffer.samples = t, this.outputBuffer.samples = t) : n !== t && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, t), this.outputBuffer = this.inputBuffer.clone())
                }
            }]), t
        }();
    Set;
    var Mg = function() {
            function t() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                Vm(this, t), this.x = e, this.y = n
            }
            return qm(t, [{
                key: "set",
                value: function(t, e) {
                    return this.x = t, this.y = e, this
                }
            }, {
                key: "equals",
                value: function(t) {
                    return this === t || this.x === t.x && this.y === t.y
                }
            }]), t
        }(),
        Sg = function t() {
            Vm(this, t), this.min = new Mg, this.max = new Mg
        };
    new Sg, new Sg, new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]);
    new Map([
        [Eg([0, 0, 0, 0]), [0, 0, 0, 0]],
        [Eg([0, 0, 0, 1]), [0, 0, 0, 1]],
        [Eg([0, 0, 1, 0]), [0, 0, 1, 0]],
        [Eg([0, 0, 1, 1]), [0, 0, 1, 1]],
        [Eg([0, 1, 0, 0]), [0, 1, 0, 0]],
        [Eg([0, 1, 0, 1]), [0, 1, 0, 1]],
        [Eg([0, 1, 1, 0]), [0, 1, 1, 0]],
        [Eg([0, 1, 1, 1]), [0, 1, 1, 1]],
        [Eg([1, 0, 0, 0]), [1, 0, 0, 0]],
        [Eg([1, 0, 0, 1]), [1, 0, 0, 1]],
        [Eg([1, 0, 1, 0]), [1, 0, 1, 0]],
        [Eg([1, 0, 1, 1]), [1, 0, 1, 1]],
        [Eg([1, 1, 0, 0]), [1, 1, 0, 0]],
        [Eg([1, 1, 0, 1]), [1, 1, 0, 1]],
        [Eg([1, 1, 1, 0]), [1, 1, 1, 0]],
        [Eg([1, 1, 1, 1]), [1, 1, 1, 1]]
    ]);

    function Tg(t, e, n) {
        return t + (e - t) * n
    }

    function Eg(t) {
        var e = Tg(t[0], t[1], .75),
            n = Tg(t[2], t[3], .75);
        return Tg(e, n, .875)
    }
    new yn, new En, Math.PI, new yn, new yn;
    var Cg = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#ifdef ESKIL\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#else\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#endif\noutputColor=vec4(color,inputColor.a);}",
        Ag = function(t) {
            Um(n, t);
            var e = zm(n);

            function n() {
                var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                Vm(this, n);
                var r = Object.assign({
                    blendFunction: lg,
                    eskil: !1,
                    offset: .5,
                    darkness: .5
                }, i);
                return (t = e.call(this, "VignetteEffect", Cg, {
                    blendFunction: r.blendFunction,
                    uniforms: new Map([
                        ["offset", new Fh(r.offset)],
                        ["darkness", new Fh(r.darkness)]
                    ])
                })).eskil = r.eskil, t
            }
            return qm(n, [{
                key: "eskil",
                get: function() {
                    return this.defines.has("ESKIL")
                },
                set: function(t) {
                    this.eskil !== t && (t ? this.defines.set("ESKIL", "1") : this.defines.delete("ESKIL"), this.setChanged())
                }
            }]), n
        }(dg);

    function Lg(t) {
        return (Lg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Pg(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Og(t, e) {
        return (Og = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Rg(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Dg(t);
            if (e) {
                var r = Dg(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Ig(this, n)
        }
    }

    function Ig(t, e) {
        return !e || "object" !== Lg(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function Dg(t) {
        return (Dg = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Ng = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Og(t, e)
            }(o, t);
            var e, n, i, r = Rg(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, "TorchlightEffect", "#define GLSLIFY 1\nuniform sampler2D torchTexture;\nuniform vec2 mouse0;\nuniform vec2 mouse1;\nuniform vec2 mouse2;\nuniform float scale;\nuniform float uTime;\nuniform float opacity;\n\nfloat torchLayer(vec2 p, sampler2D tex, vec2 uv, float size) {\n  vec2 pScale = vec2(\n    size * 0.5 - p.x,\n    p.y - 1.0 + size * 0.5 * aspect\n  );\n  vec2 uv2 = (uv + pScale) * 1.0 / size * vec2(1.0, 1.0 / aspect);\n  return texture2D(tex, uv2).a;\n}\n\nvec4 torchLayerColor(vec2 p, sampler2D tex, vec2 uv, float size) {\n  vec2 pScale = vec2(\n    size * 0.5 - p.x,\n    p.y - 1.0 + size * 0.5 * aspect\n  );\n  vec2 uv2 = (uv + pScale) * 1.0 / size * vec2(1.0, 1.0 / aspect);\n  return texture2D(tex, uv2);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n  float t0 = torchLayerColor(mouse0, torchTexture, uv, scale).r;\n  float t1 = torchLayerColor(mouse1, torchTexture, uv, scale).g;\n  float t2 = torchLayerColor(mouse2, torchTexture, uv, scale).b;\n\n  float torch = min(1.5, t0 + t1 + t2);\n  \n  float t = uTime * 0.75;\n  float variation = (cos(sin(t) * tan(t * PI) * PI / 8.0) * 0.5 + 0.5) * 0.1 + 0.9;\n  \n  outputColor = mix(inputColor, inputColor * torch * 0.75 * variation + inputColor * 0.40 * variation, opacity);\n}", {
                    blendFunction: lg,
                    uniforms: new Map([
                        ["scale", new Fh(.44)],
                        ["uTime", new Fh(0)],
                        ["opacity", new Fh(1)],
                        ["mouse0", new Fh([.5, .5])],
                        ["mouse1", new Fh([.5, .5])],
                        ["mouse2", new Fh([.5, .5])],
                        ["torchTexture", new Fh(t)]
                    ])
                })).scale = e.uniforms.get("scale"), e.mouse0 = e.uniforms.get("mouse0"), e.mouse1 = e.uniforms.get("mouse1"), e.mouse2 = e.uniforms.get("mouse2"), e.uTime = e.uniforms.get("uTime"), e.uOpacity = e.uniforms.get("opacity"), e
            }
            return e = o, (n = [{
                key: "updateTime",
                value: function(t) {
                    this.uTime.value = t
                }
            }, {
                key: "updateMouse",
                value: function(t, e) {
                    this.mouse0.value[0] += .12 * (t - this.mouse0.value[0]), this.mouse1.value[0] += .1 * (t - this.mouse1.value[0]), this.mouse2.value[0] += .08 * (t - this.mouse2.value[0]), this.mouse0.value[1] += .12 * (e - this.mouse0.value[1]), this.mouse1.value[1] += .1 * (e - this.mouse1.value[1]), this.mouse2.value[1] += .08 * (e - this.mouse2.value[1])
                }
            }, {
                key: "opacity",
                get: function() {
                    return this.uOpacity.value
                },
                set: function(t) {
                    this.uOpacity.value = t
                }
            }]) && Pg(e.prototype, n), i && Pg(e, i), o
        }(dg),
        kg = "#define GLSLIFY 1\nvarying vec2 vUvR;\nvarying vec2 vUvB;\n\nuniform float intensity;\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n\t\n\tvec4 chromaColor = inputColor;\n\n\tconst vec2 center = vec2(0.5);\n\tconst float offset = 0.5;\n\tconst float darkness = 0.5;\n\tfloat d = distance(uv, center);\n\tfloat v = 1.0 - smoothstep(0.8, offset * 0.799, d * (darkness + offset));\n\n\tvec2 uvr = vUvR;\n\tvec2 uvb = vUvB;\n\t\n\t#ifdef ALPHA\n\n\t\tvec2 ra = texture2D(inputBuffer, uvr).ra;\n\t\tvec2 ba = texture2D(inputBuffer, uvb).ba;\n\n\t\tchromaColor.r = ra.x;\n\t\tchromaColor.b = ba.x;\n\t\tchromaColor.a = max(max(ra.y, ba.y), inputColor.a);\n\n\t#else\n\n\t\tchromaColor.r = texture2D(inputBuffer, uvr).r;\n\t\tchromaColor.b = texture2D(inputBuffer, uvb).b;\n\n\t#endif\n\n\toutputColor = mix(mix(inputColor, chromaColor, v), chromaColor, intensity);\n}";

    function Ug(t) {
        return (Ug = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Bg(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function zg(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Fg(t, e) {
        return (Fg = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function jg(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Gg(t);
            if (e) {
                var r = Gg(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Hg(this, n)
        }
    }

    function Hg(t, e) {
        return !e || "object" !== Ug(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function Gg(t) {
        return (Gg = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Vg = "#define GLSLIFY 1\nuniform vec2 offset;\n\nvarying vec2 vUvR;\nvarying vec2 vUvB;\n\nvoid mainSupport(const in vec2 uv) {\n\n\tvUvR = uv + offset;\n\tvUvB = uv - offset;\n\n}".replace("#define GLSLIFY 1\n", ""),
        Wg = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Fg(t, e)
            }(o, t);
            var e, n, i, r = jg(o);

            function o() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    e = t.blendFunction,
                    n = void 0 === e ? lg : e,
                    i = t.offset,
                    s = void 0 === i ? new sn(.01, .005) : i;
                return Bg(this, o), r.call(this, "ChromaticAberrationEffect", kg, {
                    vertexShader: Vg,
                    blendFunction: n,
                    uniforms: new Map([
                        ["offset", new Fh(s)],
                        ["intensity", new Fh(0)]
                    ])
                })
            }
            return e = o, (n = [{
                key: "initialize",
                value: function(t, e, n) {
                    e ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA")
                }
            }, {
                key: "offset",
                get: function() {
                    return this.uniforms.get("offset").value
                },
                set: function(t) {
                    this.uniforms.get("offset").value = t
                }
            }, {
                key: "intensity",
                get: function() {
                    return this.uniforms.get("intensity").value
                },
                set: function(t) {
                    this.uniforms.get("intensity").value = t
                }
            }]) && zg(e.prototype, n), i && zg(e, i), o
        }(dg),
        qg = new jr({
            uniforms: {
                tDiffuse: new Fh(null),
                delta: new Fh(new sn(0, 0)),
                time: new Fh(0)
            },
            vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform sampler2D tDiffuse;\nuniform vec2 delta;\nuniform float time;\n\nconst float PI = 3.1458;\nconst vec2 center = vec2(0.5);\n\nvoid main() {\n  vec2 uv  = vUv;\n\n  // Dformation en mode respiration (breath < 1 correspond a un zoom IN)\n  float breath = 1.0 - (cos(time) * 0.5 + 0.5) * 0.025;\n  uv  = (uv - center) * breath + center;\n\n  // Dformation au drag\n  float dy = 1.0 - (cos(uv.y * PI * 2.0) * 0.5 + 0.5);\n  uv.x += (dy * 0.1 * delta.x); \n\n  gl_FragColor = texture2D(tDiffuse, uv);\n}"
        }),
        Xg = new wg(qg, "tDiffuse");

    function Zg(t) {
        return (Zg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Yg(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function $g(t, e) {
        return ($g = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Jg(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = tv(t);
            if (e) {
                var r = tv(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Kg(this, n)
        }
    }

    function Kg(t, e) {
        return !e || "object" !== Zg(e) && "function" != typeof e ? Qg(t) : e
    }

    function Qg(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function tv(t) {
        return (tv = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var ev = new jr({
            uniforms: {
                tDiffuse: new Fh(null),
                delta: new Fh(new sn(1, 0)),
                zoomValues: new Fh(new sn(.5, 1)),
                time: new Fh(0),
                intensity: new Fh(0),
                zoom: new Fh(0),
                brightness: new Fh(0),
                contrast: new Fh(0)
            },
            vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec2 vUvR;\nvarying vec2 vUvB;\n\nconst vec2 offset = vec2(0.025, 0.01);\n\nvoid main() {\n\tvUv = uv;\n  vUvR = uv + offset;\n\tvUvB = uv - offset;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec2 vUvR;\nvarying vec2 vUvB;\n\nuniform sampler2D tDiffuse;\nuniform vec2 delta;\nuniform float time;\nuniform float intensity;\nuniform float zoom;\nuniform float brightness;\nuniform float contrast;\nuniform vec2 zoomValues;\n\nconst float PI = 3.1458;\nconst vec2 center = vec2(0.5);\n\nvec2 zoomDeform(vec2 uv, float r) {\n  // Deformation sur les bords de l'ecran en mode bomb\n  float d = 1.0 - distance(uv, center);\n  vec2 res = (uv - center) * mix(1.0, d, r) + center;\n\n  // Zoom\n  res = (res - center) * mix(zoomValues.x, zoomValues.y, 1.0 - zoom) + center;\n  return res;\n}\n\nvec3 bc(vec3 inputColor) { \n\tvec3 color = inputColor.rgb + vec3(brightness - 0.5);\n\tif(contrast > 0.0) {\n\t\tcolor /= vec3(1.0 - contrast);\n\t} else {\n\t\tcolor *= vec3(1.0 + contrast);\n\t}\n\n\treturn min(color + vec3(0.5), 1.0);\n\n}\n\nvoid main() {\n  // Intensity\n  float i = intensity;\n\n  vec2 uv = zoomDeform(vUv, i);\n  vec2 uvR = zoomDeform(vUvR, i);\n  vec2 uvB = zoomDeform(vUvB, i);\n\n  vec4 color = texture2D(tDiffuse, uv);\n  color.r = mix(color.r, texture2D(tDiffuse, uvR).r, i);\n\tcolor.b = mix(color.b, texture2D(tDiffuse, uvB).b, i);\n\n  color.rgb *= 1.0 - pow(i, 8.0);\n\n  color.rgb = bc(color.rgb);\n\n  gl_FragColor = color;\n}"
        }),
        nv = new(function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && $g(t, e)
            }(o, t);
            var e, n, i, r = Jg(o);

            function o() {
                var t;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (t = r.call(this, ev, "tDiffuse")).setTransitionOutMode = t.setTransitionOutMode.bind(Qg(t)), t.setTransitionInMode = t.setTransitionInMode.bind(Qg(t)), t.setInventaireMode = t.setInventaireMode.bind(Qg(t)), t
            }
            return e = o, (n = [{
                key: "setTransitionOutMode",
                value: function() {
                    this.screen.material.uniforms.zoomValues.value.set(.5, 1)
                }
            }, {
                key: "setTransitionInMode",
                value: function() {
                    this.screen.material.uniforms.zoomValues.value.set(4, 1)
                }
            }, {
                key: "setInventaireMode",
                value: function() {
                    this.screen.material.uniforms.zoomValues.value.set(.5, 1)
                }
            }, {
                key: "intensity",
                get: function() {
                    return this.screen.material.uniforms.intensity.value
                },
                set: function(t) {
                    this.screen.material.uniforms.intensity.value = t
                }
            }, {
                key: "zoom",
                get: function() {
                    return this.screen.material.uniforms.zoom.value
                },
                set: function(t) {
                    this.screen.material.uniforms.zoom.value = t
                }
            }, {
                key: "contrast",
                get: function() {
                    return this.screen.material.uniforms.contrast.value
                },
                set: function(t) {
                    this.screen.material.uniforms.contrast.value = t
                }
            }, {
                key: "brightness",
                get: function() {
                    return this.screen.material.uniforms.brightness.value
                },
                set: function(t) {
                    this.screen.material.uniforms.brightness.value = t
                }
            }]) && Yg(e.prototype, n), i && Yg(e, i), o
        }(wg));

    function iv(t) {
        return (iv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function rv(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function ov(t, e) {
        return (ov = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function sv(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = lv(t);
            if (e) {
                var r = lv(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return av(this, n)
        }
    }

    function av(t, e) {
        return !e || "object" !== iv(e) && "function" != typeof e ? cv(t) : e
    }

    function cv(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function lv(t) {
        return (lv = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var uv = new jr({
            uniforms: {
                tDiffuse: new Fh(null),
                delta: new Fh(new sn(1, 0)),
                zoomValues: new Fh(new sn(2, 1)),
                time: new Fh(0),
                intensity: new Fh(0),
                opacity: new Fh(1),
                zoom: new Fh(0)
            },
            vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec2 vUvR;\nvarying vec2 vUvB;\n\nconst vec2 offset = vec2(0.025, 0.01);\n\nvoid main() {\n\tvUv = uv;\n  vUvR = uv + offset;\n\tvUvB = uv - offset;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec2 vUvR;\nvarying vec2 vUvB;\n\nuniform sampler2D tDiffuse;\nuniform vec2 delta;\nuniform float time;\nuniform float intensity;\nuniform float opacity;\nuniform float zoom;\nuniform vec2 zoomValues;\n\nconst float PI = 3.1458;\nconst vec2 center = vec2(0.5);\n\nvec2 swirl(vec2 uv2, float r) {\n  float effectRadius = 0.8;\n  float effectAngle = 2.0 * PI * r;\n  \n  vec2 uv = uv2 - center;\n  float aspect = 1.0;\n  float len = length(uv * vec2(aspect, 1.0));\n  float angle = atan(uv.y, uv.x) + effectAngle * smoothstep(effectRadius, 0.0, len);\n  float radius = length(uv);\n  \n\n  vec2 res = vec2(radius * cos(angle), radius * sin(angle)) + center;\n\n  \n  // Zoom\n  res = (res - center) * mix(zoomValues.x, zoomValues.y, 1.0 - zoom) + center;\n  return res;\n}\n\nvoid main() {\n  float i = intensity;\n\n  vec2 uv = swirl(vUv, i);\n  vec2 uvR = swirl(vUvR, i);\n  vec2 uvB = swirl(vUvB, i);\n\n  gl_FragColor = texture2D(tDiffuse, uv);\n  gl_FragColor.r = mix(gl_FragColor.r, texture2D(tDiffuse, uvR).r, i);\n\tgl_FragColor.b = mix(gl_FragColor.b, texture2D(tDiffuse, uvB).b, i);\n\n  gl_FragColor.rgb *= opacity;\n}"
        }),
        hv = new(function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ov(t, e)
            }(o, t);
            var e, n, i, r = sv(o);

            function o() {
                var t;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (t = r.call(this, uv, "tDiffuse")).setTransitionOutMode = t.setTransitionOutMode.bind(cv(t)), t.setTransitionInMode = t.setTransitionInMode.bind(cv(t)), t
            }
            return e = o, (n = [{
                key: "setTransitionOutMode",
                value: function() {
                    this.screen.material.uniforms.zoomValues.value.set(2, 1)
                }
            }, {
                key: "setTransitionInMode",
                value: function() {
                    this.screen.material.uniforms.zoomValues.value.set(4, 1)
                }
            }, {
                key: "intensity",
                get: function() {
                    return this.screen.material.uniforms.intensity.value
                },
                set: function(t) {
                    this.screen.material.uniforms.intensity.value = t
                }
            }, {
                key: "zoom",
                get: function() {
                    return this.screen.material.uniforms.zoom.value
                },
                set: function(t) {
                    this.screen.material.uniforms.zoom.value = t
                }
            }, {
                key: "opacity",
                get: function() {
                    return this.screen.material.uniforms.opacity.value
                },
                set: function(t) {
                    this.screen.material.uniforms.opacity.value = t
                }
            }]) && rv(e.prototype, n), i && rv(e, i), o
        }(wg));

    function pv(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var fv = new(function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.startWarp = this.startWarp.bind(this), this.endWarp = this.endWarp.bind(this), this.startTransitionPass = this.startTransitionPass.bind(this), this.endTransitionPass = this.endTransitionPass.bind(this), this.pause = this.pause.bind(this), this.stop = this.stop.bind(this), this.resume = this.resume.bind(this), this.hideTorch = this.hideTorch.bind(this), this.showTorch = this.showTorch.bind(this), this.usePostprocessing = !0, this.stopped = !1
        }
        var e, n, i;
        return e = t, (n = [{
            key: "init",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    e = t.renderer,
                    n = t.camera,
                    i = t.scene;
                this.renderer = e, this.camera = n, this.scene = i, this.composer = new _g(e), this.vignetteEffect = new Ag({
                    darkness: .973,
                    offset: .545
                });
                var r = wm.get("torchlightsTexture");
                this.torchlightEffect = new Ng(r), this.chromaticAberrationEffect = new Wg, this.effectPass = new bg(n, this.chromaticAberrationEffect, this.torchlightEffect, this.vignetteEffect), this.effectPass.renderToScreen = !0, this.composer.addPass(new og(i, n)), this.composer.addPass(Xg), this.composer.addPass(this.effectPass), this.composer.addPass(nv), this.composer.addPass(hv), nv.enabled = !1, hv.enabled = !1, this.transitions = [nv, hv]
            }
        }, {
            key: "startTransitionPass",
            value: function(t) {
                this.transitions.forEach((function(t) {
                    t.enabled = !1, t.renderToScreen = !1
                })), this.effectPass.renderToScreen = !1, t.renderToScreen = !0, t.enabled = !0
            }
        }, {
            key: "endTransitionPass",
            value: function() {
                this.transitions.forEach((function(t) {
                    t.enabled = !1, t.renderToScreen = !1
                })), this.effectPass.renderToScreen = !0
            }
        }, {
            key: "startWarp",
            value: function() {
                nv.enabled = !0, this.effectPass.renderToScreen = !1, nv.renderToScreen = !0
            }
        }, {
            key: "endWarp",
            value: function() {
                nv.enabled = !1, nv.renderToScreen = !1, this.effectPass.renderToScreen = !0
            }
        }, {
            key: "setSize",
            value: function(t, e) {
                this.composer.setSize(t, e)
            }
        }, {
            key: "pause",
            value: function() {
                this.paused = !0
            }
        }, {
            key: "resume",
            value: function() {
                this.paused = !1
            }
        }, {
            key: "stop",
            value: function() {
                this.stopped = !0
            }
        }, {
            key: "hideTorch",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5;
                return this.tlTorch && this.tlTorch.kill(), this.tlTorch = gsap.timeline(), this.tlTorch.to(this.torchlightEffect, {
                    opacity: 0,
                    duration: t
                }), this.tlTorch
            }
        }, {
            key: "showTorch",
            value: function() {
                return this.tlTorch && this.tlTorch.kill(), this.tlTorch = gsap.timeline(), this.tlTorch.to(this.torchlightEffect, {
                    opacity: 1,
                    duration: .5
                }), this.tlTorch
            }
        }, {
            key: "hideFx",
            value: function() {
                var t = gsap.timeline();
                return t.add(this.hideTorch(4), 0), t.to(this.vignetteEffect.blendMode.opacity, {
                    value: 0,
                    duration: 4
                }, 0), t
            }
        }, {
            key: "render",
            value: function(t, e, n) {
                this.paused || (this.torchlightEffect.updateMouse(n[0], n[1]), this.torchlightEffect.updateTime(t), Xg.screen.material.uniforms.delta.value.x *= .9, Xg.screen.material.uniforms.time.value = t, nv.screen.material.uniforms.time.value = t, this.chromaticAberrationEffect.intensity *= .9, this.usePostprocessing ? this.composer.render(e) : this.renderer.render(this.scene, this.camera))
            }
        }]) && pv(e.prototype, n), i && pv(e, i), t
    }());

    function dv(t) {
        var e = new Wh;
        return e.setFromVector3(t.exitPortal.position), {
            phi: Math.PI - e.phi,
            theta: e.theta > 0 ? e.theta - Math.PI : e.theta + Math.PI
        }
    }
    var mv = {
            fade: { in: function(t) {
                    var e = gsap.timeline({
                        onUpdate: function() {
                            t.skyMesh.material.color.setStyle(t.skyMesh.material.colorTween)
                        }
                    });
                    return e.add(Kp.enterRoom(), 0), e.fromTo(t.skyMesh.material, {
                        colorTween: "#000000"
                    }, {
                        colorTween: "#ffffff",
                        duration: .6
                    }, 0), e
                },
                out: function(t) {
                    var e = dv(t),
                        n = e.phi,
                        i = e.theta,
                        r = gsap.timeline({
                            onUpdate: function() {
                                t.skyMesh.material.color.setStyle(t.skyMesh.material.colorTween)
                            }
                        });
                    return r.add(Kp.lookAtTransition(n, i, .8, "power1.inOut"), 0), r.add(Kp.exitRoom(), .2), r.to(t.skyMesh.material, {
                        colorTween: "#000000",
                        duration: .5
                    }, .8), r.call(md), r
                }
            },
            warp: { in: function() {
                    gsap.killTweensOf(nv);
                    var t = gsap.timeline();
                    return t.call(nv.setTransitionInMode), t.fromTo(nv, {
                        intensity: 1,
                        zoom: 1
                    }, {
                        intensity: 0,
                        zoom: 0,
                        ease: "expo.out",
                        duration: .8
                    }, 0), t.call(fv.endTransitionPass), t
                },
                out: function(t) {
                    gsap.killTweensOf(nv);
                    var e = dv(t),
                        n = e.phi,
                        i = e.theta,
                        r = gsap.timeline();
                    return r.call(fv.startTransitionPass, [nv]), r.call(nv.setTransitionOutMode), r.add(Kp.lookAtTransition(n, i, .8, "power1.inOut"), 0), r.fromTo(nv, {
                        intensity: 0,
                        zoom: 0
                    }, {
                        intensity: 1,
                        zoom: 1,
                        ease: "expo.in",
                        duration: .8
                    }, 0), r.call(md), r
                }
            },
            swirl: { in: function(t) {
                    var e = gsap.timeline();
                    return e.call(hv.setTransitionInMode), e.fromTo(hv, {
                        intensity: 1,
                        opacity: 0
                    }, {
                        intensity: 0,
                        opacity: 1,
                        ease: "expo.out",
                        duration: .8
                    }, 0), e.fromTo(hv, {
                        zoom: 1
                    }, {
                        zoom: 0,
                        ease: "expo.out",
                        duration: .9
                    }, .1), t.phiDest && t.thetaDest && e.add(Kp.lookAtTransition(t.phiDest, t.thetaDest, 2, "expo.out"), .2), e.call(fv.endTransitionPass), e
                },
                out: function(t) {
                    var e = dv(t),
                        n = e.phi,
                        i = e.theta,
                        r = gsap.timeline();
                    return r.call(fv.startTransitionPass, [hv]), r.call(hv.setTransitionOutMode), r.add(Kp.lookAtTransition(n, i, .8, "power1.inOut"), 0), r.fromTo(hv, {
                        zoom: 0
                    }, {
                        zoom: -1,
                        ease: "expo.in",
                        duration: .8
                    }, 0), r.fromTo(hv, {
                        intensity: 0
                    }, {
                        intensity: -4,
                        ease: "expo.in",
                        duration: .8
                    }, .2), r.fromTo(hv, {
                        opacity: 1
                    }, {
                        opacity: 0,
                        ease: "none",
                        duration: .8
                    }, 0), r.call(md), r
                }
            },
            inventaire: { in: function() {
                    var t = gsap.timeline();
                    return t.call(fv.startTransitionPass, [nv]), t.call(Kp.disable), t.call(Kp.startTransition), t.call(nv.setInventaireMode), t.to(nv, {
                        duration: 2,
                        intensity: .7,
                        zoom: -2,
                        brightness: -.4,
                        contrast: -.5,
                        ease: "expo.out"
                    }), t.add(fv.hideTorch(), 0), t.call(Kp.endTransition), t.call(fv.pause), t
                },
                out: function() {
                    var t = gsap.timeline();
                    return t.call(fv.resume), t.call(Kp.startTransition), t.call(nv.setInventaireMode), t.to(nv, {
                        duration: 1,
                        intensity: 0,
                        zoom: 0,
                        brightness: 0,
                        contrast: 0,
                        ease: "expo.out"
                    }), t.add(fv.showTorch(), 0), t.call(fv.endTransitionPass), t.call(Kp.enable), t.call(Kp.endTransition), t
                }
            },
            pause: { in: function(t) {
                    var e = t.skyMesh.material;
                    l("Intro").recenter();
                    var n = gsap.timeline({
                        onUpdate: function() {
                            e.color.setStyle(e.colorTween)
                        }
                    });
                    return n.call(Kp.disable), n.call(Kp.startTransition), n.fromTo(e, {
                        colorTween: "#ffffff"
                    }, {
                        colorTween: "#555555",
                        duration: .5
                    }, 0), n.call(Kp.endTransition), n.call(fv.pause), n.add(l("Intro").transitionIn(), 0), n
                },
                out: function(t) {
                    var e = t.skyMesh.material,
                        n = gsap.timeline({
                            onUpdate: function() {
                                e.color.setStyle(e.colorTween)
                            }
                        });
                    return n.call(fv.resume), n.call(Kp.startTransition), n.to(e, {
                        colorTween: "#ffffff",
                        duration: .5
                    }, 0), n.call(Kp.enable), n.call(Kp.endTransition), n.add(l("Intro").transitionOut(), 0), n
                }
            },
            starting: function(t) {
                var e = t.skyMesh.material,
                    n = gsap.timeline({
                        onUpdate: function() {
                            e.color.setStyle(e.colorTween)
                        }
                    });
                return n.call(fv.endTransitionPass), n.add(l("Logo").transitionIn(), 1), n.add(l("Intro").transitionIn(), 1.5), n.call(l("Intro").transitionOut, null, 5.5), n.add(l("Footer").transitionIn(), 6.5), n.add(l("Languages").transitionIn(), 6.5), n.add(l("Cursor").transitionIn(), 6.5), n.fromTo(e, {
                    colorTween: "#000000"
                }, {
                    colorTween: "#ffffff",
                    duration: .5
                }, 6.5), n.to(e, {
                    colorTween: "#000000",
                    duration: .1
                }), n.to(e, {
                    colorTween: "#ffffff",
                    duration: .3
                }), n.to(e, {
                    colorTween: "#000000",
                    duration: .1
                }), n.to(e, {
                    colorTween: "#ffffff",
                    duration: .3
                }), n.add(Kp.startAnimation(), "-=0.6"), n.call(l("Tuto").transitionIn), n.call(Kp.endTransition), n
            },
            ending: function(t) {
                Oe("Ending", "Start", "Dbut de la squence de fin");
                var e = t.skyMesh.material,
                    n = gsap.timeline({
                        onUpdate: function() {
                            e.color.setStyle(e.colorTween)
                        }
                    });
                return n.call(fv.endTransitionPass), n.call(c.emit, ["startend"]), n.call(Zt), n.fromTo(e, {
                    colorTween: "#000000"
                }, {
                    colorTween: "#ffffff",
                    duration: .6
                }, 0), n.add(fv.hideFx(), 0), n.add(Kp.endAnimation(), 0), n.to(e, {
                    colorTween: "#000000",
                    duration: 1.5
                }, "-=1.5"), n.call(fv.stop), n.call(c.emit, ["playvideoend"]), n
            }
        },
        gv = "swirl";

    function vv() {
        return gv
    }

    function yv(t) {
        return (yv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function bv(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function xv(t, e) {
        return (xv = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function wv(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Sv(t);
            if (e) {
                var r = Sv(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return _v(this, n)
        }
    }

    function _v(t, e) {
        return !e || "object" !== yv(e) && "function" != typeof e ? Mv(t) : e
    }

    function Mv(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Sv(t) {
        return (Sv = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Tv = 0,
        Ev = new yn(0, 1, 0),
        Cv = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && xv(t, e)
            }(o, t);
            var e, n, i, r = wv(o);

            function o(t) {
                var e, n;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this)).portalId = Tv++, e.computePosition = e.computePosition.bind(Mv(e)), e.computeSize = e.computeSize.bind(Mv(e)), e.infos = Object.assign(t, {
                    u: t.p[0],
                    v: t.p[1],
                    width: t.s[0],
                    height: t.s[1],
                    transition: t.t ? t.t : (n = ["warp", "fade"], n[Math.floor(Math.random() * n.length)])
                });
                var i = new Hi({
                    color: 16711680,
                    transparent: !0,
                    opacity: 0
                });
                return e.mesh = new Ar(new kr(1, 1, 1), i), e.add(e.mesh), e.mesh.rotation.set(e.infos.r[0], e.infos.r[1], e.infos.r[2]), e.computePosition(), e.computeSize(), e
            }
            return e = o, (n = [{
                key: "mouseOver",
                value: function() { of () || L.emit("door:over")
                }
            }, {
                key: "mouseOut",
                value: function() { of () || U()
                }
            }, {
                key: "click",
                value: function() {
                    U()
                }
            }, {
                key: "computeSize",
                value: function() {
                    this.mesh.scale.set(this.infos.width, this.infos.height, 1)
                }
            }, {
                key: "computePosition",
                value: function() {
                    var t = this.infos,
                        e = t.origin,
                        n = t.radius,
                        i = 2 * Math.PI * this.infos.u,
                        r = Math.acos(2 * this.infos.v - 1);
                    this.position.set(e.x + n * Math.sin(r) * Math.cos(i), e.y + n * Math.sin(r) * Math.sin(i), e.z + n * Math.cos(r)), this.position.x *= -1, this.position.applyAxisAngle(Ev, Math.PI), this.mesh.rotation.y *= -1, this.lookAt(e)
                }
            }, {
                key: "hide",
                value: function() {
                    this.visible = !1
                }
            }, {
                key: "destroy",
                value: function() {
                    this.gui && this.gui.remove(), this.mesh.geometry.dispose(), this.mesh.material.dispose()
                }
            }]) && bv(e.prototype, n), i && bv(e, i), o
        }(Vn),
        Av = "#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n}",
        Lv = "#define GLSLIFY 1\nuniform float visibility;\nuniform float opacity;\nuniform sampler2D map;\nuniform float maxAlpha;\nuniform float meshAspect;\nuniform float mapAspect;\nuniform float mapScale;\nuniform vec2 mapOffset;\nuniform float border;\nuniform float time;\nuniform float flipx;\nuniform float normalIntensity;\nuniform float waveIntensity;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec2 flippedScale = vec2(mapScale);\n  flippedScale.x *= mix(1.0, -1.0, flipx);\n\n  // restore uv to square shape\n  uv.x *= meshAspect;\n  uv.x -= (0.5 - (1. / meshAspect) * 0.5) * meshAspect;\n\n  // uv to respect map aspect ratio\n  uv.y *= mapAspect;\n  uv.y -= (0.5 - (1. / mapAspect) * 0.5) * mapAspect;\n\n  // apply custom scale\n  vec2 scale = 1.0 / flippedScale;\n  float recenterScaleX = (0.5 - (1. / scale.x) * 0.5) * scale.x;\n  float recenterScaleY = (0.5 - (1. / scale.y) * 0.5) * scale.y;\n  uv *= scale;\n  uv.x -= recenterScaleX;\n  uv.y -= recenterScaleY;\n\n  // apply custom offset\n  uv -= mapOffset;\n\n  // apply wave distortion\n  vec2 waveUv = uv;\n  // waveUv.x += cos(time * 3.2 + sin(uv.y)) * sin(time * 5.6 + uv.x) * 0.2 * sin(uv.y * 15.0);\n  waveUv.x += cos(time * 6.0 + uv.y * 20.0) * mix(0.002, 0.05, 1.0 - visibility) * waveIntensity;\n  // uv = mix(waveUv, uv, visibility + 0.2);\n  uv = mix(waveUv, uv, 0.0);\n\n  // Get color and use white for transparency (because Multiply Blending)\n  vec4 texelColor = texture2D(map, uv);\n\n  vec4 borderColor = vec4(0.0);\n  #ifdef MULTIPLY\n    texelColor.rgb = (texelColor.rgb * texelColor.a + vec3(1.0) * (1.0 - texelColor.a));\n    texelColor.a = 1.0;\n    borderColor = vec4(1.0);\n  #else\n    texelColor.rgb = (texelColor.rgb * texelColor.a + vec3(0.0) * (1.0 - texelColor.a));\n    texelColor.a = 1.0;\n    borderColor = vec4(0.0);\n  #endif \n  \n  vec4 diffuseColor = mix(vec4(0.0), sRGBToLinear(texelColor), visibility);\n  #ifdef MULTIPLY\n    diffuseColor = mix(vec4(1.0), sRGBToLinear(texelColor), visibility);\n  #endif \n  #ifdef NORMAL\n    diffuseColor = sRGBToLinear(texelColor);\n    diffuseColor.a = visibility;\n  #endif\n    \n  diffuseColor.rgb *= normalIntensity;\n\n  // Border mask (progressive on sides)\n  float b = border;\n  vec2 gbl = vUv / vec2(b, b * meshAspect);\n  vec2 gtr = (1.0 - vUv) / vec2(b, b * meshAspect);\n  float pct = min(1.0, max(0.0, 1.0 - (gbl.x * gbl.y * gtr.x * gtr.y)));\n  diffuseColor = mix(diffuseColor, borderColor, pct);\n\n\tgl_FragColor = diffuseColor;\n  #ifndef MULTIPLY \n    gl_FragColor.a = opacity;\n  #endif \n\n  #ifdef NORMAL\n    gl_FragColor.a *= visibility;\n  #endif\n\n  #ifdef MULTIPLY \n    gl_FragColor.rgb += (1.0 - maxAlpha);\n  #endif\n\n  #ifdef ADDITIVE \n    gl_FragColor.rgb *= maxAlpha;\n  #endif\n\n  #ifdef NORMAL \n    gl_FragColor.a *= maxAlpha;\n  #endif\n\n\t#include <encodings_fragment>\n}";

    function Pv(t) {
        return (Pv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Ov(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Rv(t, e) {
        return (Rv = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Iv(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Nv(t);
            if (e) {
                var r = Nv(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Dv(this, n)
        }
    }

    function Dv(t, e) {
        return !e || "object" !== Pv(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function Nv(t) {
        return (Nv = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var kv = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Rv(t, e)
        }(n, t);
        var e = Iv(n);

        function n() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                i = t.texture,
                r = void 0 === i ? new hn : i,
                o = t.infos,
                s = void 0 === o ? {
                    mb: 0,
                    mo: [0, 0],
                    ms: 0
                } : o,
                a = t.blending,
                c = void 0 === a ? 4 : a;
            Ov(this, n);
            var l = 4 === c,
                u = 1 === c,
                h = l ? {
                    MULTIPLY: 1
                } : u ? {
                    NORMAL: 1
                } : {
                    ADDITIVE: 1
                };
            return e.call(this, {
                vertexShader: Av,
                fragmentShader: Lv,
                transparent: u,
                uniforms: {
                    visibility: {
                        value: 0
                    },
                    normalIntensity: {
                        value: s.normalIntensity ? s.normalIntensity : 1
                    },
                    waveIntensity: {
                        value: void 0 !== s.wave ? s.wave : 1
                    },
                    opacity: {
                        value: 1
                    },
                    maxAlpha: {
                        value: s.a ? s.a : 1
                    },
                    time: {
                        value: 0
                    },
                    border: {
                        value: s.mb
                    },
                    mapAspect: {
                        value: (r.image.width || r.image.videoWidth) / (r.image.height || r.image.videoHeight)
                    },
                    mapScale: {
                        value: s.ms
                    },
                    mapOffset: {
                        value: new sn(s.mo[0], s.mo[1])
                    },
                    meshAspect: {
                        value: 1
                    },
                    flipx: {
                        value: s.flip ? 1 : 0
                    },
                    map: {
                        value: r
                    }
                },
                blending: c,
                defines: h
            })
        }
        return n
    }(jr);

    function Uv(t) {
        return (Uv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Bv(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function zv(t, e) {
        return (zv = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Fv(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Gv(t);
            if (e) {
                var r = Gv(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return jv(this, n)
        }
    }

    function jv(t, e) {
        return !e || "object" !== Uv(e) && "function" != typeof e ? Hv(t) : e
    }

    function Hv(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Gv(t) {
        return (Gv = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Vv = 0,
        Wv = new yn(0, 1, 0);
    var qv = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && zv(t, e)
        }(o, t);
        var e, n, i, r = Fv(o);

        function o(t) {
            var e;
            if (function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this)).onTextureReady = e.onTextureReady.bind(Hv(e)), e.hintId = Vv++, e.computePosition = e.computePosition.bind(Hv(e)), e.computeSize = e.computeSize.bind(Hv(e)), e.infos = Object.assign({
                    r: [0, 0, 0],
                    ms: 1,
                    mo: [0, 0],
                    mb: .2
                }, t, {
                    u: t.p[0],
                    v: t.p[1],
                    width: t.s ? t.s[0] : 1,
                    height: t.s ? t.s[1] : 1
                }), e.isValidated = gf(e.infos.id), e.defaultMesh = new Ar(new kr(1, 1, 1), new Hi({
                    transparent: !0,
                    opacity: 0
                })), e.add(e.defaultMesh), e.defaultMesh.rotation.set(e.infos.r[0], e.infos.r[1], e.infos.r[2]), e.infos.video) {
                var n = document.createElement("video");
                n.src = "/SilentFamilyShadow/assets/videos/" + e.infos.video, n.muted = !0, n.loop = !0, n.load(), n.play();
                var i = new rc(n);
                i.minFilter = 1006, i.magFilter = 1006, e.texture = i, n.addEventListener("loadeddata", e.onTextureReady)
            } else {
                var s = wm.get(e.infos.img);
                s.wrapT = s.wrapS = 1e3, e.texture = s, e.onTextureReady()
            }
            return e
        }
        return e = o, (n = [{
            key: "onTextureReady",
            value: function() {
                this.flipx = !!this.infos.flip;
                var t = new kv({
                        texture: this.texture,
                        infos: this.infos,
                        blending: this.infos.additive ? 2 : this.infos.normal ? 1 : 4
                    }),
                    e = this.defaultMesh.material;
                this.defaultMesh.material = t, e.dispose(), this.uOpacity = {
                    value: 1
                }, this.uTime = t.uniforms.time, this.computePosition(), this.computeSize(), this.isValidated && (this.visibility = .9)
            }
        }, {
            key: "mouseOver",
            value: function() {
                this.isValidated || of () || Sf() || this.isValidating || this.startValidation()
            }
        }, {
            key: "mouseOut",
            value: function() {
                this.isValidated || of () || Sf() || this.isValidating && this.stopValidation()
            }
        }, {
            key: "click",
            value: function() {}
        }, {
            key: "computeSize",
            value: function() {
                this.defaultMesh.scale.set(this.infos.width, this.infos.height, 1), this.defaultMesh.material.uniforms.meshAspect.value = this.infos.width / this.infos.height, this.infos.width, this.infos.height
            }
        }, {
            key: "computePosition",
            value: function() {
                var t = this.infos,
                    e = t.origin,
                    n = t.radius,
                    i = 2 * Math.PI * this.infos.u,
                    r = Math.acos(2 * this.infos.v - 1);
                this.position.set(e.x + n * Math.sin(r) * Math.cos(i), e.y + n * Math.sin(r) * Math.sin(i), e.z + n * Math.cos(r)), this.position.applyAxisAngle(Wv, Math.PI), this.lookAt(e)
            }
        }, {
            key: "hide",
            value: function() {
                this.visible = !1
            }
        }, {
            key: "destroy",
            value: function() {
                this.sound && this.sound.fade(this.sound.volume(), 0, 500), this.texture.isVideoTexture && (this.texture.image.pause(), this.texture.dispose()), this.defaultMesh.geometry.dispose(), this.defaultMesh.material.dispose()
            }
        }, {
            key: "startValidation",
            value: function() {
                this.isValidating = !0, this.validationTimer = 1e3, L.emit("hint:over")
            }
        }, {
            key: "stopValidation",
            value: function() {
                this.isValidating = !1, D(1), L.emit("hint:out")
            }
        }, {
            key: "checkValidation",
            value: function(t, e) {
                this.validationTimer -= 10 * t, D(1 - this.validationTimer / 1e3), this.validationTimer <= 0 && this.validate()
            }
        }, {
            key: "validate",
            value: function() {
                this.isValidating = !1, this.isValidated = !0;
                var t = void 0 !== this.infos.souvenir && this.infos.souvenir;
                if (function(t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        gf(t) || (df.length <= 0 && l("HintsButton").transitionIn(), ff.push(t), Oe("Hint", "Find", "Indice trouv", parseInt(t)), Oe("Hint", "TotalFound", "Nombre total trouv", parseInt(ff.length)), e ? (mf.push(t), xf() && nf.emit("last")) : (df.push(t), Vt(df.length)), nf.emit("hint", Object.assign(vf(), {
                            current: t
                        })))
                    }(this.infos.id, t), gsap.timeline({}).to(this, {
                        visibility: .9,
                        duration: .5
                    }), L.emit("hint:validate"), !t) {
                    var e = yf();
                    ! function(t, e) {
                        pd && pd.kill(), (pd = gsap.timeline()).fromTo(ud.domElement, {
                            display: "none",
                            alpha: 0
                        }, {
                            display: "block",
                            alpha: 1,
                            duration: .5
                        });
                        var n = [].slice.call(t.querySelectorAll("div")),
                            i = 0,
                            r = n.map((function(t, n) {
                                var r = t.cloneNode(!0),
                                    o = new td(r);
                                r.style.pointerEvents = "none", r.style.top = r.style.left = 0, r.style.opacity = 0, r.style.fontSize = "300px", fd.add(o), o.scale.multiplyScalar(.005), o.position.copy(e), o.position.y -= i, o.lookAt(dd.position);
                                var s = function() {
                                        o.element.style.filter = "blur(" + c.blur + "px)"
                                    },
                                    a = 1 * n,
                                    c = {
                                        blur: 0
                                    };
                                return pd.fromTo(c, {
                                    blur: 30
                                }, {
                                    blur: 0,
                                    duration: 2,
                                    onUpdate: s
                                }, a), pd.to(o.element, {
                                    alpha: 1,
                                    duration: 1
                                }, a), pd.to(o.position, {
                                    z: 0,
                                    y: -i,
                                    x: 0,
                                    duration: 6
                                }, a), pd.to(o.element, {
                                    alpha: 0,
                                    duration: 1
                                }, a + 4.5 - 1), pd.to(c, {
                                    blur: 20,
                                    duration: 2,
                                    onUpdate: s
                                }, a + 4.5 - 2), i += 3 * (n + 1), o
                            }));
                        pd.eventCallback("onComplete", (function() {
                            r.forEach((function(t) {
                                fd.remove(t)
                            }))
                        }))
                    }(document.querySelector(".Phrase:nth-child(" + e.total + ")"), this.position)
                }
                this.infos.audio && (this.sound = qt(this.infos.audio))
            }
        }, {
            key: "update",
            value: function(t, e, n) {
                if (this.uTime && (this.uTime.value = t), !this.isValidated && ! of () && !Sf()) {
                    var i = this.position.distanceTo(e),
                        r = (s = 1 - (i - 20) / 40, on.clamp(s, 0, 1)),
                        o = .5 * r;
                    this.visibility += .1 * (o - this.visibility), this.isValidating && this.checkValidation(r, n)
                }
                var s
            }
        }, {
            key: "visibility",
            get: function() {
                return this.defaultMesh && this.defaultMesh.material.uniforms ? this.defaultMesh.material.uniforms.visibility.value : 0
            },
            set: function(t) {
                this.defaultMesh && this.defaultMesh.material.uniforms && (this.defaultMesh.material.uniforms.visibility.value = t)
            }
        }]) && Bv(e.prototype, n), i && Bv(e, i), o
    }(Vn);

    function Xv(t) {
        return (Xv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Zv(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Yv(t, e) {
        return (Yv = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function $v(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Qv(t);
            if (e) {
                var r = Qv(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Jv(this, n)
        }
    }

    function Jv(t, e) {
        return !e || "object" !== Xv(e) && "function" != typeof e ? Kv(t) : e
    }

    function Kv(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Qv(t) {
        return (Qv = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var ty = new al(100, 64, 32),
        ey = new Hh,
        ny = new sn(1e3, 1e3),
        iy = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Yv(t, e)
            }(o, t);
            var e, n, i, r = $v(o);

            function o(t) {
                var e;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this)).infos = t, e.onMouseMove = e.onMouseMove.bind(Kv(e)), e.onClick = e.onClick.bind(Kv(e)), e.onMouseDown = e.onMouseDown.bind(Kv(e)), e.onMouseUp = e.onMouseUp.bind(Kv(e)), e.onUIOver = e.onUIOver.bind(Kv(e)), e.onLastSouvenirFound = e.onLastSouvenirFound.bind(Kv(e)), e.emitter = Object(a.default)(), e.startDrag = new sn(0, 0), e.currentDrag = new sn(0, 0), e.dragThreshold = 15;
                var n = e.infos.texture;
                n.wrapS = 1e3, n.repeat.x = -1;
                var i = new Hi({
                    map: n,
                    side: 1,
                    depthTest: !1
                });
                i.colorTween = "#ffffff", e.skyMesh = new Ar(ty, i), e.add(e.skyMesh), e.skyPointer = new yn, e.isStarting = !1, e.visible = !1, window.addEventListener("mousemove", e.onMouseMove), window.addEventListener("mousedown", e.onMouseDown), window.addEventListener("mouseup", e.onMouseUp), O(e.onUIOver), wf(e.onLastSouvenirFound);
                var s = {
                    radius: 100,
                    origin: e.skyMesh.position
                };
                e.portals = e.infos.portals.map((function(t) {
                    var n = new Cv(Object.assign(t, s));
                    return e.add(n), n
                }));
                var c = e.infos.hints;
                e.hints = [];
                for (var l = 0, u = c ? c.length : 0; l < u; l++) {
                    var h = c[l];
                    if (!h.last || h.last && bf()) {
                        var p = new qv(Object.assign(h, s));
                        e.add(p), e.hints.push(p)
                    }
                }
                return e.interactivePortals = e.portals.map((function(t) {
                    return t.mesh
                })), e.interactiveHints = e.hints.map((function(t) {
                    return t.defaultMesh
                })), bf() && (e.altTexture = (new au).load("/SilentFamilyShadow/assets/textures/equirectangular/" + t.alt + ".jpg"), e.altTexture.wrapS = 1e3, e.altTexture.repeat.x = -1), e
            }
            return e = o, (n = [{
                key: "onLastSouvenirFound",
                value: function() {
                    console.log("onLastSouvenirFound"), this.skyMesh.material.map = this.altTexture
                }
            }, {
                key: "onUIOver",
                value: function() {
                    this.activePortal = null
                }
            }, {
                key: "setEnteringView",
                value: function(t, e) {
                    var n = this.getPortalByDestination(t, e),
                        i = n.infos.c,
                        r = new Wh;
                    r.setFromVector3(n.position);
                    var o = i && "default" !== i[0] ? i[0] : .5 * Math.PI,
                        s = i ? i[1] : r.theta;
                    Kp.orbit.setPolarAngle(o), Kp.orbit.setAzimuthalAngle(s), i && i.length >= 4 && (this.phiDest = i[2], this.thetaDest = i[3])
                }
            }, {
                key: "setManualEnteringView",
                value: function(t, e) {
                    Kp.orbit.setPolarAngle(t), Kp.orbit.setAzimuthalAngle(e)
                }
            }, {
                key: "getPortalByDestination",
                value: function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        n = this.portals.filter((function(n) {
                            return e.alt ? t === n.infos.room && e.alt === n.infos.alt : t === n.infos.room
                        }));
                    return n.length ? n[0] : null
                }
            }, {
                key: "fistRoomPreload",
                value: function() {}
            }, {
                key: "nextRomsPreload",
                value: function() {}
            }, {
                key: "onMouseMove",
                value: function(t) {
                    ny.x = t.clientX / window.innerWidth * 2 - 1, ny.y = -t.clientY / window.innerHeight * 2 + 1
                }
            }, {
                key: "update",
                value: function(t, e, n) {
                    if (!(this.isStarting || this.isExiting || P)) {
                        ey.setFromCamera(ny, t);
                        var i = ey.intersectObjects(this.interactivePortals);
                        if (i.length) {
                            var r = i[0].object.parent;
                            if (r.infos.exit && !xf()) return;
                            this.activePortal || r.mouseOver(), this.activePortal = r
                        } else this.activePortal && (this.activePortal.mouseOut(), this.activePortal = null);
                        var o = ey.intersectObjects(this.interactiveHints);
                        if (o.length) {
                            var s = o[0].object.parent;
                            this.activeHint || s.mouseOver(), this.activeHint = s
                        } else this.activeHint && (this.activeHint.mouseOut(), this.activeHint = null);
                        var a = ey.intersectObject(this.skyMesh);
                        a.length && (this.skyPointer = a[0].point);
                        for (var c = 0, l = this.hints.length; c < l; c++) this.hints[c].update(e, this.skyPointer, n)
                    }
                }
            }, {
                key: "starting",
                value: function() {
                    this.tl && this.tl.kill(), this.tl = new gsap.timeline, this.tl.set(this, {
                        isStarting: !0
                    }), this.tl.call(Kp.startTransition), this.tl.call(Kp.disable), this.tl.set(this, {
                        visible: !0
                    }), this.tl.add(mv.starting(this)), this.tl.call(Kp.enable), this.tl.set(this, {
                        isStarting: !1
                    })
                }
            }, {
                key: "ending",
                value: function() {
                    var t = this;
                    return this.exitPortal = null, new Promise((function(e) {
                        t.tl && t.tl.kill(), t.tl = new gsap.timeline({
                            onComplete: e
                        }), Kp.setFOV(120), t.tl.call(Kp.startTransition), t.tl.call(Kp.disable), t.tl.set(t, {
                            visible: !0
                        }), t.tl.add(mv.ending(t))
                    }))
                }
            }, {
                key: "transitionIn",
                value: function() {
                    var t = this;
                    return this.exitPortal = null, new Promise((function(e) {
                        t.tl && t.tl.kill(), t.tl = new gsap.timeline({
                            onComplete: e
                        }), Kp.setFOV(parseInt(t.infos.fov ? t.infos.fov : Kp.defaultFOV)), t.tl.call(Kp.startTransition), t.tl.set(t, {
                            visible: !0
                        }), t.tl.add(mv[vv()].in(t)), t.tl.set(Kp.orbit, {
                            enabled: !0
                        }), t.tl.call(Kp.endTransition)
                    }))
                }
            }, {
                key: "transitionOut",
                value: function() {
                    var t = this;
                    return new Promise((function(e) {
                        t.portals.forEach((function(t) {
                            return t.hide()
                        })), t.tl && t.tl.kill(), t.tl = new gsap.timeline({
                            onComplete: e
                        }), t.tl.call(Kp.startTransition), t.tl.set(Kp.orbit, {
                            enabled: !1
                        }), t.tl.add(mv[vv()].out(t)), t.tl.set(t, {
                            visible: !1
                        }), t.tl.call(Kp.endTransition)
                    }))
                }
            }, {
                key: "onClick",
                value: function() {
                    var t;
                    ! of () && this.activePortal && (this.isExiting = !0, this.exitPortal = this.activePortal, this.activePortal.click(), t = this.activePortal.infos.transition, gv = t, this.emitter.emit("portal:click", this.activePortal.infos))
                }
            }, {
                key: "onMouseDown",
                value: function(t) {
                    this.startDrag.set(t.clientX, t.clientY)
                }
            }, {
                key: "onMouseUp",
                value: function(t) {
                    this.currentDrag.set(t.clientX, t.clientY), this.currentDrag.distanceTo(this.startDrag) <= this.dragThreshold && this.onClick()
                }
            }, {
                key: "destroy",
                value: function() {
                    var t;
                    this.emitter.off("*"), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mousedown", this.onMouseDown), window.removeEventListener("mouseup", this.onMouseUp), t = this.onUIOver, L.off("ui:over", t), this.skyMesh.material.map.dispose(), this.skyMesh.material.dispose(), this.portals.forEach((function(t) {
                        return t.destroy()
                    })), this.hints.forEach((function(t) {
                        return t.destroy()
                    }))
                }
            }]) && Zv(e.prototype, n), i && Zv(e, i), o
        }(Vn);

    function ry(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var oy = new(function() {
        function t(e) {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.loader = new au, this.textures = {}, this.renderer = e
        }
        var e, n, i;
        return e = t, (n = [{
            key: "loadMultiples",
            value: function(t) {
                var e = this;
                return Promise.all(t.map((function(t) {
                    return e.loadOne(t)
                })))
            }
        }, {
            key: "loadOne",
            value: function(t) {
                var e = this;
                return new Promise((function(n) {
                    e.loader.load(function(t) {
                        return "/SilentFamilyShadow/assets/textures/equirectangular/" + (t.alt && xf() ? t.alt : t.name) + ".jpg"
                    }(t), (function(i) {
                        e.renderer && e.renderer.initTexture(i), e.textures[t.id] = i, n(Object.assign(t, {
                            texture: i
                        }))
                    }))
                }))
            }
        }, {
            key: "unloadUseless",
            value: function(t) {
                var e = this,
                    n = t.map((function(t) {
                        return t.id
                    }));
                Object.keys(this.textures).forEach((function(t) {
                    n.indexOf(t) < 0 && (e.textures[t].dispose(), delete e.textures[t])
                }))
            }
        }]) && ry(e.prototype, n), i && ry(e, i), t
    }());

    function sy(t) {
        return (sy = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function ay(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function cy(t, e) {
        return (cy = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function ly(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = py(t);
            if (e) {
                var r = py(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return uy(this, n)
        }
    }

    function uy(t, e) {
        return !e || "object" !== sy(e) && "function" != typeof e ? hy(t) : e
    }

    function hy(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function py(t) {
        return (py = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var fy = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && cy(t, e)
            }(o, t);
            var e, n, i, r = ly(o);

            function o() {
                var t;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (t = r.call(this)).history = [], t.start = t.start.bind(hy(t)), t.onPortalClick = t.onPortalClick.bind(hy(t)), t.onLastSouvenirFound = t.onLastSouvenirFound.bind(hy(t));
                var e = 10..toString();
                return t.lastPortal = null, oy.loadOne(t.getById(e)).then(t.start), wf(t.onLastSouvenirFound), t
            }
            return e = o, (n = [{
                key: "start",
                value: function(t) {
                    this.current = this.prepareCurrentRoom(t)
                }
            }, {
                key: "prepareCurrentRoom",
                value: function(t, e) {
                    var n = this.getNeighborsInfos(t),
                        i = new iy(t),
                        r = 18 === parseInt(t.id),
                        o = !r && !this.history.length;
                    r ? i.setManualEnteringView(1.44, -.5) : o ? i.setManualEnteringView(1.44, .1) : i.setEnteringView(this.history[this.history.length - 1], e), this.add(i), r ? i.ending() : o ? i.starting() : i.transitionIn(), i.emitter.on("portal:click", this.onPortalClick);
                    var s = [t].concat(n);
                    return oy.loadMultiples(n).then((function() {
                        oy.unloadUseless(s)
                    })), this.history.push(t.id), i
                }
            }, {
                key: "onLastSouvenirFound",
                value: function() {
                    oy.loadOne(this.getById(21..toString()))
                }
            }, {
                key: "onPortalClick",
                value: function(t) {
                    var e = this;
                    this.current.emitter.off("portal:click", this.onPortalClick), this.current.transitionOut().then((function() {
                        e.remove(e.current), e.current.destroy(), e.current = e.prepareCurrentRoom(e.getById(t.room), t)
                    })), 18 === parseInt(t.room) && c.emit("loadvideoend")
                }
            }, {
                key: "getNeighborsInfos",
                value: function(t) {
                    var e = this;
                    return t.portals.map((function(t) {
                        return e.getById(t.room)
                    }))
                }
            }, {
                key: "getById",
                value: function(t) {
                    var e = tf.a.filter((function(e) {
                        return e.id === t
                    }));
                    return e.length ? e[0] : null
                }
            }, {
                key: "update",
                value: function(t, e, n) {
                    this.current && this.current.update(t, e, n)
                }
            }]) && ay(e.prototype, n), i && ay(e, i), o
        }(Vn),
        dy = "#define GLSLIFY 1\nattribute float size;\nattribute float opacity;\n\nvarying float vOpacity;\n\nvoid main() {\n  vOpacity = opacity;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = size * (300.0 / -mvPosition.z);\n  gl_Position = projectionMatrix * mvPosition;\n}",
        my = "#define GLSLIFY 1\nuniform sampler2D pointTexture;\n\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n  gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);\n}";

    function gy(t) {
        return (gy = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function vy(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function yy(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function by(t, e) {
        return (by = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function xy(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = _y(t);
            if (e) {
                var r = _y(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return wy(this, n)
        }
    }

    function wy(t, e) {
        return !e || "object" !== gy(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function _y(t) {
        return (_y = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var My = new yn;

    function Sy(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5;
        return My.set((2 * Math.random() - 1) * t, (2 * Math.random() - 1) * t, (2 * Math.random() - 1) * t), My.length() < t * e ? Sy(t, e) : My.toArray()
    }
    var Ty = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && by(t, e)
        }(o, t);
        var e, n, i, r = xy(o);

        function o() {
            var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                n = e.amount,
                i = void 0 === n ? 1e3 : n,
                s = e.speed,
                a = void 0 === s ? new yn(0, .001, 0) : s,
                c = e.radius,
                l = void 0 === c ? 10 : c,
                u = e.minSize,
                h = void 0 === u ? .1 : u,
                p = e.maxSize,
                f = void 0 === p ? 3 : p,
                d = e.minOpacity,
                m = void 0 === d ? 0 : d,
                g = e.maxOpacity,
                v = void 0 === g ? 1 : g,
                y = e.texture,
                b = void 0 === y ? null : y;
            vy(this, o), (t = r.call(this)).speed = a;
            for (var x = [], w = [], _ = [], M = [], S = 0; S < i; S++) {
                var T = Sy(l);
                x.push(T[0]), x.push(T[1]), x.push(T[2]), w.push(Math.random() * Math.PI * 2), w.push(Math.random() * Math.PI * 2), w.push(Math.random() * Math.PI * 2), _.push(h + Math.random() * f), M.push(m + Math.random() * v)
            }
            t.geometry = new ur, t.geometry.setAttribute("position", new Qi(x, 3)), t.geometry.setAttribute("size", new Qi(_, 1)), t.geometry.setAttribute("opacity", new Qi(M, 1));
            var E = new jr({
                vertexShader: dy,
                fragmentShader: my,
                uniforms: {
                    pointTexture: {
                        value: b
                    }
                },
                blending: 2,
                depthTest: !1,
                transparent: !0,
                vertexColors: !0
            });
            return t.system = new nc(t.geometry, E), t.add(t.system), t
        }
        return e = o, (n = [{
            key: "update",
            value: function(t) {
                this.system.rotation.x += this.speed.x * t, this.system.rotation.y += this.speed.y * t, this.system.rotation.z += this.speed.z * t
            }
        }]) && yy(e.prototype, n), i && yy(e, i), o
    }(Vn);

    function Ey(t) {
        return (Ey = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Cy(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Ay(t, e) {
        return (Ay = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Ly(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Oy(t);
            if (e) {
                var r = Oy(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Py(this, n)
        }
    }

    function Py(t, e) {
        return !e || "object" !== Ey(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function Oy(t) {
        return (Oy = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Ry = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Ay(t, e)
        }(o, t);
        var e, n, i, r = Ly(o);

        function o() {
            var t;
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), (t = r.call(this)).smalls = new Ty({
                texture: wm.get("dust1"),
                amount: 250,
                speed: new yn(1e-4, 5e-4, 0),
                maxSize: 2
            }), t.add(t.smalls), t.smalls2 = new Ty({
                texture: wm.get("dust3"),
                amount: 250,
                speed: new yn(-1e-4, 7e-4, 0),
                maxSize: .6
            }), t.add(t.smalls2), t.mediums = new Ty({
                texture: wm.get("dust2"),
                amount: 25,
                speed: new yn(0, -5e-4, 0),
                minSize: 0,
                maxSize: .6
            }), t.add(t.mediums), t.bigs = new Ty({
                texture: wm.get("dust4"),
                amount: 7,
                speed: new yn(0, -3e-4, 0),
                minSize: 2,
                maxSize: 3
            }), t.add(t.bigs), t.speed = 1, t
        }
        return e = o, (n = [{
            key: "update",
            value: function() {
                this.smalls.update(this.speed), this.smalls2.update(this.speed), this.mediums.update(this.speed), this.bigs.update(this.speed)
            }
        }]) && Cy(e.prototype, n), i && Cy(e, i), o
    }(Vn);

    function Iy(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Dy = function() {
        function t(e, n, i) {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.animate = this.animate.bind(this), this.resize = this.resize.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onLoadComplete = this.onLoadComplete.bind(this), this.onOpenInventaire = this.onOpenInventaire.bind(this), this.onCloseInventaire = this.onCloseInventaire.bind(this), this.onPauseStart = this.onPauseStart.bind(this), this.onPauseEnd = this.onPauseEnd.bind(this), this.preloadCompleteCallback = n, this.usePostprocessing = !0, this.isAlive = !0, this.canvas = e, this.renderer = new ra({
                canvas: e
            }), this.scene = new Wn, this.clock = new dh, this.clock.start(), this.then = Date.now(), this.startTime = this.then, this.light1 = new Uu, this.scene.add(this.light1), this.target = new yn, this.mouse = [.5, .5], this.cursor = i, this.camera = new Gr(Kp.defaultFOV, window.innerWidth / window.innerHeight, .1, 1e3), this.camera.position.x = 5, Kp.init(this.camera, this.renderer.domElement), wm.isComplete ? this.onLoadComplete() : (wm.init(new Sm, new Em(this.renderer), new Am), wm.load([{
                type: "texture",
                id: "dust1",
                url: "textures/dust1.png"
            }, {
                type: "texture",
                id: "dust2",
                url: "textures/dust2.png"
            }, {
                type: "texture",
                id: "dust3",
                url: "textures/dust3.png"
            }, {
                type: "texture",
                id: "dust4",
                url: "textures/dust4.png"
            }, {
                type: "texture",
                id: "sil_01",
                linear: !0,
                url: "textures/hints/sil_01.png"
            }, {
                type: "texture",
                id: "sil_02",
                linear: !0,
                url: "textures/hints/sil_02.png"
            }, {
                type: "texture",
                id: "sil_03",
                linear: !0,
                url: "textures/hints/sil_03.png"
            }, {
                type: "texture",
                id: "fenetre",
                linear: !0,
                url: "textures/hints/fenetre.png"
            }, {
                type: "texture",
                id: "sil_04",
                linear: !0,
                url: "textures/hints/sil_04_pied.png"
            }, {
                type: "texture",
                id: "torchlightsTexture",
                url: "textures/torchlight-min.png"
            }], "/SilentFamilyShadow/assets/").then(this.onLoadComplete))
        }
        var e, n, i;
        return e = t, (n = [{
            key: "onLoadComplete",
            value: function() {
                Vt(0), wm.isComplete = !0, fv.init(this), Kp.orbit.emitter.on("rotate", (function(t) {
                    fv.chromaticAberrationEffect.intensity += .2 * (t.x / 10 - fv.chromaticAberrationEffect.intensity), Xg.screen.material.uniforms.delta.value.x += .2 * (t.x / 10 - Xg.screen.material.uniforms.delta.value.x)
                })), this.roomManager = new fy, this.scene.add(this.roomManager), this.roomManager.position.copy(this.camera.position), this.particles = new Ry, this.scene.add(this.particles), this.resize(), window.addEventListener("resize", this.resize), window.addEventListener("mousemove", this.onMouseMove), this.renderer.compile(this.scene, this.camera), this.preloadCompleteCallback(), gsap.ticker.add(this.animate), af(this.onOpenInventaire), cf(this.onCloseInventaire), Ef(this.onPauseStart), Cf(this.onPauseEnd)
            }
        }, {
            key: "onOpenInventaire",
            value: function() {
                mv.inventaire.in()
            }
        }, {
            key: "onCloseInventaire",
            value: function() {
                mv.inventaire.out()
            }
        }, {
            key: "onPauseStart",
            value: function() {
                mv.pause.in(this.roomManager.current)
            }
        }, {
            key: "onPauseEnd",
            value: function() {
                mv.pause.out(this.roomManager.current)
            }
        }, {
            key: "onMouseMove",
            value: function(t) {
                var e = t.clientX,
                    n = t.clientY;
                this.mouse[0] = e / window.innerWidth, this.mouse[1] = n / window.innerHeight
            }
        }, {
            key: "resize",
            value: function() {
                this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight), fv.setSize(window.innerWidth, window.innerHeight)
            }
        }, {
            key: "animate",
            value: function() {
                this.now = Date.now(), this.elapsed = this.now - this.then, this.isAlive && this.elapsed > 1e3 / 60 && (this.then = this.now - this.elapsed % (1e3 / 60), this.update())
            }
        }, {
            key: "update",
            value: function() {
                if (!fv.stopped) {
                    Kp.update();
                    var t = this.clock.getElapsedTime(),
                        e = this.elapsed % (1e3 / 60);
                    this.particles.update(t), fv.render(t, e, this.mouse), this.roomManager && this.roomManager.update(this.camera, t, e), this.cursor.update(t), dd.position.copy(this.camera.position), dd.rotation.copy(this.camera.rotation), ud.render(fd, dd)
                }
            }
        }, {
            key: "destroy",
            value: function() {
                window.cancelAnimationFrame(this.raf), window.removeEventListener("resize", this.resize), this.isAlive = !1
            }
        }]) && Iy(e.prototype, n), i && Iy(e, i), t
    }();

    function Ny(t) {
        return (Ny = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }
    var ky, Uy, By = function(t, e) {
        return function() {
            return t.apply(e, arguments)
        }
    };
    window.Device = function() {
        function t() {
            this._handleOrientation = By(this._handleOrientation, this), this._handleResize = By(this._handleResize, this), this.onDOMloaded = By(this.onDOMloaded, this), this.previousDevice = window.device, window.device = {}, this._doc_element = null, this._user_agent = window.navigator.userAgent.toLowerCase()
        }
        return t.prototype.osx = function() {
            return this._find("mac os x")
        }, t.prototype.ios = function() {
            return this.iphone() || this.ipod() || this.ipad()
        }, t.prototype.iphone = function() {
            return this._find("iphone")
        }, t.prototype.ipod = function() {
            return this._find("ipod")
        }, t.prototype.ipad = function() {
            return this._find("ipad")
        }, t.prototype.android = function() {
            return this._find("android")
        }, t.prototype.chrome = function() {
            return this._find("chrome") && !this.edge()
        }, t.prototype.firefox = function() {
            return this._find("firefox")
        }, t.prototype.ie = function() {
            return null !== new RegExp("trident/.*rv:([0-9]{1,}[.0-9]{0,})").exec(this._user_agent) || null !== new RegExp("msie").exec(this._user_agent)
        }, t.prototype.ie12 = function() {
            return this._find("msie 12.0")
        }, t.prototype.ie11 = function() {
            return this._find("msie 11.0")
        }, t.prototype.ie10 = function() {
            return this._find("msie 10.0")
        }, t.prototype.ie9 = function() {
            return this._find("msie 9.0")
        }, t.prototype.ie8 = function() {
            return this._find("msie 8.0")
        }, t.prototype.ie7 = function() {
            return this._find("msie 7.0")
        }, t.prototype.ie6 = function() {
            return this._find("msie 6.0")
        }, t.prototype.safari = function() {
            return this._find("safari")
        }, t.prototype.androidPhone = function() {
            return this.android() && this._find("mobile")
        }, t.prototype.androidTablet = function() {
            return window.innerWidth, this.android() && !this._find("mobile")
        }, t.prototype.blackberry = function() {
            return this._find("blackberry") || this._find("bb10") || this._find("rim")
        }, t.prototype.blackberryPhone = function() {
            return this.blackberry() && !this._find("tablet")
        }, t.prototype.blackberryTablet = function() {
            return this.blackberry() && this._find("tablet")
        }, t.prototype.windows = function() {
            return this._find("windows")
        }, t.prototype.windowsPhone = function() {
            return this.windows() && this._find("phone")
        }, t.prototype.windowsTablet = function() {
            return this.windows() && this._find("touch") && !this.windowsPhone()
        }, t.prototype.fxos = function() {
            return (this._find("(mobile;") || this._find("(tablet;")) && this._find("; rv:")
        }, t.prototype.fxosPhone = function() {
            return this.fxos() && this._find("mobile")
        }, t.prototype.fxosTablet = function() {
            return this.fxos() && this._find("tablet")
        }, t.prototype.meego = function() {
            return this._find("meego")
        }, t.prototype.edge = function() {
            return this._find("edge")
        }, t.prototype.cordova = function() {
            return window.cordova && "file:" === location.protocol
        }, t.prototype.nodeWebkit = function() {
            return "object" === Ny(window.process)
        }, t.prototype.mobile = function() {
            return this.androidPhone() || this.iphone() || this.ipod() || this.windowsPhone() || this.blackberryPhone() || this.fxosPhone() || this.meego()
        }, t.prototype.tablet = function() {
            return this.ipad() || this.androidTablet() || this.blackberryTablet() || this.windowsTablet() || this.fxosTablet()
        }, t.prototype.desktop = function() {
            return !this.tablet() && !this.mobile()
        }, t.prototype.nexus5 = function() {
            return this._find("nexus 5")
        }, t.prototype.portrait = function() {
            return window.innerHeight / window.innerWidth > 1
        }, t.prototype.landscape = function() {
            return window.innerHeight / window.innerWidth < 1
        }, t.prototype.noConflict = function() {
            return window.device = this.previousDevice, this
        }, t.prototype.browserVersion = function() {
            var t, e, n, i;
            return n = void 0, (e = (i = navigator.userAgent).match(/(edge(?=\/))\/?\s*(\d+)/i) || []).length ? {
                name: e[1],
                version: e[2]
            } : (t = i.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [], /trident/i.test(t[1]) ? {
                name: "IE ",
                version: (n = /\brv[ :]+(\d+)/g.exec(i) || [])[1] || ""
            } : "Chrome" === t[1] && null !== (n = i.match(/\bOPR\/(\d+)/)) ? {
                name: "Opera",
                version: n[1]
            } : (t = t[2] ? [t[1], t[2]] : [navigator.appName, navigator.appVersion, "-?"], null !== (n = i.match(/version\/(\d+)/i)) && t.splice(1, 1, n[1]), {
                name: t[0],
                version: t[1]
            }))
        }, t.prototype._find = function(t) {
            return -1 !== this._user_agent.indexOf(t)
        }, t.prototype._hasClass = function(t) {
            var e;
            return e = new RegExp(t, "i"), this._doc_element.className.match(e)
        }, t.prototype._addClass = function(t) {
            if (!this._hasClass(t)) return this._doc_element.className += " " + t
        }, t.prototype._removeClass = function(t) {
            if (this._hasClass(t)) return this._doc_element.className = this._doc_element.className.replace(t, "")
        }, t.prototype.onDOMloaded = function() {
            return this._doc_element = window.document.body, this.ios() ? this.ipad() ? this._addClass("ios ipad tablet") : this.iphone() ? this._addClass("ios iphone mobile") : this.ipod() && this._addClass("ios ipod mobile") : this.android() ? this.desktop() ? this._addClass("android desktop error-android-resolution") : this.androidTablet() ? this._addClass("android tablet") : this._addClass("android mobile") : this.blackberry() ? this.blackberryTablet() ? this._addClass("blackberry tablet") : this._addClass("blackberry mobile") : this.windows() ? this.windowsTablet() ? this._addClass("windows tablet") : this.windowsPhone() ? this._addClass("windows mobile") : this.windows() && this._addClass("windows desktop") : this.fxos() ? this.fxosTablet() ? this._addClass("fxos tablet") : this._addClass("fxos mobile") : this.meego() ? this._addClass("meego mobile") : this.nodeWebkit() ? this._addClass("node-webkit") : this.osx() ? this._addClass("osx desktop") : this._addClass("desktop"), this.desktop() && this._addClass("desktop"), this.cordova() && this._addClass("cordova"), this.chrome() && this._addClass("chrome"), this.edge() && this._addClass("msedge"), this.firefox() && this._addClass("firefox"), this.ie() && (this._addClass("ie"), this.ie6() ? this._addClass("ie6") : this.ie7() ? this._addClass("ie7") : this.ie8() ? this._addClass("ie8") : this.ie9() ? this._addClass("ie9") : this.ie10() ? this._addClass("ie10") : this._addClass("ie11")), this._supports_orientation = "onorientationchange" in window, this._orientation_event = (this._supports_orientation, "orientationchange"), window.addEventListener ? window.addEventListener("resize", this._handleResize, !1) : document.attachEvent("resize", this._handleResize), this._handleResize()
        }, t.prototype.orientationCallback = null, t.prototype._handleResize = function() {
            var t;
            t = "portrait", this.landscape() ? (this._removeClass("portrait"), this._addClass("landscape"), t = "landscape") : (this._removeClass("landscape"), this._addClass("portrait")), "function" == typeof this.orientationCallback && this.orientationCallback(t)
        }, t.prototype._handleOrientation = function(t) {
            var e;
            e = "portrait", this.landscape() ? (this._removeClass("portrait"), this._addClass("landscape"), e = "landscape") : (this._removeClass("landscape"), this._addClass("portrait")), "function" == typeof this.orientationCallback && this.orientationCallback(e)
        }, t
    }(), ky = function() {
        var t, e;

        function n() {}
        return e = null, n.get = function() {
            return null != e ? e : e = new t
        }, t = function() {
            function t() {
                this.onChangeOrientation = By(this.onChangeOrientation, this), this.device = new window.Device, this.browserVersion = this.device.browserVersion(), this.isOSX = this.device.osx(), this.isIpad = this.device.ios() && this.device.ipad(), this.isIphone = this.device.ios() && (this.device.iphone() || this.device.ipod), this.isIos = this.device.ios(), this.isAndroidTablet = this.device.android() && this.device.androidTablet(), this.device.android() && !this.device.androidTablet() && (this.isAndroidPhone = !0), this.isAndroid = this.device.android(), this.isTablet = this.device.tablet(), this.isMobile = this.device.mobile(), this.isDesktop = this.device.desktop(), this.isNexus5 = this.device.nexus5(), this.isWindow = this.device.windows(), this.isWindowsPhone = this.device.windowsPhone(), this.isWindowsTablet = this.device.windowsTablet(), this.isChrome = this.device.chrome(), this.isFirefox = this.device.firefox(), this.isMSEdge = this.device.edge(), this.isIE = this.device.ie(), this.isIE6 = this.device.ie6(), this.isIE7 = this.device.ie7(), this.isIE8 = this.device.ie8(), this.isIE9 = this.device.ie9(), this.isIE10 = this.device.ie10(), this.isIE11 = this.device.ie11(), this.isIE12 = this.device.ie12(), this.isIEDesktop = this.device.ie() && !this.device.windowsPhone() && !this.device.windowsTablet(), this.isltIE10 = this.device.ie9() || this.device.ie8() || this.device.ie7() || this.device.ie6(), this.islteIE10 = this.device.ie10() || this.device.ie9() || this.device.ie8() || this.device.ie7() || this.device.ie6(), this.isltIE9 = this.device.ie8() || this.device.ie7() || this.device.ie6(), this.islteIE9 = this.device.ie9() || this.device.ie8() || this.device.ie7() || this.device.ie6(), this.isSafari = !this.device.chrome() && this.device.safari(), this.isLandscape = this.device.landscape(), this.isPortrait = this.device.portrait(), this.isGalaxyTab10inches = this.device.android() && Uy("(min-device-width: 1280px) and (max-device-width: 1281px) and (orientation: landscape), (min-device-width: 800px) and (max-device-width: 801px) and (orientation: portrait)"), this.isGalaxyTab7inches = this.device.android() && Uy("(min-device-width: 1024px) and (max-device-width: 1025px) and (orientation: landscape), (min-device-width: 600px) and (max-device-width: 601px) and (orientation: portrait)"), this.isGalaxyTab = this.isGalaxyTab7inches || this.isGalaxyTab10inches, this.isAndroid && this.isGalaxyTab && this.forceGalaxyTab()
            }
            return t.prototype.forceGalaxyTab = function() {
                return this.device.desktop = function() {
                    return !0
                }, this.device.tablet = function() {
                    return !1
                }, this.device.mobile = function() {
                    return !1
                }, this.isDesktop = this.device.desktop(), this.isTablet = this.device.tablet(), this.isMobile = this.device.mobile()
            }, t.prototype.bindEvents = function() {
                return this.device.onDOMloaded()
            }, t.prototype.onChangeOrientation = function(t) {
                if (null == t && (t = null), null != t) return this.device.orientationCallback = t
            }, t
        }(), n
    }(), Uy = function(t) {
        if (null != window.matchMedia) switch ("(min-device-width: 1024px)", "(min-device-width: 768px) and (max-device-width: 1023px)", "(min-device-width: 320px) and (max-device-width: 767px)", t) {
            case "mobile":
                return window.matchMedia("(min-device-width: 320px) and (max-device-width: 767px)").matches;
            case "tablet":
                return window.matchMedia("(min-device-width: 768px) and (max-device-width: 1023px)").matches;
            case "desktop":
                return window.matchMedia("(min-device-width: 1024px)").matches;
            default:
                return window.matchMedia(t).matches
        }
    }, window.BrowserDetect = ky.get(), window.BrowserDetect.bindEvents();
    var zy = window.BrowserDetect;

    function Fy(t) {
        return (Fy = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function jy(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Hy(t, e, n) {
        return (Hy = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
            var i = function(t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Xy(t)););
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        })(t, e, n || t)
    }

    function Gy(t, e) {
        return (Gy = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Vy(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Xy(t);
            if (e) {
                var r = Xy(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Wy(this, n)
        }
    }

    function Wy(t, e) {
        return !e || "object" !== Fy(e) && "function" != typeof e ? qy(t) : e
    }

    function qy(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Xy(t) {
        return (Xy = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Zy = !1,
        Yy = function(t) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Gy(t, e)
            }(o, t);
            var e, n, i, r = Vy(o);

            function o(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, o), (e = r.call(this, t)).start = e.start.bind(qy(e)), zy.isDesktop && (Zy ? e.start() : c.on("rootComponent", e.start)), e
            }
            return e = o, (n = [{
                key: "start",
                value: function() {
                    Zy = !0, this.webgl = new Dy(this.$one(".Webgl"), (function() {}), this.root.findInstance("Cursor"))
                }
            }, {
                key: "transitionIn",
                value: function(t) {
                    this.tl && this.tl.kill(), this.tl = gsap.timeline({
                        onComplete: t
                    }), this.tl.set(this.$el, {
                        visibility: "visible"
                    }), this.tl.fromTo(this.$el, {
                        alpha: 0
                    }, {
                        alpha: 1,
                        duration: .4
                    }, 0)
                }
            }, {
                key: "transitionOut",
                value: function(t) {
                    this.tl && this.tl.kill(), this.tl = gsap.timeline({
                        onComplete: t
                    }), this.tl.to(this.$el, {
                        alpha: 0,
                        duration: .4
                    }, 0)
                }
            }, {
                key: "destroy",
                value: function() {
                    this.tl && this.tl.kill(), Hy(Xy(o.prototype), "destroy", this).call(this)
                }
            }, {
                key: "destroy",
                value: function() {
                    this.webgl.destroy(), Hy(Xy(o.prototype), "destroy", this).call(this)
                }
            }]) && jy(e.prototype, n), i && jy(e, i), o
        }(s.a);

    function $y(t) {
        return ($y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Jy(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Ky(t, e, n) {
        return (Ky = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
            var i = function(t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = nb(t)););
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        })(t, e, n || t)
    }

    function Qy(t, e) {
        return (Qy = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function tb(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = nb(t);
            if (e) {
                var r = nb(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return eb(this, n)
        }
    }

    function eb(t, e) {
        return !e || "object" !== $y(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function nb(t) {
        return (nb = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var ib = function(t) {
        ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Qy(t, e)
        }(o, t);
        var e, n, i, r = tb(o);

        function o(t) {
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, o), r.call(this, t)
        }
        return e = o, (n = [{
            key: "transitionIn",
            value: function(t) {
                this.tl && this.tl.kill(), this.tl = gsap.timeline({
                    onComplete: t
                }), this.tl.set(this.$el, {
                    visibility: "visible"
                }), this.tl.fromTo(this.$el, {
                    alpha: 0
                }, {
                    alpha: 1,
                    duration: .4
                }, 0)
            }
        }, {
            key: "transitionOut",
            value: function(t) {
                this.tl && this.tl.kill(), this.tl = gsap.timeline({
                    onComplete: t
                }), this.tl.to(this.$el, {
                    alpha: 0,
                    duration: .4
                }, 0)
            }
        }, {
            key: "destroy",
            value: function() {
                this.tl && this.tl.kill(), Ky(nb(o.prototype), "destroy", this).call(this)
            }
        }]) && Jy(e.prototype, n), i && Jy(e, i), o
    }(s.a);
    if ("maxTouchPoints" in navigator) navigator.maxTouchPoints > 0;
    else if ("msMaxTouchPoints" in navigator) navigator.msMaxTouchPoints > 0;
    else {
        var rb = window.matchMedia && matchMedia("(pointer:coarse)");
        if (rb && "(pointer:coarse)" === rb.media) !!rb.matches;
        else if ("orientation" in window) !0;
        else {
            var ob = navigator.userAgent;
            /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(ob) || /\b(Android|Windows Phone|iPad|iPod)\b/i.test(ob)
        }
    }
    window.innerWidth;
    n(11);
    window.lang = document.body.getAttribute("data-lang"), document.body.style.visibility = "visible", (self.createImageBitmap ? fetch("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=").then((function(t) {
        return t.blob()
    })).then((function(t) {
        return createImageBitmap(t)
    })).then((function() {
        return !0
    }), (function() {
        return !1
    })) : new Promise((function(t) {
        return t(!1)
    }))).then((function(t) {
        t ? document.body.setAttribute("class", "webp") : document.body.setAttribute("class", "no-webp")
    }));
    var sb, ab, cb, lb, ub, hb = (sb = document.body, ab = i, r = new s.a(sb, (function(t) {
        return ab[t]
    })), c.emit("rootComponent"), r);
    zy.isDesktop ? (cb = hb, lb = document.querySelector("script#main").getAttribute("src").replace(/\/?build.js/g, "").replace(/^\//, ""), ub = g ? f.a.map((function(t) {
        return Object.assign(t, {
            path: "/:lang/" + t.path
        })
    })) : f.a, (y = Object(h.createRouter)(cb, {
        routes: ub,
        baseUrl: lb,
        verbose: !1,
        beforeCompile: function(t) {
            return [].slice.call(t.querySelectorAll(window.isMobile ? ".brindille--desktop [data-component]" : ".brindille--mobile [data-component]")).forEach((function(t) {
                return t.setAttribute("data-component", "")
            })), Promise.resolve(t)
        },
        getContent: function(t) {
            var e;
            return e = t.base + t.path + "/partial.html", window.fetch(e, {
                headers: {
                    "X-Requested-With": "XMLHttpRequest"
                }
            }).then((function(t) {
                return t.text()
            }))
        }
    })).on("update", w), y.on("update", _), y.on("start", x), y).start() : (Oe("Fallback", "Display", "Utilisateur sur fallback"), hb.$one(".Fallback").style.display = "block", hb.$one(".Logo").style.display = "none", hb.$one(".Intro").style.display = "none", hb.$one(".Tuto").style.display = "none", hb.$one(".Languages").style.display = "none", hb.$one(".Footer").style.display = "none", hb.$one(".Inventaire").style.display = "none", hb.$one(".Cursor").style.display = "none", hb.$one("#Css3d").style.display = "none")
}]);